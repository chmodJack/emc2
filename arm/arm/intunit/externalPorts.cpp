/***************************************************************************//**
*
*           _/       _/_/_/      _/         _/
*         _/_/      _/    _/    _/_/      __/
*       _/  _/     _/    _/    _/ _/    _/_/
*     _/_/_/_/    _/_/_/      _/  _/  _/ _/
*   _/      _/   _/    _/    _/   _/_/  _/
* _/        _/  _/      _/  _/    _/   _/
*
* @brief    This file is part of the SoCRocket ARM ISS generated by TRAP.
* @details  This SystemC model was automatically generated by running
*           $ python ARMArch.py
*           Please refer to the ARM TRAP source files for documentation.
* @author   Lillian Tadros (TUDO ETIT IRF)
* @date     2014-12-01 tadros: Initial ARM Cortex A9 (ARMv7-A) version
*
*
* (c) 2014-2016
* Technische Universitaet Dortmund
* Institut fuer Roboterforschung
* Project Embedded Multi-Core Systems for Mixed Criticality
* Applications in Dynamic and Changeable Real-time Environments (EMC2)
*
*
* This file is part of ARMCortexA9.
*
* ARMCortexA9 is free software; you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License as
* published by the Free Software Foundation; either version 3 of the
* License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Affero General Public License for more details.
*
* You should have received a copy of the GNU Affero General Public
* License along with this program; if not, write to the
* Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
* or see <http://www.gnu.org/licenses/>.
*
*******************************************************************************/

#include "arm/intunit/externalPorts.hpp"
#include "arm/intunit/memory.hpp"


#include <systemc.h>
#include <common/tools_if.hpp>
#include <common/report.hpp>
#include <tlm.h>
#include <tlm_utils/simple_initiator_socket.h>
#include <tlm_utils/tlm_quantumkeeper.h>


using namespace core_armcortexa9_lt;

void core_armcortexa9_lt::TLMMemory::set_debugger(MemoryToolsIf<unsigned>*
debugger) {
  this->debugger = debugger;
} // set_debugger()
/// ----------------------------------------------------------------------------

sc_dt::uint64 core_armcortexa9_lt::TLMMemory::read_dword(const unsigned& address)
throw() {
  sc_dt::uint64 datum = 0;
  if (this->dmi_ptr_valid) {
    if (address + this->dmi_data.get_start_address() > this->dmi_data.get_end_address())
    {
      SC_REPORT_ERROR("TLM-2", "Error in reading memory data through DMI: address out of bounds");
    }
    memcpy(&datum, this->dmi_data.get_dmi_ptr() - this->dmi_data.get_start_address()
    + address, sizeof(datum));
    this->quant_keeper.inc(this->dmi_data.get_read_latency());
    if (this->quant_keeper.need_sync()) {
      this->quant_keeper.sync();
    }

  } else {
    sc_time delay = this->quant_keeper.get_local_time();
    tlm::tlm_generic_payload trans;
    trans.set_address(address);
    trans.set_read();
    trans.set_data_ptr(reinterpret_cast<unsigned char*>(&datum));
    trans.set_data_length(sizeof(datum));
    trans.set_streaming_width(sizeof(datum));
    trans.set_byte_enable_ptr(0);
    trans.set_dmi_allowed(false);
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    this->init_socket->b_transport(trans, delay);

    if (trans.is_response_error()) {
      std::string error_str("Error from b_transport, response status = " +
      trans.get_response_string());
      SC_REPORT_ERROR("TLM-2", error_str.c_str());
    }
    if (trans.is_dmi_allowed()) {
      this->dmi_data.init();
      this->dmi_ptr_valid = this->init_socket->get_direct_mem_ptr(trans, this->dmi_data);
    }
    // Keep track of time.
    this->quant_keeper.set(delay);
    if (this->quant_keeper.need_sync()) {
      this->quant_keeper.sync();
    }
  }
#ifdef BIG_ENDIAN_BO
  unsigned datum1 = (unsigned)(datum);
  this->swap_endianess(datum1);
  unsigned datum2 = (unsigned)(datum >> 32);
  this->swap_endianess(datum2);
  datum = datum1 | (((sc_dt::uint64)datum2) << 32);
#endif

  return datum;
} // read_dword()
/// ----------------------------------------------------------------------------

/// ----------------------------------------------------------------------------

unsigned short int core_armcortexa9_lt::TLMMemory::read_half(const unsigned&
address) throw() {
  unsigned short int datum = 0;
  if (this->dmi_ptr_valid) {
    if (address + this->dmi_data.get_start_address() > this->dmi_data.get_end_address())
    {
      SC_REPORT_ERROR("TLM-2", "Error in reading memory data through DMI: address out of bounds");
    }
    memcpy(&datum, this->dmi_data.get_dmi_ptr() - this->dmi_data.get_start_address()
    + address, sizeof(datum));
    this->quant_keeper.inc(this->dmi_data.get_read_latency());
    if (this->quant_keeper.need_sync()) {
      this->quant_keeper.sync();
    }

  } else {
    sc_time delay = this->quant_keeper.get_local_time();
    tlm::tlm_generic_payload trans;
    trans.set_address(address);
    trans.set_read();
    trans.set_data_ptr(reinterpret_cast<unsigned char*>(&datum));
    trans.set_data_length(sizeof(datum));
    trans.set_streaming_width(sizeof(datum));
    trans.set_byte_enable_ptr(0);
    trans.set_dmi_allowed(false);
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    this->init_socket->b_transport(trans, delay);

    if (trans.is_response_error()) {
      std::string error_str("Error from b_transport, response status = " +
      trans.get_response_string());
      SC_REPORT_ERROR("TLM-2", error_str.c_str());
    }
    if (trans.is_dmi_allowed()) {
      this->dmi_data.init();
      this->dmi_ptr_valid = this->init_socket->get_direct_mem_ptr(trans, this->dmi_data);
    }
    // Keep track of time.
    this->quant_keeper.set(delay);
    if (this->quant_keeper.need_sync()) {
      this->quant_keeper.sync();
    }
  }
  // Endianess conversion: The processor is always modeled with the host endianess.
  // In case they are different, the endianess is swapped.
#ifdef BIG_ENDIAN_BO
  this->swap_endianess(datum);
#endif

  return datum;
} // read_half()
/// ----------------------------------------------------------------------------

unsigned char core_armcortexa9_lt::TLMMemory::read_byte(const unsigned& address)
throw() {
  unsigned char datum = 0;
  if (this->dmi_ptr_valid) {
    if (address + this->dmi_data.get_start_address() > this->dmi_data.get_end_address())
    {
      SC_REPORT_ERROR("TLM-2", "Error in reading memory data through DMI: address out of bounds");
    }
    memcpy(&datum, this->dmi_data.get_dmi_ptr() - this->dmi_data.get_start_address()
    + address, sizeof(datum));
    this->quant_keeper.inc(this->dmi_data.get_read_latency());
    if (this->quant_keeper.need_sync()) {
      this->quant_keeper.sync();
    }

  } else {
    sc_time delay = this->quant_keeper.get_local_time();
    tlm::tlm_generic_payload trans;
    trans.set_address(address);
    trans.set_read();
    trans.set_data_ptr(reinterpret_cast<unsigned char*>(&datum));
    trans.set_data_length(sizeof(datum));
    trans.set_streaming_width(sizeof(datum));
    trans.set_byte_enable_ptr(0);
    trans.set_dmi_allowed(false);
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    this->init_socket->b_transport(trans, delay);

    if (trans.is_response_error()) {
      std::string error_str("Error from b_transport, response status = " +
      trans.get_response_string());
      SC_REPORT_ERROR("TLM-2", error_str.c_str());
    }
    if (trans.is_dmi_allowed()) {
      this->dmi_data.init();
      this->dmi_ptr_valid = this->init_socket->get_direct_mem_ptr(trans, this->dmi_data);
    }
    // Keep track of time.
    this->quant_keeper.set(delay);
    if (this->quant_keeper.need_sync()) {
      this->quant_keeper.sync();
    }
  }

  return datum;
} // read_byte()
/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::TLMMemory::write_dword(
    const unsigned& address,
    sc_dt::uint64 datum) throw() {
#ifdef BIG_ENDIAN_BO
  unsigned datum1 = (unsigned)(datum);
  this->swap_endianess(datum1);
  unsigned datum2 = (unsigned)(datum >> 32);
  this->swap_endianess(datum2);
  datum = datum1 | (((sc_dt::uint64)datum2) << 32);
#endif
  if (this->debugger != NULL) {
    this->debugger->notify_address(address, sizeof(datum));
  }
  if (this->dmi_ptr_valid) {
    if (address + this->dmi_data.get_start_address() > this->dmi_data.get_end_address())
    {
      SC_REPORT_ERROR("TLM-2", "Error in writing memory data through DMI: address out of bounds");
    }
    memcpy(this->dmi_data.get_dmi_ptr() - this->dmi_data.get_start_address() +
    address, &datum, sizeof(datum));
    this->quant_keeper.inc(this->dmi_data.get_write_latency());
    if (this->quant_keeper.need_sync()) {
      this->quant_keeper.sync();
    }
  } else {
    sc_time delay = this->quant_keeper.get_local_time();
    tlm::tlm_generic_payload trans;
    trans.set_address(address);
    trans.set_write();
    trans.set_data_ptr((unsigned char*)&datum);
    trans.set_data_length(sizeof(datum));
    trans.set_streaming_width(sizeof(datum));
    trans.set_byte_enable_ptr(0);
    trans.set_dmi_allowed(false);
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    this->init_socket->b_transport(trans, delay);

    if (trans.is_response_error()) {
      std::string error_str("Error from b_transport, response status = " +
      trans.get_response_string());
      SC_REPORT_ERROR("TLM-2", error_str.c_str());
    }
    if (trans.is_dmi_allowed()) {
      this->dmi_data.init();
      this->dmi_ptr_valid = this->init_socket->get_direct_mem_ptr(trans, this->dmi_data);
    }
    // Keep track of time.
    this->quant_keeper.set(delay);
    if (this->quant_keeper.need_sync()) {
      this->quant_keeper.sync();
    }
  }
} // write_dword()
/// ----------------------------------------------------------------------------

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::TLMMemory::write_half(
    const unsigned& address,
    unsigned short int datum) throw() {
  // Endianess conversion: The processor is always modeled with the host endianess.
  // In case they are different, the endianess is swapped.
#ifdef BIG_ENDIAN_BO
  this->swap_endianess(datum);
#endif
#ifdef BIG_ENDIAN_BO
#else
#endif
  if (this->debugger != NULL) {
    this->debugger->notify_address(address, sizeof(datum));
  }
  if (this->dmi_ptr_valid) {
    if (address + this->dmi_data.get_start_address() > this->dmi_data.get_end_address())
    {
      SC_REPORT_ERROR("TLM-2", "Error in writing memory data through DMI: address out of bounds");
    }
    memcpy(this->dmi_data.get_dmi_ptr() - this->dmi_data.get_start_address() +
    address, &datum, sizeof(datum));
    this->quant_keeper.inc(this->dmi_data.get_write_latency());
    if (this->quant_keeper.need_sync()) {
      this->quant_keeper.sync();
    }
  } else {
    sc_time delay = this->quant_keeper.get_local_time();
    tlm::tlm_generic_payload trans;
    trans.set_address(address);
    trans.set_write();
    trans.set_data_ptr((unsigned char*)&datum);
    trans.set_data_length(sizeof(datum));
    trans.set_streaming_width(sizeof(datum));
    trans.set_byte_enable_ptr(0);
    trans.set_dmi_allowed(false);
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    this->init_socket->b_transport(trans, delay);

    if (trans.is_response_error()) {
      std::string error_str("Error from b_transport, response status = " +
      trans.get_response_string());
      SC_REPORT_ERROR("TLM-2", error_str.c_str());
    }
    if (trans.is_dmi_allowed()) {
      this->dmi_data.init();
      this->dmi_ptr_valid = this->init_socket->get_direct_mem_ptr(trans, this->dmi_data);
    }
    // Keep track of time.
    this->quant_keeper.set(delay);
    if (this->quant_keeper.need_sync()) {
      this->quant_keeper.sync();
    }
  }
} // write_half()
/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::TLMMemory::write_byte(
    const unsigned& address,
    unsigned char datum) throw() {
#ifdef BIG_ENDIAN_BO
#else
#endif
  if (this->debugger != NULL) {
    this->debugger->notify_address(address, sizeof(datum));
  }
  if (this->dmi_ptr_valid) {
    if (address + this->dmi_data.get_start_address() > this->dmi_data.get_end_address())
    {
      SC_REPORT_ERROR("TLM-2", "Error in writing memory data through DMI: address out of bounds");
    }
    memcpy(this->dmi_data.get_dmi_ptr() - this->dmi_data.get_start_address() +
    address, &datum, sizeof(datum));
    this->quant_keeper.inc(this->dmi_data.get_write_latency());
    if (this->quant_keeper.need_sync()) {
      this->quant_keeper.sync();
    }
  } else {
    sc_time delay = this->quant_keeper.get_local_time();
    tlm::tlm_generic_payload trans;
    trans.set_address(address);
    trans.set_write();
    trans.set_data_ptr((unsigned char*)&datum);
    trans.set_data_length(sizeof(datum));
    trans.set_streaming_width(sizeof(datum));
    trans.set_byte_enable_ptr(0);
    trans.set_dmi_allowed(false);
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    this->init_socket->b_transport(trans, delay);

    if (trans.is_response_error()) {
      std::string error_str("Error from b_transport, response status = " +
      trans.get_response_string());
      SC_REPORT_ERROR("TLM-2", error_str.c_str());
    }
    if (trans.is_dmi_allowed()) {
      this->dmi_data.init();
      this->dmi_ptr_valid = this->init_socket->get_direct_mem_ptr(trans, this->dmi_data);
    }
    // Keep track of time.
    this->quant_keeper.set(delay);
    if (this->quant_keeper.need_sync()) {
      this->quant_keeper.sync();
    }
  }
} // write_byte()
/// ----------------------------------------------------------------------------

sc_dt::uint64 core_armcortexa9_lt::TLMMemory::read_dword_dbg(const unsigned&
address) throw() {
  tlm::tlm_generic_payload trans;
  trans.set_address(address);
  trans.set_read();
  trans.set_data_length(8);
  trans.set_streaming_width(8);
  sc_dt::uint64 datum = 0;
  trans.set_data_ptr(reinterpret_cast<unsigned char*>(&datum));
  this->init_socket->transport_dbg(trans);
#ifdef BIG_ENDIAN_BO
  unsigned datum1 = (unsigned)(datum);
  this->swap_endianess(datum1);
  unsigned datum2 = (unsigned)(datum >> 32);
  this->swap_endianess(datum2);
  datum = datum1 | (((sc_dt::uint64)datum2) << 32);
#endif
  return datum;
} // read_dword_dbg()
/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::TLMMemory::read_word_dbg(const unsigned& address)
throw() {
  tlm::tlm_generic_payload trans;
  trans.set_address(address);
  trans.set_read();
  trans.set_data_length(4);
  trans.set_streaming_width(4);
  unsigned datum = 0;
  trans.set_data_ptr(reinterpret_cast<unsigned char*>(&datum));
  this->init_socket->transport_dbg(trans);
  // Endianess conversion: The processor is always modeled with the host endianess.
  // In case they are different, the endianess is swapped.
#ifdef BIG_ENDIAN_BO
  this->swap_endianess(datum);
#endif
  return datum;
} // read_word_dbg()
/// ----------------------------------------------------------------------------

unsigned short int core_armcortexa9_lt::TLMMemory::read_half_dbg(const unsigned&
address) throw() {
  tlm::tlm_generic_payload trans;
  trans.set_address(address);
  trans.set_read();
  trans.set_data_length(2);
  trans.set_streaming_width(2);
  unsigned short int datum = 0;
  trans.set_data_ptr(reinterpret_cast<unsigned char*>(&datum));
  this->init_socket->transport_dbg(trans);
  // Endianess conversion: The processor is always modeled with the host endianess.
  // In case they are different, the endianess is swapped.
#ifdef BIG_ENDIAN_BO
  this->swap_endianess(datum);
#endif
  return datum;
} // read_half_dbg()
/// ----------------------------------------------------------------------------

unsigned char core_armcortexa9_lt::TLMMemory::read_byte_dbg(const unsigned&
address) throw() {
  tlm::tlm_generic_payload trans;
  trans.set_address(address);
  trans.set_read();
  trans.set_data_length(1);
  trans.set_streaming_width(1);
  unsigned char datum = 0;
  trans.set_data_ptr(reinterpret_cast<unsigned char*>(&datum));
  this->init_socket->transport_dbg(trans);
  return datum;
} // read_byte_dbg()
/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::TLMMemory::write_dword_dbg(
    const unsigned& address,
    sc_dt::uint64 datum) throw() {
#ifdef BIG_ENDIAN_BO
  unsigned datum1 = (unsigned)(datum);
  this->swap_endianess(datum1);
  unsigned datum2 = (unsigned)(datum >> 32);
  this->swap_endianess(datum2);
  datum = datum1 | (((sc_dt::uint64)datum2) << 32);
#endif
  tlm::tlm_generic_payload trans;
  trans.set_address(address);
  trans.set_write();
  trans.set_data_length(8);
  trans.set_streaming_width(8);
  trans.set_data_ptr((unsigned char*)&datum);
  this->init_socket->transport_dbg(trans);
} // write_dword_dbg()
/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::TLMMemory::write_word_dbg(
    const unsigned& address,
    unsigned datum) throw() {
  // Endianess conversion: The processor is always modeled with the host endianess.
  // In case they are different, the endianess is swapped.
#ifdef BIG_ENDIAN_BO
  this->swap_endianess(datum);
#endif
  tlm::tlm_generic_payload trans;
  trans.set_address(address);
  trans.set_write();
  trans.set_data_length(4);
  trans.set_streaming_width(4);
  trans.set_data_ptr((unsigned char*)&datum);
  this->init_socket->transport_dbg(trans);
} // write_word_dbg()
/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::TLMMemory::write_half_dbg(
    const unsigned& address,
    unsigned short int datum) throw() {
  // Endianess conversion: The processor is always modeled with the host endianess.
  // In case they are different, the endianess is swapped.
#ifdef BIG_ENDIAN_BO
  this->swap_endianess(datum);
#endif
#ifdef BIG_ENDIAN_BO
#else
#endif
  tlm::tlm_generic_payload trans;
  trans.set_address(address);
  trans.set_write();
  trans.set_data_length(2);
  trans.set_streaming_width(2);
  trans.set_data_ptr((unsigned char*)&datum);
  this->init_socket->transport_dbg(trans);
} // write_half_dbg()
/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::TLMMemory::write_byte_dbg(
    const unsigned& address,
    unsigned char datum) throw() {
#ifdef BIG_ENDIAN_BO
#else
#endif
  tlm::tlm_generic_payload trans;
  trans.set_address(address);
  trans.set_write();
  trans.set_data_length(1);
  trans.set_streaming_width(1);
  trans.set_data_ptr((unsigned char*)&datum);
  this->init_socket->transport_dbg(trans);
} // write_byte_dbg()
/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::TLMMemory::lock() {

} // lock()
/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::TLMMemory::unlock() {

} // unlock()
/// ----------------------------------------------------------------------------

core_armcortexa9_lt::TLMMemory::TLMMemory(
    sc_module_name port_name,
    tlm_utils::tlm_quantumkeeper& quant_keeper) :
  sc_module(port_name),
  quant_keeper(quant_keeper) {
  this->debugger = NULL;
  this->dmi_ptr_valid = false;
  end_module();
} // TLMMemory()
/// ----------------------------------------------------------------------------

/// ****************************************************************************

