/***************************************************************************//**
*
*           _/       _/_/_/      _/         _/
*         _/_/      _/    _/    _/_/      __/
*       _/  _/     _/    _/    _/ _/    _/_/
*     _/_/_/_/    _/_/_/      _/  _/  _/ _/
*   _/      _/   _/    _/    _/   _/_/  _/
* _/        _/  _/      _/  _/    _/   _/
*
* @brief    This file is part of the SoCRocket ARM ISS generated by TRAP.
* @details  This SystemC model was automatically generated by running
*           $ python ARMArch.py
*           Please refer to the ARM TRAP source files for documentation.
* @author   Lillian Tadros (TUDO ETIT IRF)
* @date     2014-12-01 tadros: Initial ARM Cortex A9 (ARMv7-A) version
*
*
* (c) 2014-2016
* Technische Universitaet Dortmund
* Institut fuer Roboterforschung
* Project Embedded Multi-Core Systems for Mixed Criticality
* Applications in Dynamic and Changeable Real-time Environments (EMC2)
*
*
* This file is part of ARMCortexA9.
*
* ARMCortexA9 is free software; you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License as
* published by the Free Software Foundation; either version 3 of the
* License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Affero General Public License for more details.
*
* You should have received a copy of the GNU Affero General Public
* License along with this program; if not, write to the
* Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
* or see <http://www.gnu.org/licenses/>.
*
*******************************************************************************/

#include "arm/intunit/registers.hpp"
#include "arm/intunit/memory.hpp"
#include "arm/intunit/instructions.hpp"

#include <modules/instruction.hpp>
#include <common/report.hpp>
#include <string>
#include <modules/register.hpp>
#include <systemc.h>
#include <sstream>


using namespace core_armcortexa9_lt;

core_armcortexa9_lt::Instruction::Instruction(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  R(R),
  data_memory(data_memory),
  total_cycles(total_cycles) {
  this->total_instr_cycles = 0;
} // Instruction()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::Instruction::~Instruction() {

} // ~Instruction()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::Instruction::BranchWritePC(unsigned addr) {

  /// Writing an address to the PC causes either a simple branch to that address
  /// or an interworking branch that also selects the instruction set to execute
  /// after the branch. A simple branch is performed by the BranchWritePC()
  /// function.
  switch(CurrentInstrSet()) {
    case (unsigned)(ISMODE::ARM):
    // ARM mode 0x0, word align
    PC = addr & 0xFFFFFFFC;
    break;
    case (unsigned)(ISMODE::THUMB):
    // Thumb mode 0x1, half-word align
    PC = addr & 0xFFFFFFFE;
    break;
    case (unsigned)(ISMODE::JAZELLE):
    // Jazelle mode 0x2, no alignment
    if (JazelleAcceptsExecution())
    PC = addr;
    else
    PC = addr & 0xFFFFFFFC;
    break;
    case (unsigned)(ISMODE::THUMBEE):
    // ThumbEE mode 0x3, half-word align
    PC = addr & 0xFFFFFFFE;
    break;
    default:
    THROW_EXCEPTION("Invalid instruction set mode switch " << ios::hex <<
    CurrentInstrSet() << " while updating the PC.");
    break;
  }
} // BranchWritePC()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::Instruction::BXWritePC(unsigned addr) {

  // ThumbEE -> ThumbEE
  if (CurrentInstrSet() != 0x3) {
    // ARM/Thumb/Jazelle -> Thumb
    if (addr & 0x1) {
      CPSR[CPSR_T] = 0x1;
      CPSR[CPSR_J] = 0x0;
      PC.update_alias(REGS[15], 4);
      // ARM/Thumb/Jazelle -> ARM
    } else if (!(addr & 0x2)) {
      CPSR[CPSR_J] = CPSR[CPSR_T] = 0x0;
      PC.update_alias(REGS[15], 8);
    }
  }

  BranchWritePC(addr);
} // BXWritePC()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::Instruction::Rmode(
    unsigned reg_index,
    unsigned mode,
    bool write,
    unsigned value) {

  if ((reg_index < 0) || (reg_index > 14))
  THROW_EXCEPTION("Invalid register " << reg_index << ".");
  /*if (!valid_psr_mode(mode))
  THROW_EXCEPTION("Invalid execution mode " << mode << ".");
  if ((mode == (unsigned)EXECMODE::MON) && !IsSecure())
  THROW_EXCEPTION("Attempted use of Monitor mode in non-secure state.");
  if ((mode == (unsigned)EXECMODE::FIQ) && !IsSecure() && NSACR[NSACR_RFR] == 1)
  THROW_EXCEPTION("Attempted use of FIQ registers reserved by the Security Extensions.");*/
  /*TODO: This should be added as a pre-write callback for SP.
  if ((reg_index == 13) && (value & 0x3) && (CurrentInstrSet() != (unsigned)(ISMODE::ARM)))
  THROW_EXCEPTION("Writes of non word-aligned values to SP are only permitted in ARM state.");*/

  if ((reg_index > 12) && (reg_index < 15)) {
    switch(mode) {
      case (unsigned)EXECMODE::USR:
      case (unsigned)EXECMODE::SYS:
      // RB[0-12]:  R0_usr..R12_usr
      // RB[13-15]: SP_usr, LR_usr, PC
      break;
      case (unsigned)EXECMODE::FIQ:
      // RB[18-24]: R8_fiq..R12_fiq, SP_fiq, LR_fiq
      reg_index += 10;
      break;
      case (unsigned)EXECMODE::IRQ:
      // RB[16-17]: SP_irq, LR_irq
      reg_index += 3;
      break;
      case (unsigned)EXECMODE::SVC:
      // RB[29-30]: SP_svc, LR_svc
      reg_index += 16;
      break;
      case (unsigned)EXECMODE::MON:
      // RB[33-34]: SP_mon, LR_mon
      reg_index += 20;
      break;
      case (unsigned)EXECMODE::ABT:
      // RB[27-28]: SP_abt, LR_abt
      reg_index += 14;
      break;
      case (unsigned)EXECMODE::HYP:
      // RB[31-32]: SP_hyp, ELR_hyp
      reg_index += 18;
      break;
      case (unsigned)EXECMODE::UND:
      // RB[25-26]: SP_und, LR_und
      reg_index += 12;
      break;
      default:
      THROW_EXCEPTION("Invalid execution mode " << next_mode << " while updating the register banks.");
      break;
    }
  } else if ((reg_index > 7) && (reg_index < 15) && (mode == (unsigned)EXECMODE::FIQ))
  {
    // FIQ mode
    // RB[18-24]: R8_fiq..R12_fiq, SP_fiq, LR_fiq
    reg_index += 10;
  }

  if (write) {
    REGS[reg_index] = value;
    return 0;
  } else return (REGS[reg_index]);
} // Rmode()

/// ----------------------------------------------------------------------------

bool core_armcortexa9_lt::Instruction::valid_banked_reg_access(unsigned sys_mode)
{

  unsigned cur_mode = CPSR[CPSR_M];
  if (!(valid_psr_mode(cur_mode)))
  return false;

  bool result = true;

  switch((sys_mode >> 3) & 0x3) {
    case 0x0:
    // Banked USR registers
    switch (sys_mode & 0x7) {
      case 0x5:
      // Banked SP_USR register: Inaccessible from SYS mode
      if (cur_mode == (unsigned)EXECMODE::SYS) result = false;
      break;
      case 0x6:
      // Banked LR_USR register: Inaccessible from SYS or HYP
      if ((cur_mode == (unsigned)EXECMODE::HYP) || (cur_mode == (unsigned)EXECMODE::SYS))
      result = false;
      break;
      case 0x7:
      // Undefined sys_mode
      result = false;
      break;
      default:
      // Banked R8-R12: Accessible only in FIQ mode
      if (cur_mode != (unsigned)EXECMODE::FIQ) result = false;
    } break;
    case 0x1:
    // Banked FIQ registers
    if (((sys_mode & 0x7) == 0x7) || (cur_mode == (unsigned)EXECMODE::FIQ)) {
      result = false;
    } break;
    case 0x2:
    // Banked IRQ/SVC/ABT/UND registers
    switch (sys_mode & 0x7) {
      case 0x0:
      case 0x1:
      // Banked LR_IRQ / SP_IRQ registers: Inaccessible from IRQ mode
      if (cur_mode == (unsigned)EXECMODE::IRQ) result = false;
      break;
      case 0x2:
      case 0x3:
      // Banked LR_SVC / SP_SVC registers: Inaccessible from SVC mode
      if (cur_mode == (unsigned)EXECMODE::SVC) result = false;
      break;
      case 0x4:
      case 0x5:
      // Banked LR_ABT / SP_ABT registers: Inaccessible from ABT mode
      if (cur_mode == (unsigned)EXECMODE::ABT) result = false;
      break;
      case 0x16:
      // Banked LR_UND / SP_UND registers: Inaccessible from UND mode
      if (cur_mode == (unsigned)EXECMODE::UND) result = false;
      break;
    } break;
    case 0x3:
    // Banked MON/HYP registers
    switch (sys_mode & 0x7) {
      case 0x0:
      case 0x1:
      case 0x2:
      case 0x3:
      // Undefined sys_mode
      result = false;
      case 0x4:
      case 0x5:
      // Banked LR_MON / SP_MON registers: Inaccessible in non-secure state
      if ((cur_mode == (unsigned)EXECMODE::MON) || (cur_mode == (unsigned)EXECMODE::HYP))
      result = false;
      break;
      case 0x6:
      // Banked ELR_HYP register: Inaccessible in non-secure state; accessible
      // only from MON mode in secure state
      if (cur_mode != (unsigned)EXECMODE::HYP) result = false;
      break;
      case 0x7:
      // Banked SP_HYP register: Inaccessible in non-secure state; accessible
      // only from MON mode in secure state
      if (cur_mode != (unsigned)EXECMODE::MON) result = false;
      break;
    } break;
  }

  return result;
} // valid_banked_reg_access()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::Instruction::update_alias(
    unsigned cur_mode,
    unsigned next_mode) {

  switch(next_mode) {
    case (unsigned)EXECMODE::USR:
    case (unsigned)EXECMODE::SYS:
    // RB[0-12]:  R0_usr..R12_usr
    // RB[13-15]: SP_usr, LR_usr, PC
    REGS[13].update_alias(RB[13]);
    REGS[14].update_alias(RB[14]);
    break;
    case (unsigned)EXECMODE::FIQ:
    // RB[18-24]: R8_fiq..R12_fiq, SP_fiq, LR_fiq
    REGS[8].update_alias(RB[18]);
    REGS[9].update_alias(RB[19]);
    REGS[10].update_alias(RB[20]);
    REGS[11].update_alias(RB[21]);
    REGS[12].update_alias(RB[22]);
    REGS[13].update_alias(RB[23]);
    REGS[14].update_alias(RB[24]);
    break;
    case (unsigned)EXECMODE::IRQ:
    // RB[16-17]: SP_irq, LR_irq
    REGS[13].update_alias(RB[16]);
    REGS[14].update_alias(RB[17]);
    break;
    case (unsigned)EXECMODE::SVC:
    // RB[29-30]: SP_svc, LR_svc
    REGS[13].update_alias(RB[29]);
    REGS[14].update_alias(RB[30]);
    break;
    case (unsigned)EXECMODE::MON:
    // RB[33-34]: SP_mon, LR_mon
    REGS[13].update_alias(RB[33]);
    REGS[14].update_alias(RB[34]);
    break;
    case (unsigned)EXECMODE::ABT:
    // RB[27-28]: SP_abt, LR_abt
    REGS[13].update_alias(RB[27]);
    REGS[14].update_alias(RB[28]);
    break;
    case (unsigned)EXECMODE::HYP:
    // RB[31-32]: SP_hyp, ELR_hyp
    REGS[13].update_alias(RB[31]);
    REGS[14].update_alias(RB[32]);
    break;
    case (unsigned)EXECMODE::UND:
    // RB[25-26]: SP_und, LR_und
    REGS[13].update_alias(RB[25]);
    REGS[14].update_alias(RB[26]);
    break;
    default:
    THROW_EXCEPTION("Invalid execution mode " << next_mode << " while updating the register banks.");
    break;
  }
  if (cur_mode == (unsigned)EXECMODE::FIQ && next_mode != (unsigned)EXECMODE::FIQ)
  {
    REGS[8].update_alias(RB[8]);
    REGS[9].update_alias(RB[9]);
    REGS[10].update_alias(RB[10]);
    REGS[11].update_alias(RB[11]);
    REGS[12].update_alias(RB[12]);
  }
} // update_alias()

/// ----------------------------------------------------------------------------

int core_armcortexa9_lt::Instruction::get_spsr_idx(unsigned mode) {

  /// Gives access to the PSRs.
  switch(mode) {
    //return ((&SPSR.<mode>.get_reg() - SPSR) / sizeof(SPSR[0]));
    case (unsigned)EXECMODE::USR:
    case (unsigned)EXECMODE::SYS:
    return -1;
    case (unsigned)EXECMODE::FIQ:
    return 1;
    case (unsigned)EXECMODE::IRQ:
    return 0;
    case (unsigned)EXECMODE::SVC:
    return 4;
    case (unsigned)EXECMODE::MON:
    return 6;
    case (unsigned)EXECMODE::ABT:
    return 3;
    case (unsigned)EXECMODE::HYP:
    return 5;
    case (unsigned)EXECMODE::UND:
    return 2;
    default:
    return -1;
  }
} // get_spsr_idx()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::Instruction::restore_spsr() {

  if (!(CPSR[CPSR_M] & 0x10)) {
    THROW_EXCEPTION("Invalid execution mode " << ios::hex << CPSR[CPSR_M] << ": CPSR[4] != 1.");
  }

  unsigned cur_mode = CPSR[CPSR_M];
  switch(cur_mode) {
    case (unsigned)EXECMODE::FIQ:
    CPSR = SPSR_FIQ;
    break;
    case (unsigned)EXECMODE::IRQ:
    CPSR = SPSR_IRQ;
    break;
    case (unsigned)EXECMODE::SVC:
    CPSR = SPSR_SVC;
    break;
    case (unsigned)EXECMODE::MON:
    CPSR = SPSR_MON;
    break;
    case (unsigned)EXECMODE::ABT:
    CPSR = SPSR_ABT;
    break;
    case (unsigned)EXECMODE::HYP:
    CPSR = SPSR_HYP;
    break;
    case (unsigned)EXECMODE::UND:
    CPSR = SPSR_UND;
    break;
    default:
    THROW_EXCEPTION("Invalid execution mode " << ios::hex << cur_mode << " while updating the PSR.");
    break;
  }
  update_alias(cur_mode, CPSR[CPSR_M]);
} // restore_spsr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::Instruction::psr_mask(
    unsigned next_value,
    unsigned byte_mask,
    unsigned cur_mode,
    bool is_spsr,
    bool is_exception) {

  /// Gives access to the PSRs.
  bool is_privileged = cur_mode & 0xF;
  unsigned mask = 0;
  unsigned next_mode = next_value & 0x1F;

  if (is_spsr && (!is_privileged || (cur_mode == (unsigned)EXECMODE::SYS)))
  return 0;

  if (byte_mask & 0x8) {
    if (is_spsr || is_exception) {
      // NZCVQITJ flags
      mask |= 0xFF000000;
    } else {
      // NZCVQ flags
      mask |= 0xF8000000;
    }
  }
  if (byte_mask & 0x4) {
    // GE flags
    mask |= 0x000F0000;
  }
  if (byte_mask & 0x2) {
    // E flag
    mask |= 0x00000200;
    if (is_spsr || is_exception) {
      // IT flags
      mask |= 0x0000FC00;
    }
    if (is_privileged && (is_spsr || IsSecure() /* TODO: || SCR[SCR_AW] */ ||
    HaveVirtExt())) {
      // A flag
      mask |= 0x00000100;
    }
  }
  if (byte_mask & 0x1) {
    if (is_spsr) {
      // IFT flags
      mask |= 0x000000E0;
      if (valid_psr_mode(next_mode)) {
        // cur_mode field
        mask |= 0x0000001F;
      }
    } else {
      if (is_exception) {
        // T flag
        mask |= 0x00000020;
      }
      if (is_privileged) {
        // I flag
        mask |= 0x00000080;
        if (/* TODO: !(SCTLR[SCTLR_NMFI] && (next_value & 0x40))
        && */ (IsSecure() /* TODO: || SCR[SCR_FW] */ || HaveVirtExt())) {
          // F flag
          mask |= 0x00000040;
        }
        if (valid_psr_mode(next_mode)
        // Check for attempts to enter modes only permitted in Secure state from
        // Non-secure state. These are Monitor cur_mode, and FIQ cur_mode if the
        // Security Extensions have reserved it.
        /* && (IsSecure()
        || ((next_mode != (unsigned)EXECMODE::MON)
        && !((next_mode == (unsigned)EXECMODE::FIQ) && NSACR[NSACR_RFR])))
        // There is no Hyp cur_mode in Secure state.
        && (SCR[SCR_NS] || (next_mode != (unsigned)EXECMODE::HYP))
        // Cannot move into Hyp cur_mode directly from a Non-secure PL1 cur_mode.
        && ((cur_mode == (unsigned)EXECMODE::HYP) || (next_mode != (unsigned)EXECMODE::HYP)
        || IsSecure())
        // Cannot move out of Hyp cur_mode with this function except on an
        // exception return.
        && ((cur_mode != (unsigned)EXECMODE::HYP) || (next_mode == (unsigned)EXECMODE::HYP)
        || is_exception) */) {
          // cur_mode field
          mask |= 0x0000001F;
        }
      }
    }
  }
  return mask;
} // psr_mask()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::Instruction::CurrentInstrSet() {

  /// Returns the current instruction set.
  /// JT=00: ARM; JT=01: Thumb; JT=10: Jazelle; JT=11: ThumbEE
  unsigned current_mode = (CPSR[CPSR_J] << 1) & CPSR[CPSR_T] & (unsigned)0x3;

  return (current_mode);
} // CurrentInstrSet()

/// ----------------------------------------------------------------------------

bool core_armcortexa9_lt::Instruction::valid_psr_mode(unsigned mode) {

  /// Tests whether a 5-bit mode number corresponds to one of the permitted
  /// modes.
  switch(mode) {
    case (unsigned)EXECMODE::USR:
    case (unsigned)EXECMODE::FIQ:
    case (unsigned)EXECMODE::IRQ:
    case (unsigned)EXECMODE::SVC:
    case (unsigned)EXECMODE::ABT:
    case (unsigned)EXECMODE::UND:
    case (unsigned)EXECMODE::SYS:
    return true;
    case (unsigned)EXECMODE::MON:
    return (HaveSecurityExt());
    case (unsigned)EXECMODE::HYP:
    return (HaveVirtExt());
    default:
    return false;
  }
} // valid_psr_mode()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::Instruction::ITAdvance() {

  /// Advances after normal execution of an IT block instruction.
  //unsigned IT = ((CPSR[CPSR_IT72] << 2) & 0xFC) | (CPSR[CPSR_IT10] & 0x3);
  if (!(CPSR[CPSR_IT10] || (CPSR[CPSR_IT72] & 0x1)))
  CPSR[CPSR_IT72] = CPSR[CPSR_IT10] = 0x0;
  else {
    // CPSR[CPSR_IT][0:4] <<= 1
    CPSR[CPSR_IT10] = (CPSR[CPSR_IT10] << 1) & 0x2;
    CPSR[CPSR_IT72] = (CPSR[CPSR_IT72] & 0x38) | ((CPSR[CPSR_IT72] << 1) & 0x6)
    | ((CPSR[CPSR_IT10] >> 1) & 0x1);
    //IT = (IT & 0xE0) | ((IT << 1) & 0x1F);
    //CPSR[CPSR_IT72] = ((IT >> 2) & 0x3F);
    //CPSR[CPSR_IT10] = (IT & 0x3);
  }
} // ITAdvance()

/// ----------------------------------------------------------------------------

bool core_armcortexa9_lt::Instruction::InITBlock() {

  /// Tests whether the current instruction is in an IT block.
  return (CPSR[CPSR_IT10] || (CPSR[CPSR_IT72] & 0x3));
} // InITBlock()

/// ----------------------------------------------------------------------------

bool core_armcortexa9_lt::Instruction::LastInITBlock() {

  /// Tests whether the current instruction is the last instruction of an IT
  /// block.
  return ((CPSR[CPSR_IT10] == 0x0) && ((CPSR[CPSR_IT72] & 0x3) == 0x2));
} // LastInITBlock()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::Instruction::AddWithCarry(
    unsigned operand1,
    unsigned operand2,
    bool carry) {

  long long result_signed = (long long)((long long)((int)operand1) + (long
  long)((int)operand2)) + (long long)((unsigned)carry);

  // Update N (negative flag) if result is negative (bit[63]).
  CPSR[CPSR_N] = ((result_signed & 0x0000000080000000LL) != 0);

  // Update Z (zero flag) if result is 0.
  CPSR[CPSR_Z] = (result_signed == 0);

  // Update C (carry flag; unsigned overflow) if operation generated a carry.
  // Carry is only relevant for unsigned and meaningless for signed additions.
  // We can either test result_unsigned & 0x100000000LL or XOR the MSB of
  // operands and result_signed. The first method is easier, but we want to
  // avoid the extra unsigned addition:
  // Ex1:
  //   u: 0111b (7d) + 0111b (7d)
  //   -> u = 0 1110b (14d)
  //   -> u & 10000b = 0
  //   s: 0111b (7d) + 0111b (7d)
  //   -> s = 0 1110b (14d)
  //   -> 0 ^ 0 ^ (s & 10000b) = 0
  // Ex2:
  //   u: 0111b (7d) + 1000b (8d)
  //   -> u = 0 1111b (15d)
  //   -> u & 10000b = 0
  //   s: 0111b (7d) + 1000b (-8d)
  //   -> s = 1 1111b (-1d)
  //   -> 0 ^ 1 ^ (s & 10000b) = 0
  // Ex3:
  //   u: 0001b (1d) + 1111b (15d)
  //   -> u = 1 0000b (16d)
  //   -> u & 10000b = 1
  //   s: 0001b (1d) + 1111b (-1d)
  //   -> s = 0 0000b (0d)
  //   -> 0 ^ 1 ^ (s & 10000b) = 1
  // Ex4:
  //   u: 0001b (1d) + 1110b (14d)
  //   -> u = 0 1111b (15d)
  //   -> u & 10000b = 0
  //   s: 0001b (1d) + 1110b (-2d)
  //   -> s = 1 1111b (-1d)
  //   -> 0 ^ 1 ^ (s & 10000b) = 0
  // Ex5:
  //   u: 1000b (8d)  + 1000b (8d)
  //   -> u = 1 0000b (16d)
  //   -> u & 10000b = 1
  //   s: 1000b (-8d) + 1000b (-8d)
  //   -> s = 1 0000b (-16d)
  //   -> 1 ^ 1 ^ (s & 10000b) = 1
  CPSR[CPSR_C] = (((operand1 ^ operand2 ^ (result_signed >> 1)) & 0x80000000) !=
  0);

  // Update V (overflow flag; signed overflow) if operation generated an overflow.
  // Overflow is only relevant for signed and meaningless for unsigned additions.
  // Since we have already calculated result_signed, the easiest test would be
  // (result_signed & 0x80000000LL) != (result_signed & 0x100000000LL):
  // Ex1: 1111b (-1d) + 1000b (-8d)
  //   -> s = 1 0111b (-9d)
  //   -> (s & 1000b) != (s & 10000b) -> 1
  // Ex2: 1111b (-1d) + 1001b (-7d)
  //   -> s = 1 1000b (-8d)
  //   -> (s & 1000b) == (s & 10000b) -> 0
  CPSR[CPSR_V] = (((result_signed >> 1) & 0x80000000) != (result_signed &
  0x80000000));
} // AddWithCarry()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::Instruction::update_psr_sub(
    unsigned operand1,
    unsigned operand2,
    bool carry) {

  long long result_signed = (long long)((long long)((int)operand1) - (long
  long)((int)operand2)) - (long long)((int)carry);

  //unsigned long long result_unsigned = (unsigned long long)((unsigned long
  // long)operand1 - (unsigned long long)operand2);

  // Update N (negative flag) if result is negative (bit[63]).
  CPSR[CPSR_N] = ((result_signed & 0x0000000080000000LL) != 0);

  // Update Z (zero flag) if result is 0.
  CPSR[CPSR_Z] = (result_signed == 0);

  // Update C (carry flag; unsigned overflow) if operation generated a carry.
  // Carry is only relevant for unsigned and meaningless for signed additions.
  // We can't just test (result_signed >> 1) & 0x800000000 because result_signed
  // is signed and therefore had the sign logically explanded. This e.g. should
  // not generate a carry:
  // 01b (1) + 10b (2|-2) -> 0001b + 1110b = 1111b (15|-1).
  //operand2 = (int)-operand2;
  CPSR[CPSR_C] = (((operand1 ^ operand2 ^ ((unsigned)(result_signed >> 1))) &
  0x80000000) == 0);

  // Update V (overflow flag; signed overflow) if operation generated an overflow.
  // Definition 1: (op1[MSB] == op2[MSB]) && result[MSB] != opx[MSB]
  // Definition 2: carry_in(result[MSB]) != carry_out(result[MSB])
  // Overflow is only relevant for signed and meaningless for unsigned additions.
  CPSR[CPSR_V] = ((((unsigned)(result_signed >> 1)) ^ ((unsigned)result_signed))
  & 0x80000000) != 0;
} // update_psr_sub()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::Instruction::update_psr_bit(
    unsigned result,
    bool carry) {

  // Update N (negative flag) if result is negative (bit[63]).
  CPSR[CPSR_N] = ((result & 0x80000000) != 0);

  // Update Z (zero flag) if result is 0.
  CPSR[CPSR_Z] = (result == 0);

  // Update C (carry flag; unsigned overflow) if operation generated a carry.
  // Carry is only relevant for unsigned and meaningless for signed additions We
  // can't just test (resultSign >> 1) & 0x800000000 because resultSign is
  // signed and therefore had the sign logically explanded. This e.g. should not
  // generate a carry:
  // 01b (1) + 10b (2|-2) -> 0001b + 1110b = 1111b (15|-1).
  CPSR[CPSR_C] = (carry != 0);

  // V (overflow flag; signed overflow) is not updated.
} // update_psr_bit()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::Instruction::sign_extend(
    unsigned bits,
    unsigned len_bits) {

  // NOTE: This function assumes two's complement, which is implementation
  // defined according to the C++ LRM. Extend only if MSB == 1.
  if ((bits & (1 << (len_bits - 1))) != 0)
  bits |= (((unsigned)0xFFFFFFFF) << len_bits);
  // NOTE: Branchless algorithm courtesy of http://aggregate.ee.engr.uky.edu/MAGIC/.
  //bits = (bits ^ (1 << (len_bits - 1))) - (1 << (len_bits - 1))
  return bits;
} // sign_extend()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::Instruction::LSL(
    unsigned to_shift,
    unsigned shift_amm,
    bool& carry) {

  unsigned shifted;

  to_shift &= 0xFFFFFFFF;
  if (shift_amm <= 0) return to_shift;
  shifted = ((unsigned long)to_shift << shift_amm) & 0xFFFFFFFF;
  carry = to_shift & (0x1 << (32 - shift_amm));
  return shifted;
} // LSL()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::Instruction::LSR(
    unsigned to_shift,
    unsigned shift_amm,
    bool& carry) {

  unsigned shifted;

  to_shift &= 0xFFFFFFFF;
  if (shift_amm <= 0) return to_shift;
  shifted = (unsigned long)to_shift >> shift_amm;
  carry = to_shift & ((unsigned long)0x1 << (shift_amm - 1));
  return shifted;
} // LSR()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::Instruction::ASR(
    unsigned to_shift,
    unsigned shift_amm,
    bool& carry) {

  unsigned shifted;

  to_shift &= 0xFFFFFFFF;
  if (shift_amm <= 0) return to_shift;
  shifted = (unsigned long)to_shift >> shift_amm;
  // Extend sign.
  if (to_shift & 0x80000000) {
    shifted |= (((unsigned long)0xFFFFFFFF) << (32 - shift_amm));
  }
  carry = to_shift & ((unsigned long)0x1 << (shift_amm - 1));
  return shifted;
} // ASR()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::Instruction::ROR(
    unsigned to_rotate,
    unsigned rotate_amm,
    bool& carry) {

  unsigned rotated;

  to_rotate &= 0xFFFFFFFF;
  if (rotate_amm <= 0) return to_rotate;
  if (rotate_amm > 31) rotate_amm %= 32;
  rotated = ((unsigned)to_rotate >> rotate_amm) | (to_rotate << (32 - rotate_amm));
  carry = rotated & 0x80000000;
  return rotated;
} // ROR()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::Instruction::RRX(
    unsigned to_rotate,
    bool carry_in,
    bool& carry) {

  unsigned rotated;

  to_rotate &= 0xFFFFFFFF;
  rotated = (carry_in? 0x80000000 : 0) | ((unsigned)to_rotate >> 1);
  carry = to_rotate & 0x1;
  return rotated;
} // RRX()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::Instruction::sat_q(
    int operand,
    unsigned saturate_to,
    bool is_signed,
    bool set_q_en) {

  unsigned mask = ((unsigned long)0xFFFFFFFF >> (unsigned)(32 - (unsigned)saturate_to
  + is_signed)) & 0xFFFFFFFF;

  if ((unsigned)operand > mask) {
    if (set_q_en) CPSR[CPSR_Q] = 1;
    return mask;
  } else if (!is_signed && (operand < 0)) {
    if (set_q_en) CPSR[CPSR_Q] = 1;
    return 0;
  } else if (is_signed && (operand < (int)(-mask-1))) {
    if (set_q_en) CPSR[CPSR_Q] = 1;
    return (-mask-1) & 0xFFFFFFFF;
  } else if (set_q_en) CPSR[CPSR_Q] = 0;
  return operand;
} // sat_q()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::Instruction::BitCount(unsigned operand) {

  unsigned setbits = 0;
  for (; operand; setbits++) {
    // Clears least significant set bit.
    operand &= operand - 1;
  }
  return setbits;
} // BitCount()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::Instruction::ExcVectorBase() {

  /// Determine the exception base address.
  /* TODO: if (SCTLR[SCTLR_V])
  return 0xFFFF0000;
  else if (HaveSecurityExt())
  return VBAR;
  else */ return 0x0;
} // ExcVectorBase()

/// ----------------------------------------------------------------------------

bool core_armcortexa9_lt::Instruction::HaveLPAE() {

  /// Returns TRUE if the implementation includes the Large Physical Address
  /// Extension.
  return ID_AFR0[ID_AFR0_W4];
} // HaveLPAE()

/// ----------------------------------------------------------------------------

bool core_armcortexa9_lt::Instruction::HaveMPExt() {

  /// Returns TRUE if the implementation includes the Multiprocessing Extensions.
  return ID_AFR0[ID_AFR0_W3];
} // HaveMPExt()

/// ----------------------------------------------------------------------------

bool core_armcortexa9_lt::Instruction::HaveSecurityExt() {

  /// Returns TRUE if the implementation includes the Security Extensions.
  return ID_PFR1[ID_PFR1_W1];
} // HaveSecurityExt()

/// ----------------------------------------------------------------------------

bool core_armcortexa9_lt::Instruction::HaveVirtExt() {

  /// Returns TRUE if the implementation includes the Virtualization Extensions.
  return ID_PFR1[ID_PFR1_W3];
} // HaveVirtExt()

/// ----------------------------------------------------------------------------

bool core_armcortexa9_lt::Instruction::IsSecure() {

  /// Returns TRUE if the processor is in Secure state, or if the implementation
  /// does not include the Security Extensions, and FALSE otherwise.
  return (!HaveSecurityExt() /* TODO: || !SCR[SCR_NS] */ || CPSR[CPSR_M] ==
  (unsigned)((unsigned)EXECMODE::MON));
} // IsSecure()

/// ----------------------------------------------------------------------------

bool core_armcortexa9_lt::Instruction::JazelleAcceptsExecution() {

  /// Indicates whether Jazelle hardware will take over execution when a BXJ
  /// instruction is executed.
  return ID_PFR0[ID_PFR0_W2];
} // JazelleAcceptsExecution()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::Instruction::print_trace() {
  std::cerr << "Simulated time: " << std::dec << this->total_cycles << " cycles."
  << std::endl;
  std::cerr << "Instruction: " << this->get_name() << '.' << std::endl;
  std::cerr << "Mnemonic: " << this->get_mnemonic() << std::endl;
  std::cerr << "CPSR = " << std::hex << std::showbase << CPSR << std::endl;
  std::cerr << "ID_PFR0 = " << std::hex << std::showbase << ID_PFR0 << std::endl;
  std::cerr << "ID_PFR1 = " << std::hex << std::showbase << ID_PFR1 << std::endl;
  std::cerr << "ID_DFR0 = " << std::hex << std::showbase << ID_DFR0 << std::endl;
  std::cerr << "ID_AFR0 = " << std::hex << std::showbase << ID_AFR0 << std::endl;
  std::cerr << "ID_MMFR0 = " << std::hex << std::showbase << ID_MMFR0 << std::endl;
  std::cerr << "ID_MMFR1 = " << std::hex << std::showbase << ID_MMFR1 << std::endl;
  std::cerr << "ID_MMFR2 = " << std::hex << std::showbase << ID_MMFR2 << std::endl;
  std::cerr << "ID_MMFR3 = " << std::hex << std::showbase << ID_MMFR3 << std::endl;
  std::cerr << "ID_ISAR0 = " << std::hex << std::showbase << ID_ISAR0 << std::endl;
  std::cerr << "ID_ISAR1 = " << std::hex << std::showbase << ID_ISAR1 << std::endl;
  std::cerr << "ID_ISAR2 = " << std::hex << std::showbase << ID_ISAR2 << std::endl;
  std::cerr << "ID_ISAR3 = " << std::hex << std::showbase << ID_ISAR3 << std::endl;
  std::cerr << "ID_ISAR4 = " << std::hex << std::showbase << ID_ISAR4 << std::endl;
  std::cerr << "ID_ISAR5 = " << std::hex << std::showbase << ID_ISAR5 << std::endl;
  std::cerr << "MP_ID = " << std::hex << std::showbase << MP_ID << std::endl;
  for (int reg_i = 0; reg_i < 7; reg_i++) {
    std::cerr << "SPSR[" << std::dec << reg_i << "] = " << std::hex << std::showbase
    << SPSR[reg_i] << std::endl;
  }
  for (int reg_i = 0; reg_i < 35; reg_i++) {
    std::cerr << "RB[" << std::dec << reg_i << "] = " << std::hex << std::showbase
    << RB[reg_i] << std::endl;
  }
  for (int reg_i = 0; reg_i < 16; reg_i++) {
    std::cerr << "CPREGS[" << std::dec << reg_i << "] = " << std::hex << std::showbase
    << CPREGS[reg_i] << std::endl;
  }
  std::cerr << std::endl;
} // print_trace()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::InvalidInstr::InvalidInstr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // InvalidInstr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::InvalidInstr::~InvalidInstr() {

} // ~InvalidInstr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::InvalidInstr::behavior() {
  THROW_EXCEPTION("Invalid instruction at PC=" << std::hex << std::showbase <<
  this->RB[15] << '.');
  return 0;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::InvalidInstr::replicate() const throw() {
  return new InvalidInstr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::InvalidInstr::set_params(const unsigned& bitstring)
throw() {

} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::InvalidInstr::get_name() const throw() {
  return "InvalidInstruction";
} // get_name()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::InvalidInstr::get_mnemonic() const throw() {
  return "invalid";
} // get_mnemonic()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::InvalidInstr::get_id() const throw() {
  return 161;
} // get_id()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::UpdatePSRAddOp::UpdatePSRAddOp(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // UpdatePSRAddOp()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::UpdatePSRAddOp::UpdatePSRAdd(
    trap::RegisterAlias<unsigned>& rn,
    unsigned& rn_bit,
    trap::RegisterAlias<unsigned>& rd,
    unsigned& rd_bit,
    unsigned& s,
    unsigned& operand1,
    unsigned& operand2,
    bool& carry) {
  unsigned num_cycles = 0;


  if (rd_bit == 15) {
    if (s) {
      unsigned value = 0, mask = 0;
      int spsr_idx = get_spsr_idx(CPSR[CPSR_M]);
      if (spsr_idx >= 0) {
        value = *(SPSR + spsr_idx);
        mask = psr_mask(value, 0xF, CPSR[CPSR_M], false, true);
        if (mask) CPSR = (CPSR & !mask) | (value & mask);
      }
    }
    if (!s || (CPSR[CPSR_M] != (unsigned)EXECMODE::HYP) || !CPSR[CPSR_J] ||
    !CPSR[CPSR_T])
    BranchWritePC(rd);
  } else {
    // Update the flags only for s = 0x1.
    if (s == 0x1) {
      carry = CPSR[CPSR_C];
      AddWithCarry(operand1, operand2, 0);
    }
  }

  return num_cycles;
} // UpdatePSRAdd()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::ConditionPassedOp::ConditionPassedOp(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // ConditionPassedOp()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ConditionPassedOp::ConditionPassed(unsigned& cond)
{
  unsigned num_cycles = 0;


  /// Uses the ARM/Thumb condition specifier to determine whether the instruction
  /// must be executed.
  if (cond /* TODO: CurrentCond() */!= 0xE) {
    // Of course the previous if is redundant, the case would be enough, but
    // since cond == 0xE is the most common situation, treating it in a particular
    // way makes the code a bit faster.
    switch(cond) {
      case 0x0: {
        // EQ: CPSR[CPSR_Z]
        if (CPSR[CPSR_Z] == 0x0) {
          Instruction::annul();
        }
        break;
      }
      case 0x1: {
        // NE: !CPSR[CPSR_Z]
        if (CPSR[CPSR_Z] != 0x0) {
          Instruction::annul();
        }
        break;
      }
      case 0x2: {
        // CS/HS: CPSR[CPSR_V]
        if (CPSR[CPSR_C] == 0x0) {
          Instruction::annul();
        }
        break;
      }
      case 0x3: {
        // CC/LO: !CPSR[CPSR_C]
        if (CPSR[CPSR_C] != 0x0) {
          Instruction::annul();
        }
        break;
      }
      case 0x4: {
        // MI: CPSR[CPSR_N]
        if (CPSR[CPSR_N] == 0x0) {
          Instruction::annul();
        }
        break;
      }
      case 0x5: {
        // PL: !CPSR[CPSR_N]
        if (CPSR[CPSR_N] != 0x0) {
          Instruction::annul();
        }
        break;
      }
      case 0x6: {
        // VS: CPSR[CPSR_V]
        if (CPSR[CPSR_V] == 0x0) {
          Instruction::annul();
        }
        break;
      }
      case 0x7: {
        // VC: !CPSR[CPSR_V]
        if (CPSR[CPSR_V] != 0x0) {
          Instruction::annul();
        }
        break;
      }
      case 0x8: {
        // HI: !CPSR[CPSR_Z] && CPSR[CPSR_C]
        if ((CPSR & 0x60000000) != 0x20000000) {
          Instruction::annul();
        }
        break;
      }
      case 0x9: {
        // LS: CPSR[CPSR_Z] || !CPSR[CPSR_C]
        if ((CPSR & 0x60000000) == 0x20000000) {
          Instruction::annul();
        }
        break;
      }
      case 0xA: {
        // GE: CPSR[CPSR_N] == CPSR[CPSR_V]
        if (CPSR[CPSR_V] != CPSR[CPSR_N]) {
          Instruction::annul();
        }
        break;
      }
      case 0xB: {
        // LT: CPSR[CPSR_N] != CPSR[CPSR_V]
        if (CPSR[CPSR_V] == CPSR[CPSR_N]) {
          Instruction::annul();
        }
        break;
      }
      case 0xC: {
        // GT: CPSR[CPSR_N] == CPSR[CPSR_V] && !CPSR[CPSR_Z]
        if ((CPSR[CPSR_Z] != 0x0) || (CPSR[CPSR_V] != CPSR[CPSR_N])) {
          Instruction::annul();
        }
        break;
      }
      case 0xD: {
        // LE: CPSR[CPSR_N] != CPSR[CPSR_V] || CPSR[CPSR_Z]
        if ((CPSR[CPSR_Z] == 0x0) && (CPSR[CPSR_V] == CPSR[CPSR_N])) {
          Instruction::annul();
        }
        break;
      }
      case 0xF: {
        // AL
        break;
      }
      default: {
        // Unrecognized condition code
        THROW_EXCEPTION("Unrecognized condition code " << cond << ".");
        break;
      }
    }
  }

  return num_cycles;
} // ConditionPassed()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::ARMExpandImmOp::ARMExpandImmOp(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // ARMExpandImmOp()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ARMExpandImmOp::ARMExpandImm(
    unsigned& rotate,
    unsigned& imm,
    unsigned& operand,
    bool& carry) {
  unsigned num_cycles = 0;


  operand = ROR(imm, rotate<<1, carry);

  return num_cycles;
} // ARMExpandImm()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::DecodeImmShiftOp::DecodeImmShiftOp(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // DecodeImmShiftOp()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::DecodeImmShiftOp::DecodeImmShift(
    trap::RegisterAlias<unsigned>& rm,
    unsigned& rm_bit,
    unsigned& shift_amm,
    unsigned& shift_op,
    unsigned& operand,
    bool& carry) {
  unsigned num_cycles = 0;


  switch(shift_op & 0x3) {
    case 0x0:
    // Logical shift left
    operand = LSL(rm, shift_amm, carry);
    break;
    case 0x1:
    // Logical shift right
    operand = LSR(rm, shift_amm? shift_amm : 32, carry);
    break;
    case 0x2:
    // Arithmetic shift right
    operand = ASR(rm, shift_amm? shift_amm : 32, carry);
    break;
    case 0x3:
    if (shift_amm) {
      // Rotate right
      operand = ROR(rm, shift_amm, carry);
    } else {
      // Rotate right with extend
      operand = RRX(rm, carry, carry);
    }
    break;
  }

  return num_cycles;
} // DecodeImmShift()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::DecodeRegShiftOp::DecodeRegShiftOp(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // DecodeRegShiftOp()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::DecodeRegShiftOp::DecodeRegShift(
    trap::RegisterAlias<unsigned>& rm,
    unsigned& rm_bit,
    trap::RegisterAlias<unsigned>& rs,
    unsigned& rs_bit,
    unsigned& shift_op,
    unsigned& operand,
    bool& carry) {
  unsigned num_cycles = 0;


  unsigned shift_amm = rs & 0x000000FF;
  switch(shift_op & 0x3) {
    case 0x0:
    // Logical shift left
    operand = LSL(rm, shift_amm, carry);
    break;
    case 0x1:
    // Logical shift right
    operand = LSR(rm, shift_amm, carry);
    break;
    case 0x2:
    // Arithmetic shift right
    operand = ASR(rm, shift_amm, carry);
    break;
    case 0x3:
    // Rotate right
    operand = ROR(rm, shift_amm, carry);
    break;
  }
  num_cycles = 1;

  return num_cycles;
} // DecodeRegShift()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::UpdatePSRAddWithCarryOp::UpdatePSRAddWithCarryOp(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // UpdatePSRAddWithCarryOp()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::UpdatePSRAddWithCarryOp::UpdatePSRAddWithCarry(
    trap::RegisterAlias<unsigned>& rn,
    unsigned& rn_bit,
    trap::RegisterAlias<unsigned>& rd,
    unsigned& rd_bit,
    unsigned& s,
    unsigned& operand1,
    unsigned& operand2,
    bool& carry) {
  unsigned num_cycles = 0;


  if (rd_bit == 15) {
    if (s) {
      unsigned value = 0, mask = 0;
      int spsr_idx = get_spsr_idx(CPSR[CPSR_M]);
      if (spsr_idx >= 0) {
        value = *(SPSR + spsr_idx);
        mask = psr_mask(value, 0xF, CPSR[CPSR_M], false, true);
        if (mask) CPSR = (CPSR & !mask) | (value & mask);
      }
    }
    if (!s || (CPSR[CPSR_M] != (unsigned)EXECMODE::HYP) || !CPSR[CPSR_J] ||
    !CPSR[CPSR_T])
    BranchWritePC(rd);
  } else {
    // Update the flags only for s = 0x1.
    if (s == 0x1) {
      carry = CPSR[CPSR_C];
      AddWithCarry(operand1, operand2, carry);
    }
  }

  return num_cycles;
} // UpdatePSRAddWithCarry()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::UpdatePSRSubOp::UpdatePSRSubOp(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // UpdatePSRSubOp()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::UpdatePSRSubOp::UpdatePSRSub(
    trap::RegisterAlias<unsigned>& rn,
    unsigned& rn_bit,
    trap::RegisterAlias<unsigned>& rd,
    unsigned& rd_bit,
    unsigned& s,
    unsigned& operand1,
    unsigned& operand2,
    bool& carry) {
  unsigned num_cycles = 0;


  if (rd_bit == 15) {
    if (s) {
      unsigned value = 0, mask = 0;
      int spsr_idx = get_spsr_idx(CPSR[CPSR_M]);
      if (spsr_idx >= 0) {
        value = *(SPSR + spsr_idx);
        mask = psr_mask(value, 0xF, CPSR[CPSR_M], false, true);
        if (mask) CPSR = (CPSR & !mask) | (value & mask);
      }
    }
    if (!s || (CPSR[CPSR_M] != (unsigned)EXECMODE::HYP) || !CPSR[CPSR_J] ||
    !CPSR[CPSR_T])
    BranchWritePC(rd);
  } else {
    // Update the flags only for s = 0x1.
    if (s == 0x1) {
      carry = CPSR[CPSR_C];
      update_psr_sub(operand1, operand2, 0);
    }
  }

  return num_cycles;
} // UpdatePSRSub()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::UpdatePSRSubWithCarryOp::UpdatePSRSubWithCarryOp(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // UpdatePSRSubWithCarryOp()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::UpdatePSRSubWithCarryOp::UpdatePSRSubWithCarry(
    trap::RegisterAlias<unsigned>& rn,
    unsigned& rn_bit,
    trap::RegisterAlias<unsigned>& rd,
    unsigned& rd_bit,
    unsigned& s,
    unsigned& operand1,
    unsigned& operand2,
    bool& carry) {
  unsigned num_cycles = 0;


  if (rd_bit == 15) {
    if (s) {
      unsigned value = 0, mask = 0;
      int spsr_idx = get_spsr_idx(CPSR[CPSR_M]);
      if (spsr_idx >= 0) {
        value = *(SPSR + spsr_idx);
        mask = psr_mask(value, 0xF, CPSR[CPSR_M], false, true);
        if (mask) CPSR = (CPSR & !mask) | (value & mask);
      }
    }
    if (!s || (CPSR[CPSR_M] != (unsigned)EXECMODE::HYP) || !CPSR[CPSR_J] ||
    !CPSR[CPSR_T])
    BranchWritePC(rd);
  } else {
    // Update the flags only for s = 0x1.
    if (s == 0x1) {
      carry = (CPSR[CPSR_C] == 0);
      update_psr_sub(operand1, operand2, carry);
    }
  }

  return num_cycles;
} // UpdatePSRSubWithCarry()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::UpdatePSRMulOp::UpdatePSRMulOp(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // UpdatePSRMulOp()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::UpdatePSRMulOp::UpdatePSRMul(
    unsigned& ss,
    unsigned& s,
    unsigned& l,
    sc_dt::uint64& result) {
  unsigned num_cycles = 0;


  // Update the flags only for MUL/MLA and s = 0x1.
  if (!ss && s == 0x1) {
    if (l) {
      // Update N (negative flag) if result is negative (bit[31]).
      CPSR[CPSR_N] = ((result & 0x80000000) != 0);
    } else {
      // Update N (negative flag) if result is negative (bit[63]).
      CPSR[CPSR_N] = ((result & 0x8000000000000000LL) != 0);
    }

    // Update Z (zero flag) if result is 0.
    CPSR[CPSR_Z] = (result == 0);
  }

  return num_cycles;
} // UpdatePSRMul()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::UpdatePSRBitOp::UpdatePSRBitOp(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // UpdatePSRBitOp()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::UpdatePSRBitOp::UpdatePSRBit(
    trap::RegisterAlias<unsigned>& rn,
    unsigned& rn_bit,
    trap::RegisterAlias<unsigned>& rd,
    unsigned& rd_bit,
    unsigned& s,
    unsigned& result,
    bool& carry) {
  unsigned num_cycles = 0;


  if (rd_bit == 15) {
    // rd = 15 && s implies a different instruction and is not handled here.
    if (!s) {
      BranchWritePC(result);
    }
  } else {
    // Update the flags only for s = 0x1.
    if (s == 0x1) {
      update_psr_bit(result, carry);
    }
  }

  return num_cycles;
} // UpdatePSRBit()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LSOffsetOp::LSOffsetOp(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // LSOffsetOp()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LSOffsetOp::LSOffset(
    trap::RegisterAlias<unsigned>& rn,
    unsigned& rn_bit,
    unsigned& p,
    unsigned& u,
    unsigned& w,
    unsigned& operand,
    unsigned& address) {
  unsigned num_cycles = 0;


  /** Addressing Modes:
  *  Offset: The offset is added to or subtracted from the base address to form
  the memory address.
  *  Pre-indexed: The offset is added to or subtracted form the base address to
  form the memory address. The base register is then updated with this new
  address, to permit automatic indexing through an array or memory block.
  *  Post-indexed: The value of the base register alone is used as the memory
  address. The offset is then added to subtracted from the base register and
  the result stored back in the base register, to permit automatic indexing
  through an array or memory block.
  **/
  unsigned disp = (u? rn + operand : rn - operand);
  //address = (p? disp : rn);
  //rn = ((w || !p)? disp : rn);

  if (p == 1) {
    // offset or pre-indexed
    address = disp;
    if (w == 1) {
      // pre-indexed
      rn = disp;
    }
  } else {
    // post-indexed
    address = rn;
    rn = disp;
  }

  return num_cycles;
} // LSOffset()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LSMReglistOp::LSMReglistOp(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // LSMReglistOp()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LSMReglistOp::LSMReglist(
    trap::RegisterAlias<unsigned>& rn,
    unsigned& rn_bit,
    unsigned& p,
    unsigned& u,
    unsigned& reg_list,
    unsigned& start_address,
    unsigned& wb_address) {
  unsigned num_cycles = 0;


  // NOTE: Search algorithm for counting ones taken from Brian W. Kernighan and
  // Dennis M. Ritchie, "The C Programming Language," 1988.
  unsigned input = reg_list;
  unsigned setbits = 0;
  for (; input; setbits++) {
    // Clears least significant set bit.
    input &= input - 1;
  }

  // Calculate start and end addresses of memory where registers will be saved.
  if (u == 1) {
    if (p == 0) {
      // Increment after (u == 1 && p == 0).
      start_address = rn;
      wb_address = start_address + (setbits * 4);
    } else {
      // Increment before (u == 1 && p == 1).
      start_address = rn + 4;
      wb_address = start_address - 4 + (setbits * 4);
    }
  } else {
    if (p == 0) {
      // Decrement after (u == 0 && p == 0).
      start_address = rn - (setbits * 4) + 4;
      wb_address = start_address - 4;
    } else {
      // Decrement before (u == 0 && p == 1).
      start_address = rn - (setbits * 4);
      wb_address = start_address;
    }
  }

  // Note that the addresses are word aligned, so the last 2 bits of the addresses
  // are ignored.
  start_address &= 0xFFFFFFFC;
  wb_address &= 0xFFFFFFFC;

  return num_cycles;
} // LSMReglist()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::ADD_i::ADD_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRAddOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles) {

} // ADD_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::ADD_i::~ADD_i() {

} // ~ADD_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ADD_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  // ADR
  if (!s && (rn_bit == 15))
  operand1 = PC & 0xFFFFFFFC;
  else
  operand1 = (int)rn;
  operand2 = (int)operand;
  rd = operand1 + operand2;
  this->total_cycles += UpdatePSRAdd(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::ADD_i::replicate() const throw() {
  return new ADD_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ADD_i::get_name() const throw() {
  return "ADD_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ADD_i::get_id() const throw() {
  return 0;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::ADD_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ADD_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->s) {
    default: {
      switch(this->rn_bit) {
        default: {
          oss << "ADD";
        break;}
        case 15: {
          oss << "ADR";
        break;}
      }
    break;}
    case 1: {
      oss << "ADDS";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::ADD_r::ADD_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRAddOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles) {

} // ADD_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::ADD_r::~ADD_r() {

} // ~ADD_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ADD_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  // ADR
  if (!s && (rn_bit == 15))
  operand1 = PC & 0xFFFFFFFC;
  else
  operand1 = (int)rn;
  operand2 = (int)operand;
  rd = operand1 + operand2;
  this->total_cycles += UpdatePSRAdd(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::ADD_r::replicate() const throw() {
  return new ADD_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ADD_r::get_name() const throw() {
  return "ADD_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ADD_r::get_id() const throw() {
  return 1;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::ADD_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ADD_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "ADD";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::ADD_sr::ADD_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  UpdatePSRAddOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // ADD_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::ADD_sr::~ADD_sr() {

} // ~ADD_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ADD_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid ADD (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);

  // ADR
  if (!s && (rn_bit == 15))
  operand1 = PC & 0xFFFFFFFC;
  else
  operand1 = (int)rn;
  operand2 = (int)operand;
  rd = operand1 + operand2;
  this->total_cycles += UpdatePSRAdd(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::ADD_sr::replicate() const throw() {
  return new ADD_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ADD_sr::get_name() const throw() {
  return "ADD_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ADD_sr::get_id() const throw() {
  return 2;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::ADD_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ADD_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "ADD";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::ADC_i::ADC_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRAddWithCarryOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles) {

} // ADC_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::ADC_i::~ADC_i() {

} // ~ADC_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ADC_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  operand1 = (int)rn;
  operand2 = (int)operand;
  rd = operand1 + operand2 + (unsigned)CPSR[CPSR_C];
  this->total_cycles += UpdatePSRAddWithCarry(this->rn, this->rn_bit, this->rd,
  this->rd_bit, this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::ADC_i::replicate() const throw() {
  return new ADC_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ADC_i::get_name() const throw() {
  return "ADC_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ADC_i::get_id() const throw() {
  return 3;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::ADC_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ADC_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "ADC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::ADC_r::ADC_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRAddWithCarryOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles) {

} // ADC_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::ADC_r::~ADC_r() {

} // ~ADC_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ADC_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  operand1 = (int)rn;
  operand2 = (int)operand;
  rd = operand1 + operand2 + (unsigned)CPSR[CPSR_C];
  this->total_cycles += UpdatePSRAddWithCarry(this->rn, this->rn_bit, this->rd,
  this->rd_bit, this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::ADC_r::replicate() const throw() {
  return new ADC_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ADC_r::get_name() const throw() {
  return "ADC_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ADC_r::get_id() const throw() {
  return 4;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::ADC_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ADC_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "ADC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::ADC_sr::ADC_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  UpdatePSRAddWithCarryOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // ADC_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::ADC_sr::~ADC_sr() {

} // ~ADC_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ADC_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid ADC (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);

  operand1 = (int)rn;
  operand2 = (int)operand;
  rd = operand1 + operand2 + (unsigned)CPSR[CPSR_C];
  this->total_cycles += UpdatePSRAddWithCarry(this->rn, this->rn_bit, this->rd,
  this->rd_bit, this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::ADC_sr::replicate() const throw() {
  return new ADC_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ADC_sr::get_name() const throw() {
  return "ADC_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ADC_sr::get_id() const throw() {
  return 5;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::ADC_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ADC_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "ADC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::SUB_i::SUB_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRSubOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles) {

} // SUB_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::SUB_i::~SUB_i() {

} // ~SUB_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SUB_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  // ADR
  if (!s && (rn_bit == 15))
  operand1 = PC & 0xFFFFFFFC;
  else
  operand1 = (int)rn;
  operand2 = (int)operand;
  rd = operand1 - operand2;
  this->total_cycles += UpdatePSRSub(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::SUB_i::replicate() const throw() {
  return new SUB_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SUB_i::get_name() const throw() {
  return "SUB_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SUB_i::get_id() const throw() {
  return 6;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::SUB_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SUB_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "SUB";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::SUB_r::SUB_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRSubOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles) {

} // SUB_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::SUB_r::~SUB_r() {

} // ~SUB_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SUB_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  // ADR
  if (!s && (rn_bit == 15))
  operand1 = PC & 0xFFFFFFFC;
  else
  operand1 = (int)rn;
  operand2 = (int)operand;
  rd = operand1 - operand2;
  this->total_cycles += UpdatePSRSub(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::SUB_r::replicate() const throw() {
  return new SUB_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SUB_r::get_name() const throw() {
  return "SUB_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SUB_r::get_id() const throw() {
  return 7;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::SUB_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SUB_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "SUB";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::SUB_sr::SUB_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  UpdatePSRSubOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // SUB_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::SUB_sr::~SUB_sr() {

} // ~SUB_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SUB_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid SUB (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);

  // ADR
  if (!s && (rn_bit == 15))
  operand1 = PC & 0xFFFFFFFC;
  else
  operand1 = (int)rn;
  operand2 = (int)operand;
  rd = operand1 - operand2;
  this->total_cycles += UpdatePSRSub(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::SUB_sr::replicate() const throw() {
  return new SUB_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SUB_sr::get_name() const throw() {
  return "SUB_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SUB_sr::get_id() const throw() {
  return 8;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::SUB_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SUB_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "SUB";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::SBC_i::SBC_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRSubWithCarryOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles) {

} // SBC_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::SBC_i::~SBC_i() {

} // ~SBC_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SBC_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  operand1 = (int)rn;
  operand2 = (int)operand;
  rd = operand1 - operand2;

  if (CPSR[CPSR_C] == 0x0) {
    rd = ((int)rd) - 1;
  }
  this->total_cycles += UpdatePSRSubWithCarry(this->rn, this->rn_bit, this->rd,
  this->rd_bit, this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::SBC_i::replicate() const throw() {
  return new SBC_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SBC_i::get_name() const throw() {
  return "SBC_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SBC_i::get_id() const throw() {
  return 9;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::SBC_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SBC_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "SBC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::SBC_r::SBC_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRSubWithCarryOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles) {

} // SBC_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::SBC_r::~SBC_r() {

} // ~SBC_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SBC_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  operand1 = (int)rn;
  operand2 = (int)operand;
  rd = operand1 - operand2;

  if (CPSR[CPSR_C] == 0x0) {
    rd = ((int)rd) - 1;
  }
  this->total_cycles += UpdatePSRSubWithCarry(this->rn, this->rn_bit, this->rd,
  this->rd_bit, this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::SBC_r::replicate() const throw() {
  return new SBC_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SBC_r::get_name() const throw() {
  return "SBC_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SBC_r::get_id() const throw() {
  return 10;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::SBC_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SBC_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "SBC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::SBC_sr::SBC_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  UpdatePSRSubWithCarryOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // SBC_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::SBC_sr::~SBC_sr() {

} // ~SBC_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SBC_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid SBC (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);

  operand1 = (int)rn;
  operand2 = (int)operand;
  rd = operand1 - operand2;

  if (CPSR[CPSR_C] == 0x0) {
    rd = ((int)rd) - 1;
  }
  this->total_cycles += UpdatePSRSubWithCarry(this->rn, this->rn_bit, this->rd,
  this->rd_bit, this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::SBC_sr::replicate() const throw() {
  return new SBC_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SBC_sr::get_name() const throw() {
  return "SBC_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SBC_sr::get_id() const throw() {
  return 11;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::SBC_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SBC_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "SBC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::RSB_i::RSB_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRSubOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles) {

} // RSB_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::RSB_i::~RSB_i() {

} // ~RSB_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::RSB_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  operand1 = (int)operand;
  operand2 = (int)rn;
  rd = operand1 - operand2;
  this->total_cycles += UpdatePSRSub(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::RSB_i::replicate() const throw() {
  return new RSB_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::RSB_i::get_name() const throw() {
  return "RSB_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::RSB_i::get_id() const throw() {
  return 12;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::RSB_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::RSB_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "RSB";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::RSB_r::RSB_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRSubOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles) {

} // RSB_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::RSB_r::~RSB_r() {

} // ~RSB_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::RSB_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  operand1 = (int)operand;
  operand2 = (int)rn;
  rd = operand1 - operand2;
  this->total_cycles += UpdatePSRSub(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::RSB_r::replicate() const throw() {
  return new RSB_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::RSB_r::get_name() const throw() {
  return "RSB_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::RSB_r::get_id() const throw() {
  return 13;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::RSB_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::RSB_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "RSB";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::RSB_sr::RSB_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  UpdatePSRSubOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // RSB_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::RSB_sr::~RSB_sr() {

} // ~RSB_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::RSB_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid RSB (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);

  operand1 = (int)operand;
  operand2 = (int)rn;
  rd = operand1 - operand2;
  this->total_cycles += UpdatePSRSub(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::RSB_sr::replicate() const throw() {
  return new RSB_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::RSB_sr::get_name() const throw() {
  return "RSB_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::RSB_sr::get_id() const throw() {
  return 14;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::RSB_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::RSB_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "RSB";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::RSC_i::RSC_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRSubWithCarryOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles) {

} // RSC_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::RSC_i::~RSC_i() {

} // ~RSC_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::RSC_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  operand1 = (int)operand;
  operand2 = (int)rn;
  rd = operand1 - operand2;

  if (CPSR[CPSR_C] == 0x0) {
    rd = ((int)rd) - 1;
  }
  this->total_cycles += UpdatePSRSubWithCarry(this->rn, this->rn_bit, this->rd,
  this->rd_bit, this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::RSC_i::replicate() const throw() {
  return new RSC_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::RSC_i::get_name() const throw() {
  return "RSC_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::RSC_i::get_id() const throw() {
  return 15;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::RSC_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::RSC_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "RSC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::RSC_r::RSC_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRSubWithCarryOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles) {

} // RSC_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::RSC_r::~RSC_r() {

} // ~RSC_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::RSC_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  operand1 = (int)operand;
  operand2 = (int)rn;
  rd = operand1 - operand2;

  if (CPSR[CPSR_C] == 0x0) {
    rd = ((int)rd) - 1;
  }
  this->total_cycles += UpdatePSRSubWithCarry(this->rn, this->rn_bit, this->rd,
  this->rd_bit, this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::RSC_r::replicate() const throw() {
  return new RSC_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::RSC_r::get_name() const throw() {
  return "RSC_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::RSC_r::get_id() const throw() {
  return 16;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::RSC_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::RSC_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "RSC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::RSC_sr::RSC_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  UpdatePSRSubWithCarryOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // RSC_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::RSC_sr::~RSC_sr() {

} // ~RSC_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::RSC_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid RSC (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);

  operand1 = (int)operand;
  operand2 = (int)rn;
  rd = operand1 - operand2;

  if (CPSR[CPSR_C] == 0x0) {
    rd = ((int)rd) - 1;
  }
  this->total_cycles += UpdatePSRSubWithCarry(this->rn, this->rn_bit, this->rd,
  this->rd_bit, this->s, this->operand1, this->operand2, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::RSC_sr::replicate() const throw() {
  return new RSC_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::RSC_sr::get_name() const throw() {
  return "RSC_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::RSC_sr::get_id() const throw() {
  return 17;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::RSC_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::RSC_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "RSC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::USHQADD::USHQADD(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // USHQADD()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::USHQADD::~USHQADD() {

} // ~USHQADD()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USHQADD::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (U|S|UH|SH|UQ|Q)ADD(8|16) encoding: rn|rd|rm = 0xF.");

  if (rs_bit != 15)
  THROW_WARNING("Invalid (U|S|UH|SH|UQ|Q)ADD(8|16) encoding: rs != 0xF.");

  int sum1, sum2, sum3, sum4;
  unsigned mask1, mask2, mask3, mask4;
  unsigned shift2, shift3, shift4;
  int overflow;

  // 16-bit vs. 8-bit
  if (b) {
    // xxADD8
    mask1 = 0x000000FF;
    mask2 = 0x0000FF00;
    shift2 = 8;
    mask3 = 0x00FF0000;
    shift3 = 16;
    mask4 = 0xFF000000;
    shift4 = 24;
  } else {
    // xxADD16
    mask1 = 0x0000FFFF;
    mask2 = 0;
    shift2 = 0;
    mask3 = 0xFFFF0000;
    shift3 = 16;
    mask4 = 0;
    shift4 = 0;
  }

  // Unsigned vs. signed
  if (u) {
    // UxADDx
    sum1 = (unsigned)(rn & mask1) + (unsigned)(rm & mask1);
    sum2 = ((unsigned)(rn & mask2) >> shift2) + ((unsigned)(rm & mask2) >>
    shift2);
    sum3 = ((unsigned)(rn & mask3) >> shift3) + ((unsigned)(rm & mask3) >>
    shift3);
    sum4 = ((unsigned)(rn & mask4) >> shift4) + ((unsigned)(rm & mask4) >>
    shift4);
    overflow = mask1;
  } else {
    // SxADDx
    sum1 = (rn & mask1) + (rm & mask1);
    sum2 = ((rn & mask2) >> shift2) + ((rm & mask2) >> shift2);
    sum3 = ((rn & mask3) >> shift3) + ((rm & mask3) >> shift3);
    sum4 = ((rn & mask4) >> shift4) + ((rm & mask4) >> shift4);
    overflow = -1;
  }

  // Halving vs. saturating vs. regular
  if (h && nq) {
    // xHADDx
    sum1 >>= 1;
    sum2 >>= 1;
    sum3 >>= 1;
    sum4 >>= 1;
  } else if (!nq) {
    // xQADDx
    sum1 = sat_q(sum1, 16 >> b, !u, false);
    sum2 = sat_q(sum2, 16 >> b, !u, false);
    sum3 = sat_q(sum3, 16 >> b, !u, false);
    sum4 = sat_q(sum4, 16 >> b, !u, false);
  } else {
    // x_ADDx
    CPSR[CPSR_GE] = 0;
    if (sum1 > overflow) {
      CPSR[CPSR_GE] = 0x1;
      if (!mask2) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x2;
    }
    if (sum2 > overflow) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x2;
    if (sum3 > overflow) {
      CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x4;
      if (!mask4) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x8;
    }
    if (sum4 > overflow) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x8;
  }

  rd = ((sum4 & mask1) << shift4)
  | ((sum3 & mask1) << shift3)
  | ((sum2 & mask1) << shift2)
  | (sum1 & mask1);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::USHQADD::replicate() const throw() {
  return new USHQADD(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USHQADD::get_name() const throw() {
  return "USHQADD";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USHQADD::get_id() const throw() {
  return 18;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::USHQADD::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->u = (bitstring & 0x400000) >> 22;
  this->h = (bitstring & 0x200000) >> 21;
  this->nq = (bitstring & 0x100000) >> 20;
  this->b = (bitstring & 0x80) >> 7;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USHQADD::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->u) {
    case 0: {
      oss << "S";
    break;}
    case 1: {
      oss << "U";
    break;}
  }
  switch(this->h) {
    case 1: {
      switch(this->nq) {
        case 0: {
          oss << "Q";
        break;}
        case 1: {
          oss << "H";
        break;}
      }
    break;}
  }
  oss << "ADD";
  switch(this->b) {
    case 0: {
      oss << "16";
    break;}
    case 1: {
      oss << "8";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::USHQSUB::USHQSUB(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // USHQSUB()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::USHQSUB::~USHQSUB() {

} // ~USHQSUB()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USHQSUB::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (U|S|UH|SH|UQ|Q)SUB(8|16) encoding: rn|rd|rm = 0xF.");

  if (rs_bit != 15)
  THROW_WARNING("Invalid (U|S|UH|SH|UQ|Q)SUB(8|16) encoding: rs != 0xF.");

  int sum1, sum2, sum3, sum4;
  unsigned mask1, mask2, mask3, mask4;
  unsigned shift2, shift3, shift4;

  // 16-bit vs. 8-bit
  if (b) {
    // xxSUB8
    mask1 = 0x000000FF;
    mask2 = 0x0000FF00;
    shift2 = 8;
    mask3 = 0x00FF0000;
    shift3 = 16;
    mask4 = 0xFF000000;
    shift4 = 24;
  } else {
    // xxSUB16
    mask1 = 0x0000FFFF;
    mask2 = 0;
    shift2 = 0;
    mask3 = 0xFFFF0000;
    shift3 = 16;
    mask4 = 0;
    shift4 = 0;
  }

  // Unsigned vs. signed
  if (u) {
    // UxSUBx
    sum1 = (unsigned)(rn & mask1) - (unsigned)(rm & mask1);
    sum2 = ((unsigned)(rn & mask2) >> shift2) - ((unsigned)(rm & mask2) >>
    shift2);
    sum3 = ((unsigned)(rn & mask3) >> shift3) - ((unsigned)(rm & mask3) >>
    shift3);
    sum4 = ((unsigned)(rn & mask4) >> shift4) - ((unsigned)(rm & mask4) >>
    shift4);
  } else {
    // SxSUBx
    sum1 = (rn & mask1) - (rm & mask1);
    sum2 = ((rn & mask2) >> shift2) - ((rm & mask2) >> shift2);
    sum3 = ((rn & mask3) >> shift3) - ((rm & mask3) >> shift3);
    sum4 = ((rn & mask4) >> shift4) - ((rm & mask4) >> shift4);
  }

  // Halving vs. saturating vs. regular
  if (h && nq) {
    // xHSUBx
    sum1 >>= 1;
    sum2 >>= 1;
    sum3 >>= 1;
    sum4 >>= 1;
  } else if (!nq) {
    // xQSUBx
    sum1 = sat_q(sum1, 16 >> b, !u, false);
    sum2 = sat_q(sum2, 16 >> b, !u, false);
    sum3 = sat_q(sum3, 16 >> b, !u, false);
    sum4 = sat_q(sum4, 16 >> b, !u, false);
  } else {
    // x_SUBx
    CPSR[CPSR_GE] = 0;
    if (sum1 >= 0) {
      CPSR[CPSR_GE] = 0x1;
      if (!mask2) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x2;
    }
    if (sum2 >= 0) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x2;
    if (sum3 >= 0) {
      CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x4;
      if (!mask4) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x8;
    }
    if (sum4 >= 0) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x8;
  }

  rd = ((sum4 & mask1) << shift4)
  | ((sum3 & mask1) << shift3)
  | ((sum2 & mask1) << shift2)
  | (sum1 & mask1);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::USHQSUB::replicate() const throw() {
  return new USHQSUB(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USHQSUB::get_name() const throw() {
  return "USHQSUB";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USHQSUB::get_id() const throw() {
  return 19;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::USHQSUB::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->u = (bitstring & 0x400000) >> 22;
  this->h = (bitstring & 0x200000) >> 21;
  this->nq = (bitstring & 0x100000) >> 20;
  this->b = (bitstring & 0x80) >> 7;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USHQSUB::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->u) {
    case 0: {
      oss << "S";
    break;}
    case 1: {
      oss << "U";
    break;}
  }
  switch(this->h) {
    case 1: {
      switch(this->nq) {
        case 0: {
          oss << "Q";
        break;}
        case 1: {
          oss << "H";
        break;}
      }
    break;}
  }
  oss << "SUB";
  switch(this->b) {
    case 0: {
      oss << "16";
    break;}
    case 1: {
      oss << "8";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::USADA8::USADA8(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // USADA8()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::USADA8::~USADA8() {

} // ~USADA8()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USADA8::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (USAD8/USADA8 encoding: rn|rd|rm = 0xF.");

  int diff1, diff2, diff3, diff4;

  diff1 = (unsigned)(rn & 0x000000FF) - (unsigned)(rm & 0x000000FF);
  diff1 = (diff1 < 0)? diff1 : -diff1;
  diff2 = ((unsigned)(rn & 0x0000FF00) >> 8) - ((unsigned)(rm & 0x0000FF00) >>
  8);
  diff2 = (diff2 < 0)? diff2 : -diff2;
  diff3 = ((unsigned)(rn & 0x00FF0000) >> 16) - ((unsigned)(rm & 0x00FF0000) >>
  16);
  diff3 = (diff3 < 0)? diff3 : -diff3;
  diff4 = ((unsigned)(rn & 0xFF000000) >> 24) - ((unsigned)(rm & 0xFF000000) >>
  24);
  diff4 = (diff4 < 0)? diff4 : -diff4;
  // NOTE: Alternative abs():
  // mask = 0 for diff1 > 0 else mask = 0xFFFFFFFF because of signed shift.
  //int mask = diff1 >> 31;
  // diff1 + mask = diff1 for diff1 > 0 else diff1 + mask = ~abs(diff1)
  //diff1 = (diff1 + mask) ^ mask;

  if (ra != 0xF)
  rd = (ra + diff1 + diff2 + diff3 + diff4) & 0xFFFFFFFF;
  else
  rd = (diff1 + diff2 + diff3 + diff4) & 0xFFFFFFFF;
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::USADA8::replicate() const throw() {
  return new USADA8(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USADA8::get_name() const throw() {
  return "USADA8";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USADA8::get_id() const throw() {
  return 20;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::USADA8::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf0000) >> 16;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf00) >> 8;
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf);
  this->rn.set_alias(REGS[this->rn_bit]);
  this->ra_bit = (bitstring & 0xf000) >> 12;
  this->ra.set_alias(REGS[this->ra_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USADA8::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->ra_bit) {
    default: {
      oss << "USADA8";
    break;}
    case 15: {
      oss << "USAD8";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::USXTAHB::USXTAHB(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // USXTAHB()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::USXTAHB::~USXTAHB() {

} // ~USXTAHB()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USXTAHB::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (UX|SX)(TH|TAH|TB(16)?|TAB(16)?) encoding: rd|rm = 0xF.");

  if (imm & 0x3)
  THROW_WARNING("Invalid (UX|SX)(TH|TAH|TB(16)?|TAB(16)?) encoding: bit[9:8] != 0x0.");

  unsigned mask;
  int result;

  // 16-bit vs. 8-bit source
  // xXTxH
  if (h) mask = 0xFFFF;
  // xXTxBx
  else mask = 0xFF;

  bool carry_dummy;
  result = ROR(rm, (imm << 1) & 0x18, carry_dummy) & mask;

  // Extend-to-word vs. extend-to-halfword
  if (w) {
    // xXTxx
    result &= mask;

    // Unsigned vs. signed
    if (!u) result = sign_extend(result, 8 << h);

    // Add vs. non-add
    if (rn_bit != 0xF) result += (unsigned)rn;

    rd = result;
  } else {
    int result2 = (result & 0x00FF0000) >> 16;
    result &= 0x000000FF;

    // xXTxB16
    // Unsigned vs. signed
    if (!u) {
      result2 = sign_extend(result2, 8) & 0xFFFF;
      result = sign_extend(result, 8) & 0xFFFF;
    }

    // Add vs. non-add
    if (rn_bit != 0xF) {
      result = ((((unsigned)rn & 0xFFFF) + result) & 0xFFFF)
      | (((((unsigned)rn >> 16) & 0xFFFF) + result2) & 0xFFFF);
    }

  }
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::USXTAHB::replicate() const throw() {
  return new USXTAHB(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USXTAHB::get_name() const throw() {
  return "USXTAHB";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USXTAHB::get_id() const throw() {
  return 21;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::USXTAHB::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->u = (bitstring & 0x400000) >> 22;
  this->w = (bitstring & 0x200000) >> 21;
  this->h = (bitstring & 0x100000) >> 20;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USXTAHB::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->u) {
    case 0: {
      oss << "S";
    break;}
    case 1: {
      oss << "U";
    break;}
  }
  oss << "XT";
  switch(this->rn_bit) {
    default: {
      oss << "A";
    break;}
    case 15: {
      oss << "";
    break;}
  }
  switch(this->h) {
    case 0: {
      oss << "B";
    break;}
    case 1: {
      oss << "H";
    break;}
  }
  switch(this->w) {
    case 0: {
      oss << "16";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->imm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::USHQASX::USHQASX(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // USHQASX()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::USHQASX::~USHQASX() {

} // ~USHQASX()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USHQASX::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (U|S|UH|SH|UQ|Q)ASX encoding: rn|rd|rm = 0xF.");

  if (rs_bit != 15)
  THROW_WARNING("Invalid (U|S|UH|SH|UQ|Q)ASX encoding: rs != 0xF.");

  int sum, diff;
  unsigned mask = 0xFFFF;

  // Unsigned vs. signed
  if (u) {
    // UxASX
    sum = (((unsigned)rn >> 16) & mask) + ((unsigned)rm & mask);
    diff = ((unsigned)rn & mask) - (((unsigned)rm >> 16) & mask);
  } else {
    // SxASX
    sum = ((rn >> 16) & mask) + (rm & mask);
    diff = (rn & mask) - ((rm >> 16) & mask);
  }

  // Halving vs. saturating vs. regular
  if (h && nq) {
    // xHASX
    sum >>= 1;
    diff >>= 1;
  } else if (!nq) {
    // xQSAX
    sum = sat_q(sum, 16, !u, false);
    diff = sat_q(diff, 16, !u, false);
  } else {
    // x_ASX
    CPSR[CPSR_GE] = 0;
    if (diff >= 0) CPSR[CPSR_GE] = 0x3;
    if (sum > 0xFFFF) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0xC;
  }

  rd = ((diff & mask) << 16) | (sum & mask);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::USHQASX::replicate() const throw() {
  return new USHQASX(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USHQASX::get_name() const throw() {
  return "USHQASX";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USHQASX::get_id() const throw() {
  return 22;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::USHQASX::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->u = (bitstring & 0x400000) >> 22;
  this->h = (bitstring & 0x200000) >> 21;
  this->nq = (bitstring & 0x100000) >> 20;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USHQASX::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->u) {
    case 0: {
      oss << "S";
    break;}
    case 1: {
      oss << "U";
    break;}
  }
  switch(this->h) {
    case 1: {
      switch(this->nq) {
        case 0: {
          oss << "Q";
        break;}
        case 1: {
          oss << "H";
        break;}
      }
    break;}
  }
  oss << "ASX";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::USHQSAX::USHQSAX(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // USHQSAX()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::USHQSAX::~USHQSAX() {

} // ~USHQSAX()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USHQSAX::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (U|S|UH|SH|UQ|Q)SAX encoding: rn|rd|rm = 0xF.");

  if (rs_bit != 15)
  THROW_WARNING("Invalid (U|S|UH|SH|UQ|Q)SAX encoding: rs != 0xF.");

  int sum, diff;
  unsigned mask = 0xFFFF;

  // Unsigned vs. signed
  if (u) {
    // UxASX
    sum = ((unsigned)rn & mask) + (((unsigned)rm >> 16) & mask);
    diff = (((unsigned)rn >> 16) & mask) - ((unsigned)rm & mask);
  } else {
    // SxASX
    sum = ((rn >> 16) & mask) + (rm & mask);
    diff = (rn & mask) - ((rm >> 16) & mask);
  }

  // Halving vs. saturating vs. regular
  if (h && nq) {
    // xHASX
    sum >>= 1;
    diff >>= 1;
  } else if (!nq) {
    // xQSAX
    sum = sat_q(sum, 16, !u, false);
    diff = sat_q(diff, 16, !u, false);
  } else {
    // x_ASX
    CPSR[CPSR_GE] = 0;
    if (diff >= 0) CPSR[CPSR_GE] = 0x3;
    if (sum > 0xFFFF) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0xC;
  }

  rd = ((sum & mask) << 16) | (diff & mask);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::USHQSAX::replicate() const throw() {
  return new USHQSAX(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USHQSAX::get_name() const throw() {
  return "USHQSAX";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USHQSAX::get_id() const throw() {
  return 23;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::USHQSAX::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->u = (bitstring & 0x400000) >> 22;
  this->h = (bitstring & 0x200000) >> 21;
  this->nq = (bitstring & 0x100000) >> 20;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USHQSAX::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->u) {
    case 0: {
      oss << "S";
    break;}
    case 1: {
      oss << "U";
    break;}
  }
  switch(this->h) {
    case 1: {
      oss << "H";
    break;}
  }
  oss << "SAX";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::USSAT::USSAT(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // USSAT()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::USSAT::~USSAT() {

} // ~USSAT()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USSAT::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (U|S)SAT encoding: rd|rm = 0xF.");

  // Needed by DecodeImmShift().
  shift_amm = imm1;
  shift_op = (op1a << 1);
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  rd = sat_q(operand, imm0, false, true);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::USSAT::replicate() const throw() {
  return new USSAT(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USSAT::get_name() const throw() {
  return "USSAT";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USSAT::get_id() const throw() {
  return 24;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::USSAT::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->u = (bitstring & 0x400000) >> 22;
  this->imm0 = (bitstring & 0x1f0000) >> 16;
  this->imm1 = (bitstring & 0xf80) >> 7;
  this->op1a = (bitstring & 0x40) >> 6;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USSAT::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->u) {
    case 0: {
      oss << "S";
    break;}
    case 1: {
      oss << "U";
    break;}
  }
  oss << "SAT";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->imm1;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->op1a;
  oss << "0";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::USSAT16::USSAT16(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // USSAT16()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::USSAT16::~USSAT16() {

} // ~USSAT16()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USSAT16::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (U|S)SAT16 encoding: rd|rm = 0xF.");

  if (imm != 15)
  THROW_WARNING("Invalid (U|S)SAT16 encoding: Bit's: [11..8] != 0xF.");

  rd = sat_q(rm & 0xFFFF, rn, false, true) & 0xFFFF;

  // NOTE: CPSR[CPSR_Q] = sat1 || sat2. Would have liked to pass a bool by
  // reference, but not sure how to in TRAP.
  if (CPSR[CPSR_Q])
  rd |= (sat_q((rm & 0xFFFF0000) >> 16, rn, false, false) & 0xFFFF) << 16;
  else
  rd |= (sat_q((rm & 0xFFFF0000) >> 16, rn, false, true) & 0xFFFF) << 16;
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::USSAT16::replicate() const throw() {
  return new USSAT16(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USSAT16::get_name() const throw() {
  return "USSAT16";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USSAT16::get_id() const throw() {
  return 25;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::USSAT16::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->u = (bitstring & 0x400000) >> 22;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USSAT16::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->u) {
    case 0: {
      oss << "S";
    break;}
    case 1: {
      oss << "U";
    break;}
  }
  oss << "SAT16";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->imm;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::QDADDSUB::QDADDSUB(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // QDADDSUB()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::QDADDSUB::~QDADDSUB() {

} // ~QDADDSUB()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::QDADDSUB::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (Q|QD)(ADD|SUB) encoding: rn|rd|rm = 0xF.");

  if (imm != 0)
  THROW_WARNING("Invalid (U|S|UH|SH|UQ|Q)ASX encoding: bit[11:8] != 0x0.");

  int operand = rn;
  if (d) operand = sat_q(2*rn, 32, true, true);

  // Add vs. subtract
  if (s) operand = -operand;

  // NOTE: CPSR[CPSR_Q] = sat1 || sat2; Would have liked to pass a bool by
  // reference, but not sure how to in TRAP.
  if (d && CPSR[CPSR_Q])
  rd = sat_q(rm + operand, 32, true, false);
  else
  rd = sat_q(rm + operand, 32, true, true);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::QDADDSUB::replicate() const throw() {
  return new QDADDSUB(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::QDADDSUB::get_name() const throw() {
  return "QDADDSUB";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::QDADDSUB::get_id() const throw() {
  return 26;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::QDADDSUB::set_params(const unsigned& bitstring)
throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->d = (bitstring & 0x400000) >> 22;
  this->s = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::QDADDSUB::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "Q";
  switch(this->d) {
    case 1: {
      oss << "D";
    break;}
  }
  switch(this->s) {
    case 0: {
      oss << "ADD";
    break;}
    case 1: {
      oss << "SUB";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::MUL::MUL(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRMulOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // MUL()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::MUL::~MUL() {

} // ~MUL()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MUL::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15) || (rn_bit == 15))
  THROW_EXCEPTION("Invalid MUL/MLA/MLS encoding: rd|rm|rn = 0xF.");

  if (a && (ra_bit == 15))
  THROW_EXCEPTION("Invalid MLA/MLS encoding: ra = 0xF.");

  if (!a && ra_bit)
  THROW_WARNING("Invalid MUL encoding: ra != 0x0.");

  unsigned latency = 0;

  result = (long long)((long long)rm * (long long)rn);

  // Accumulate vs. non-accumulate
  if (a) {
    // MLA/MLS
    latency++;
    // Add vs. subtract
    if (ss) {
      // MLS
      result = (long long)(((long long)ra - result) & 0x00000000FFFFFFFFLL);
    } else {
      // MLA
      result = (long long)(((long long)ra + result) & 0x00000000FFFFFFFFLL);
    }
  }
  rd = (int)(result & 0x00000000FFFFFFFFLL);

  // TODO: Compare stall cycles against Cortex A9 spec (rm: bits8-11).
  if ((rm & 0xFFFFFF00) == 0x0 || (rm & 0xFFFFFF00) == 0xFFFFFF00) {
    stall(1+latency);
  } else if ((rm & 0xFFFF0000) == 0x0 || (rm & 0xFFFF0000) == 0xFFFF0000) {
    stall(2+latency);
  } else if ((rm & 0xFF000000) == 0x0 || (rm & 0xFF000000) == 0xFF000000) {
    stall(3+latency);
  } else {
    stall(4+latency);
  }
  this->total_cycles += UpdatePSRMul(this->ss, this->s, this->l, this->result);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::MUL::replicate() const throw() {
  return new MUL(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MUL::get_name() const throw() {
  return "MUL";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MUL::get_id() const throw() {
  return 27;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::MUL::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf0000) >> 16;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf00) >> 8;
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf);
  this->rn.set_alias(REGS[this->rn_bit]);
  this->ra_bit = (bitstring & 0xf000) >> 12;
  this->ra.set_alias(REGS[this->ra_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->l = (bitstring & 0x800000) >> 23;
  this->ss = (bitstring & 0x400000) >> 22;
  this->a = (bitstring & 0x200000) >> 21;
  this->s = (bitstring & 0x100000) >> 20;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MUL::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->a) {
    case 0: {
      oss << "MUL";
    break;}
    case 1: {
      oss << "ML";
    break;}
  }
  switch(this->ss) {
    case 0: {
      oss << "A";
    break;}
    case 1: {
      oss << "S";
    break;}
  }
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", R";
  oss << std::dec << this->ra_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::SMMUL::SMMUL(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // SMMUL()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::SMMUL::~SMMUL() {

} // ~SMMUL()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SMMUL::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15) || (rn_bit == 15))
  THROW_EXCEPTION("Invalid SMMUL/SMMLA/SMMLS encoding: rd|rm|rn = 0xF.");

  if ((op1a == 3) && (ra_bit == 15))
  THROW_EXCEPTION("Invalid SMMLS encoding: ra = 0xF.");

  unsigned latency = 0;

  unsigned long long result = (long long)((long long)rm * (long long)rn);

  // Accumulate vs. non-accumulate
  if (ra_bit != 15) {
    // SMMLA/SMMLS
    latency++;
    // Add vs. subtract
    if (op1a == 3) {
      // SMMLS
      result = (long long)(((long long)ra << 32) - result);
    } else if (!op1a) {
      // SMMLA
      result = (long long)(((long long)ra << 32) + result);
    }
  }

  if (op1b) result += 0x0000000080000000LL;
  rd = (int)(((unsigned long)result >> 32) & 0x00000000FFFFFFFFLL);

  // TODO: Compare stall cycles against Cortex A9 spec (rm: bits8-11).
  if (!(rm & 0xFFFFFF00) || (rm & 0xFFFFFF00) == 0xFFFFFF00) {
    stall(1+latency);
  } else if (!(rm & 0xFFFF0000) || (rm & 0xFFFF0000) == 0xFFFF0000) {
    stall(2+latency);
  } else if (!(rm & 0xFF000000) || (rm & 0xFF000000) == 0xFF000000) {
    stall(3+latency);
  } else {
    stall(4+latency);
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::SMMUL::replicate() const throw() {
  return new SMMUL(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SMMUL::get_name() const throw() {
  return "SMMUL";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SMMUL::get_id() const throw() {
  return 28;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::SMMUL::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf0000) >> 16;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf00) >> 8;
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf);
  this->rn.set_alias(REGS[this->rn_bit]);
  this->ra_bit = (bitstring & 0xf000) >> 12;
  this->ra.set_alias(REGS[this->ra_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->op1a = (bitstring & 0xc0) >> 6;
  this->op1b = (bitstring & 0x20) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SMMUL::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->ra_bit) {
    default: {
      switch(this->op1a) {
        case 0: {
          oss << "SMMLA";
        break;}
        case 3: {
          oss << "SMMLS";
        break;}
      }
    break;}
    case 15: {
      oss << "SMMUL";
    break;}
  }
  switch(this->op1b) {
    case 1: {
      oss << "R";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", R";
  oss << std::dec << this->ra_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::MULL::MULL(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRMulOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // MULL()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::MULL::~MULL() {

} // ~MULL()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MULL::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (ra_bit == 15) || (rm_bit == 15) || (rn_bit == 15))
  THROW_EXCEPTION("Invalid UMULL/SMULL/UMLAL/SMLAL encoding: rd|ra|rm|rn = 0xF.");

  if (rd_bit == ra_bit)
  THROW_EXCEPTION("Invalid UMULL/SMULL/UMLAL/SMLAL encoding: rd = ra.");

  unsigned latency = 2;

  // Unsigned vs. signed
  if (ss) {
    // SMULL/SMLAL
    result = (long long)((long long)rm * (long long)rn);
    // Accumulate vs. non-accumulate
    if (a) {
      // SMLAL
      result += (long long)((((long long)rd << 32) & 0xFFFFFFFF00000000LL)
      + ((long long)ra & 0x00000000FFFFFFFFLL));
    }
    rd = (int)(((unsigned long)result >> 32) & 0x00000000FFFFFFFFLL);
    ra = (int)(result & 0x00000000FFFFFFFFLL);
  } else {
    // UMULL/UMLAL
    result = (unsigned long long)((unsigned long long)rm * (unsigned long
    long)rn);
    // Accumulate vs. non-accumulate
    if (a) {
      // UMLAL
      result += (unsigned long long)((((unsigned long long)rd << 32) & 0xFFFFFFFF00000000LL)
      + ((unsigned long long)ra & 0x00000000FFFFFFFFLL));
    }
    rd = (unsigned long)(((unsigned long)result >> 32) & 0x00000000FFFFFFFFLL);
    ra = (unsigned long)(result & 0x00000000FFFFFFFFLL);
  }

  // TODO: Compare stall cycles against Cortex A9 spec (rm: bits8-11).
  if (!(rm & 0xFFFFFF00) || (rm & 0xFFFFFF00) == 0xFFFFFF00) {
    stall(1+latency);
  } else if (!(rm & 0xFFFF0000) || (rm & 0xFFFF0000) == 0xFFFF0000) {
    stall(2+latency);
  } else if (!(rm & 0xFF000000) || (rm & 0xFF000000) == 0xFF000000) {
    stall(3+latency);
  } else {
    stall(4+latency);
  }
  this->total_cycles += UpdatePSRMul(this->ss, this->s, this->l, this->result);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::MULL::replicate() const throw() {
  return new MULL(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MULL::get_name() const throw() {
  return "MULL";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MULL::get_id() const throw() {
  return 29;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::MULL::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf0000) >> 16;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf00) >> 8;
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf);
  this->rn.set_alias(REGS[this->rn_bit]);
  this->ra_bit = (bitstring & 0xf000) >> 12;
  this->ra.set_alias(REGS[this->ra_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->l = (bitstring & 0x800000) >> 23;
  this->ss = (bitstring & 0x400000) >> 22;
  this->a = (bitstring & 0x200000) >> 21;
  this->s = (bitstring & 0x100000) >> 20;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MULL::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->ss) {
    case 0: {
      oss << "U";
    break;}
    case 1: {
      oss << "S";
    break;}
  }
  switch(this->a) {
    case 0: {
      oss << "MULL";
    break;}
    case 1: {
      oss << "MLAL";
    break;}
  }
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->ra_bit;
  oss << ", R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::UMAAL::UMAAL(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // UMAAL()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::UMAAL::~UMAAL() {

} // ~UMAAL()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::UMAAL::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (ra_bit == 15) || (rm_bit == 15) || (rn_bit == 15))
  THROW_EXCEPTION("Invalid UMAAL encoding: rd|ra|rm|rn = 0xF.");

  if (rd_bit == ra_bit)
  THROW_EXCEPTION("Invalid UMAAL encoding: rd = ra.");

  unsigned latency = 2;

  unsigned long long result
  = (unsigned long long)(((unsigned long long)rm * (unsigned long long)rn)
  + ((unsigned long long)rd & 0xFFFFFFFF00000000LL)
  + ((unsigned long long)ra & 0x00000000FFFFFFFFLL));

  rd = (unsigned)(((unsigned long)result >> 32) & 0x00000000FFFFFFFFLL);
  ra = (unsigned)(result & 0x00000000FFFFFFFFLL);

  // TODO: Compare stall cycles against Cortex A9 spec (rm: bits8-11).
  if (!(rm & 0xFFFFFF00) || (rm & 0xFFFFFF00) == 0xFFFFFF00) {
    stall(1+latency);
  } else if (!(rm & 0xFFFF0000) || (rm & 0xFFFF0000) == 0xFFFF0000) {
    stall(2+latency);
  } else if (!(rm & 0xFF000000) || (rm & 0xFF000000) == 0xFF000000) {
    stall(3+latency);
  } else {
    stall(4+latency);
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::UMAAL::replicate() const throw() {
  return new UMAAL(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::UMAAL::get_name() const throw() {
  return "UMAAL";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::UMAAL::get_id() const throw() {
  return 30;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::UMAAL::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf0000) >> 16;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf00) >> 8;
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf);
  this->rn.set_alias(REGS[this->rn_bit]);
  this->ra_bit = (bitstring & 0xf000) >> 12;
  this->ra.set_alias(REGS[this->ra_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::UMAAL::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "UMAAL";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->ra_bit;
  oss << ", R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::SMULBW::SMULBW(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // SMULBW()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::SMULBW::~SMULBW() {

} // ~SMULBW()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SMULBW::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15) || (rn_bit == 15))
  THROW_EXCEPTION("Invalid SMULxx/SMLAxx/SMLALxx/SMULWx/SMLAWx encoding: rd|rm|rn = 0xF.");

  if ((op0 != 3) && !((op0 == 1) && n) && (ra_bit == 15))
  THROW_EXCEPTION("Invalid SMLAxx/SMLALxx/SMLAWx encoding: ra = 0xF.");

  if ((op0 == 2) && (rd_bit == ra_bit))
  THROW_EXCEPTION("Invalid SMLALxx encoding: rd = ra.");

  if ((op0 == 3) && ra_bit)
  THROW_WARNING("Invalid SMULxx encoding: ra != 0x0.");

  if ((op0 == 1) && n && ra_bit)
  THROW_WARNING("Invalid SMULWx encoding: ra != 0x0.");

  unsigned latency = 1;
  unsigned long long result;

  // 16x16=>32-bit vs. 16x16=>64-bit vs. 16x32=>32-bit
  if ((op0 == 3) || !op0) {
    // SMULxx/SMLAxx
    result = (long long)((long long)((rn >> (16 * n)) & 0xFFFF)
    * (long long)((rm >> (16 * m)) & 0xFFFF)
    // SMLAxx; SMULxx: ra = 0
    + (long long)ra);

    rd = (int)(result & 0x00000000FFFFFFFFLL);

    // Update Q (cumulative saturation flag) if result saturates.
    // SMLAxx; SMULxx: result = rd
    CPSR[CPSR_Q] = (result != rd);
  } else if (op0 == 2) {
    // SMLALxx
    result = (long long)((long long)((rn >> (16 * n)) & 0xFFFF)
    * (long long)((rm >> (16 * m)) & 0xFFFF));
    result += (long long)((((long long)rd << 32) & 0xFFFFFFFF00000000LL)
    + ((long long)ra & 0x00000000FFFFFFFFLL));

    rd = (int)(((unsigned long)result >> 32) & 0x00000000FFFFFFFFLL);
    ra = (int)(result & 0x00000000FFFFFFFFLL);
  } else if (op0 == 1) {
    // SMULWx/SMLAWx
    result = (long long)((long long)rn
    * (long long)((rm >> (16 * m)) & 0xFFFF)
    // SMLAWx; SMULWx: ra = 0
    + ((long long)ra << 16));

    rd = (int)(((unsigned long)result >> 16) & 0x00000000FFFFFFFFLL);

    if (!n) {
      // SMLAWx
      // Update Q (cumulative saturation flag) if result saturates.
      CPSR[CPSR_Q] = ((result >> 16) != rd);
    }
  }

  // TODO: Compare stall cycles against Cortex A9 spec (rm: bits8-11).
  if (!(rm & 0xFFFFFF00) || (rm & 0xFFFFFF00) == 0xFFFFFF00) {
    stall(1+latency);
  } else if (!(rm & 0xFFFF0000) || (rm & 0xFFFF0000) == 0xFFFF0000) {
    stall(2+latency);
  } else if (!(rm & 0xFF000000) || (rm & 0xFF000000) == 0xFF000000) {
    stall(3+latency);
  } else {
    stall(4+latency);
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::SMULBW::replicate() const throw() {
  return new SMULBW(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SMULBW::get_name() const throw() {
  return "SMULBW";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SMULBW::get_id() const throw() {
  return 31;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::SMULBW::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf0000) >> 16;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf00) >> 8;
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf);
  this->rn.set_alias(REGS[this->rn_bit]);
  this->ra_bit = (bitstring & 0xf000) >> 12;
  this->ra.set_alias(REGS[this->ra_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->op0 = (bitstring & 0x600000) >> 21;
  this->m = (bitstring & 0x40) >> 6;
  this->n = (bitstring & 0x20) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SMULBW::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->op0) {
    case 0: {
      oss << "SMLA";
    break;}
    case 1: {
      oss << "SMULW";
    break;}
    case 2: {
      oss << "SMLAL";
    break;}
    case 3: {
      oss << "SMUL";
    break;}
  }
  switch(this->n) {
    case 0: {
      oss << "B";
    break;}
    case 1: {
      oss << "T";
    break;}
  }
  switch(this->m) {
    case 0: {
      oss << "B";
    break;}
    case 1: {
      oss << "T";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", R";
  oss << std::dec << this->ra_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::SMMULD::SMMULD(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // SMMULD()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::SMMULD::~SMMULD() {

} // ~SMMULD()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SMMULD::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15) || (rn_bit == 15))
  THROW_EXCEPTION("Invalid SMUAD/SMUSD/SMLAD/SMLSD/SMLALD/SMLSLD encoding: rd|rm|rn = 0xF.");

  if (l && (ra_bit == 15))
  THROW_EXCEPTION("Invalid SMLALD/SMLSLD encoding: ra = 0xF.");

  if (l && (rd_bit == ra_bit))
  THROW_EXCEPTION("Invalid SMLALD/SMLSLD encoding: rd = ra.");

  unsigned latency = 1;

  unsigned long long result = (long long)((long long)(rn & 0xFFFF)
  * (op1b? (long long)((rm >> 16) & 0xFFFF) : (long long)(rm & 0xFFFF)));

  // Add vs. subtract
  if (op1b) {
    // SMxSxD
    result += (long long)((long long)((rn >> 16) & 0xFFFF)
    * (op1b? (long long)(rm & 0xFFFF) : (long long)((rm >> 16) & 0xFFFF)));
  } else {
    // SMxAxD
    result -= (long long)((long long)((rn >> 16) & 0xFFFF)
    * (op1b? (long long)(rm & 0xFFFF) : (long long)((rm >> 16) & 0xFFFF)));
  }

  // Accumulate vs. non-accumulate
  if (ra_bit != 15) {
    // 32-bit vs. 64-bit
    if (l) {
      // SMLxLD
      result += (long long)((((long long)rd << 32) & 0xFFFFFFFF00000000LL)
      & ((long long)ra & 0x00000000FFFFFFFFLL));

      rd = (int)(((unsigned long)result >> 32) & 0x00000000FFFFFFFFLL);
      ra = (int)(result & 0x00000000FFFFFFFFLL);
    } else {
      // SMLxD
      result += (long long)ra;
      rd = (int)(result & 0x00000000FFFFFFFFLL);
    }
  } else
  // SMUxD
  rd = (int)(result & 0x00000000FFFFFFFFLL);

  if (!l) {
    // Update Q (cumulative saturation flag) if result saturates
    CPSR[CPSR_Q] = (result != rd);
  }

  // TODO: Compare stall cycles against Cortex A9 spec (rm: bits8-11).
  if (!(rm & 0xFFFFFF00) || (rm & 0xFFFFFF00) == 0xFFFFFF00) {
    stall(1+latency);
  } else if (!(rm & 0xFFFF0000) || (rm & 0xFFFF0000) == 0xFFFF0000) {
    stall(2+latency);
  } else if (!(rm & 0xFF000000) || (rm & 0xFF000000) == 0xFF000000) {
    stall(3+latency);
  } else {
    stall(4+latency);
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::SMMULD::replicate() const throw() {
  return new SMMULD(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SMMULD::get_name() const throw() {
  return "SMMULD";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SMMULD::get_id() const throw() {
  return 32;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::SMMULD::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf0000) >> 16;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf00) >> 8;
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf);
  this->rn.set_alias(REGS[this->rn_bit]);
  this->ra_bit = (bitstring & 0xf000) >> 12;
  this->ra.set_alias(REGS[this->ra_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->l = (bitstring & 0x400000) >> 22;
  this->op1a = (bitstring & 0xc0) >> 6;
  this->op1b = (bitstring & 0x20) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SMMULD::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->ra_bit) {
    default: {
      oss << "SML";
    break;}
    case 15: {
      oss << "SMU";
    break;}
  }
  switch(this->op1a) {
    case 0: {
      oss << "A";
    break;}
    case 1: {
      oss << "S";
    break;}
  }
  switch(this->l) {
    case 1: {
      oss << "L";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", R";
  oss << std::dec << this->ra_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::DIV::DIV(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // DIV()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::DIV::~DIV() {

} // ~DIV()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::DIV::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15) || (rn_bit == 15))
  THROW_EXCEPTION("Invalid UDIV/SDIV encoding: rd|rm|rn = 0xF.");

  if (ra_bit != 15)
  THROW_WARNING("Invalid UDIV/SDIV encoding: ra != 0xF.");

  int result;
  unsigned latency = 0;

  if (rm) {
    // Unsigned vs. signed
    if (s) {
      // SDIV
      result = (int)((int)rn / (int)rm);
      // Casting to int automatically truncates towards zero (not negative
      // infinity).
      rd = (int)result & 0xFFFFFFFF;
    } else {
      // UDIV
      result = (unsigned)((unsigned)rn / (unsigned)rm);
      rd = (unsigned)result & 0xFFFFFFFF;
    }
  } else {
    // Divide by zero.
    result = 0;
  }

  // TODO: Compare stall cycles against Cortex A9 spec (rm: bits8-11).
  if (!(rm & 0xFFFFFF00) || (rm & 0xFFFFFF00) == 0xFFFFFF00) {
    stall(1+latency);
  } else if (!(rm & 0xFFFF0000) || (rm & 0xFFFF0000) == 0xFFFF0000) {
    stall(2+latency);
  } else if (!(rm & 0xFF000000) || (rm & 0xFF000000) == 0xFF000000) {
    stall(3+latency);
  } else {
    stall(4+latency);
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::DIV::replicate() const throw() {
  return new DIV(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::DIV::get_name() const throw() {
  return "DIV";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::DIV::get_id() const throw() {
  return 33;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::DIV::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf0000) >> 16;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf00) >> 8;
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf);
  this->rn.set_alias(REGS[this->rn_bit]);
  this->ra_bit = (bitstring & 0xf000) >> 12;
  this->ra.set_alias(REGS[this->ra_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x200000) >> 21;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::DIV::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->s) {
    case 0: {
      oss << "UDIV";
    break;}
    case 1: {
      oss << "SDIV";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::AND_i::AND_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles) {

} // AND_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::AND_i::~AND_i() {

} // ~AND_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::AND_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  rd = result = rn & operand;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::AND_i::replicate() const throw() {
  return new AND_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::AND_i::get_name() const throw() {
  return "AND_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::AND_i::get_id() const throw() {
  return 34;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::AND_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::AND_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "AND";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::AND_r::AND_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles) {

} // AND_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::AND_r::~AND_r() {

} // ~AND_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::AND_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  rd = result = rn & operand;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::AND_r::replicate() const throw() {
  return new AND_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::AND_r::get_name() const throw() {
  return "AND_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::AND_r::get_id() const throw() {
  return 35;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::AND_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::AND_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "AND";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::AND_sr::AND_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // AND_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::AND_sr::~AND_sr() {

} // ~AND_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::AND_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid AND (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);

  rd = result = rn & operand;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::AND_sr::replicate() const throw() {
  return new AND_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::AND_sr::get_name() const throw() {
  return "AND_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::AND_sr::get_id() const throw() {
  return 36;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::AND_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::AND_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "AND";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::EOR_i::EOR_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles) {

} // EOR_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::EOR_i::~EOR_i() {

} // ~EOR_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::EOR_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  rd = result = rn ^ operand;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::EOR_i::replicate() const throw() {
  return new EOR_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::EOR_i::get_name() const throw() {
  return "EOR_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::EOR_i::get_id() const throw() {
  return 37;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::EOR_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::EOR_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "EOR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::EOR_r::EOR_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles) {

} // EOR_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::EOR_r::~EOR_r() {

} // ~EOR_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::EOR_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  rd = result = rn ^ operand;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::EOR_r::replicate() const throw() {
  return new EOR_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::EOR_r::get_name() const throw() {
  return "EOR_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::EOR_r::get_id() const throw() {
  return 38;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::EOR_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::EOR_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "EOR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::EOR_sr::EOR_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // EOR_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::EOR_sr::~EOR_sr() {

} // ~EOR_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::EOR_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid EOR (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);

  rd = result = rn ^ operand;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::EOR_sr::replicate() const throw() {
  return new EOR_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::EOR_sr::get_name() const throw() {
  return "EOR_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::EOR_sr::get_id() const throw() {
  return 39;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::EOR_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::EOR_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "EOR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::MVN_i::MVN_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // MVN_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::MVN_i::~MVN_i() {

} // ~MVN_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MVN_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rn_bit)
  THROW_WARNING("Invalid MVN (immediate) encoding: rn != 0x0.");
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  rd = result = ~operand;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::MVN_i::replicate() const throw() {
  return new MVN_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MVN_i::get_name() const throw() {
  return "MVN_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MVN_i::get_id() const throw() {
  return 40;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::MVN_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MVN_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "MVN";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::MVN_r::MVN_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // MVN_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::MVN_r::~MVN_r() {

} // ~MVN_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MVN_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rn_bit)
  THROW_WARNING("Invalid MVN (register) encoding: rn != 0x0.");
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  rd = result = ~operand;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::MVN_r::replicate() const throw() {
  return new MVN_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MVN_r::get_name() const throw() {
  return "MVN_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MVN_r::get_id() const throw() {
  return 41;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::MVN_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MVN_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "MVN";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::MVN_sr::MVN_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // MVN_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::MVN_sr::~MVN_sr() {

} // ~MVN_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MVN_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid MVN (shifted-register) encoding: rd|rs|rm = 0xF.");

  if (rn_bit)
  THROW_WARNING("Invalid MVN (shifted-register) encoding: rn != 0x0.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);

  rd = result = ~operand;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::MVN_sr::replicate() const throw() {
  return new MVN_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MVN_sr::get_name() const throw() {
  return "MVN_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MVN_sr::get_id() const throw() {
  return 42;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::MVN_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MVN_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "MVN";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::ORR_i::ORR_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles) {

} // ORR_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::ORR_i::~ORR_i() {

} // ~ORR_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ORR_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  rd = result = rn | operand;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::ORR_i::replicate() const throw() {
  return new ORR_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ORR_i::get_name() const throw() {
  return "ORR_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ORR_i::get_id() const throw() {
  return 43;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::ORR_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ORR_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "ORR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::ORR_r::ORR_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles) {

} // ORR_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::ORR_r::~ORR_r() {

} // ~ORR_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ORR_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  rd = result = rn | operand;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::ORR_r::replicate() const throw() {
  return new ORR_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ORR_r::get_name() const throw() {
  return "ORR_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ORR_r::get_id() const throw() {
  return 44;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::ORR_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ORR_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "ORR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::ORR_sr::ORR_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // ORR_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::ORR_sr::~ORR_sr() {

} // ~ORR_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ORR_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid ORR (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);

  rd = result = rn | operand;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::ORR_sr::replicate() const throw() {
  return new ORR_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ORR_sr::get_name() const throw() {
  return "ORR_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ORR_sr::get_id() const throw() {
  return 45;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::ORR_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ORR_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "ORR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::TEQ_i::TEQ_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // TEQ_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::TEQ_i::~TEQ_i() {

} // ~TEQ_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::TEQ_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit)
  THROW_WARNING("Invalid TEQ (immediate) encoding: rd != 0x0.");
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  unsigned result = rn ^ operand;
  update_psr_bit(result, carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::TEQ_i::replicate() const throw() {
  return new TEQ_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::TEQ_i::get_name() const throw() {
  return "TEQ_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::TEQ_i::get_id() const throw() {
  return 46;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::TEQ_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::TEQ_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "TEQ";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::TEQ_r::TEQ_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // TEQ_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::TEQ_r::~TEQ_r() {

} // ~TEQ_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::TEQ_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit)
  THROW_WARNING("Invalid TEQ (register) encoding: rd != 0x0.");
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  unsigned result = rn ^ operand;
  update_psr_bit(result, carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::TEQ_r::replicate() const throw() {
  return new TEQ_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::TEQ_r::get_name() const throw() {
  return "TEQ_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::TEQ_r::get_id() const throw() {
  return 47;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::TEQ_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::TEQ_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "TEQ";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::TEQ_sr::TEQ_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // TEQ_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::TEQ_sr::~TEQ_sr() {

} // ~TEQ_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::TEQ_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid TEQ (shifted-register) encoding: rn|rs|rm = 0xF.");

  if (rd_bit)
  THROW_WARNING("Invalid TEQ (shifted-register) encoding: rd != 0x0.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);

  unsigned result = rn ^ operand;
  update_psr_bit(result, carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::TEQ_sr::replicate() const throw() {
  return new TEQ_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::TEQ_sr::get_name() const throw() {
  return "TEQ_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::TEQ_sr::get_id() const throw() {
  return 48;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::TEQ_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::TEQ_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "TEQ";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::TST_i::TST_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // TST_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::TST_i::~TST_i() {

} // ~TST_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::TST_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit)
  THROW_WARNING("Invalid TST (immediate) encoding: rd != 0x0.");
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  unsigned result = rn & operand;
  update_psr_bit(result, carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::TST_i::replicate() const throw() {
  return new TST_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::TST_i::get_name() const throw() {
  return "TST_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::TST_i::get_id() const throw() {
  return 49;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::TST_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::TST_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "TST";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::TST_r::TST_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // TST_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::TST_r::~TST_r() {

} // ~TST_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::TST_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit)
  THROW_WARNING("Invalid TST (register) encoding: rd != 0x0.");
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  unsigned result = rn & operand;
  update_psr_bit(result, carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::TST_r::replicate() const throw() {
  return new TST_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::TST_r::get_name() const throw() {
  return "TST_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::TST_r::get_id() const throw() {
  return 50;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::TST_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::TST_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "TST";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::TST_sr::TST_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // TST_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::TST_sr::~TST_sr() {

} // ~TST_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::TST_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid TST (shifted-register) encoding: rn|rs|rm = 0xF.");

  if (rd_bit)
  THROW_WARNING("Invalid TST (shifted-register) encoding: rd != 0x0.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);

  unsigned result = rn & operand;
  update_psr_bit(result, carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::TST_sr::replicate() const throw() {
  return new TST_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::TST_sr::get_name() const throw() {
  return "TST_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::TST_sr::get_id() const throw() {
  return 51;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::TST_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::TST_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "TST";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::ASR_r::ASR_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // ASR_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::ASR_r::~ASR_r() {

} // ~ASR_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ASR_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rn_bit)
  THROW_WARNING("Invalid ASR (register) encoding: rn != 0x0.");
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::ASR_r::replicate() const throw() {
  return new ASR_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ASR_r::get_name() const throw() {
  return "ASR_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ASR_r::get_id() const throw() {
  return 52;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::ASR_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ASR_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "ASR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::ASR_sr::ASR_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // ASR_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::ASR_sr::~ASR_sr() {

} // ~ASR_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ASR_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid ASR (shifted-register) encoding: rn|rd|rm = 0xF.");

  if (rn_bit)
  THROW_WARNING("Invalid ASR (shifted-register) encoding: rn != 0x0.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::ASR_sr::replicate() const throw() {
  return new ASR_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ASR_sr::get_name() const throw() {
  return "ASR_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ASR_sr::get_id() const throw() {
  return 53;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::ASR_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ASR_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "ASR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LSR_r::LSR_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // LSR_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LSR_r::~LSR_r() {

} // ~LSR_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LSR_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rn_bit)
  THROW_WARNING("Invalid LSR (register) encoding: rn != 0x0.");
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LSR_r::replicate() const throw() {
  return new LSR_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LSR_r::get_name() const throw() {
  return "LSR_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LSR_r::get_id() const throw() {
  return 54;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LSR_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LSR_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LSR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LSR_sr::LSR_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // LSR_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LSR_sr::~LSR_sr() {

} // ~LSR_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LSR_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid LSR (shifted-register) encoding: rn|rd|rm = 0xF.");

  if (rn_bit)
  THROW_WARNING("Invalid LSR (shifted-register) encoding: rn != 0x0.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LSR_sr::replicate() const throw() {
  return new LSR_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LSR_sr::get_name() const throw() {
  return "LSR_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LSR_sr::get_id() const throw() {
  return 55;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LSR_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LSR_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LSR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LSL_r::LSL_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // LSL_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LSL_r::~LSL_r() {

} // ~LSL_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LSL_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rn_bit)
  THROW_WARNING("Invalid LSL (register) encoding: rn != 0x0.");
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LSL_r::replicate() const throw() {
  return new LSL_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LSL_r::get_name() const throw() {
  return "LSL_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LSL_r::get_id() const throw() {
  return 56;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LSL_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LSL_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LSL";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LSL_sr::LSL_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // LSL_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LSL_sr::~LSL_sr() {

} // ~LSL_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LSL_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid LSL (shifted-register) encoding: rn|rd|rm = 0xF.");

  if (rn_bit)
  THROW_WARNING("Invalid LSL (shifted-register) encoding: rn != 0x0.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LSL_sr::replicate() const throw() {
  return new LSL_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LSL_sr::get_name() const throw() {
  return "LSL_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LSL_sr::get_id() const throw() {
  return 57;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LSL_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LSL_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LSL";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::ROR_r::ROR_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // ROR_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::ROR_r::~ROR_r() {

} // ~ROR_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ROR_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rn_bit)
  THROW_WARNING("Invalid ROR/RRX (register) encoding: rn != 0x0.");
  carry = CPSR[CPSR_C];
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  rd = operand;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::ROR_r::replicate() const throw() {
  return new ROR_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ROR_r::get_name() const throw() {
  return "ROR_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ROR_r::get_id() const throw() {
  return 58;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::ROR_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ROR_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->shift_amm) {
    case 0: {
      oss << "RRX";
    break;}
    default: {
      oss << "ROR";
    break;}
  }
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::ROR_sr::ROR_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // ROR_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::ROR_sr::~ROR_sr() {

} // ~ROR_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ROR_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid ROR (shifted-register) encoding: rn|rd|rm = 0xF.");

  if (rn_bit)
  THROW_WARNING("Invalid ROR (shifted-register) encoding: rn != 0x0.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);

  rd = operand;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::ROR_sr::replicate() const throw() {
  return new ROR_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ROR_sr::get_name() const throw() {
  return "ROR_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ROR_sr::get_id() const throw() {
  return 59;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::ROR_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ROR_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "ROR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::BFCI::BFCI(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // BFCI()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::BFCI::~BFCI() {

} // ~BFCI()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BFCI::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit == 15)
  THROW_EXCEPTION("Invalid BFC/BFI encoding: rd = 0xF.");

  unsigned mask, result;
  if ((imm0 <= 31) && (imm1 >= 0) && (imm0 >= imm1)) {
    result = rd;
    if (rm == 0xF) {
      mask = (unsigned long)((unsigned long)0xFFFFFFFF << (32-imm0-1)) >>
      (32-imm0-1+imm1);
      result &= mask;
    } else {
      // Clear bitfield.
      //result = (unsigned long)(((unsigned long long)result << (32-imm0+imm1-1))
      // >> (32-imm0+imm1-1));
      mask = (unsigned long)((unsigned long)0xFFFFFFFF << (32-imm0+imm1-1)) >>
      (32-imm0+imm1-1);
      // Set bitfield.
      result = (result & !mask) | (rm & mask);
    }
    rd = result;
  }
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::BFCI::replicate() const throw() {
  return new BFCI(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BFCI::get_name() const throw() {
  return "BFCI";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BFCI::get_id() const throw() {
  return 60;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::BFCI::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->imm0 = (bitstring & 0x1f0000) >> 16;
  this->imm1 = (bitstring & 0xf80) >> 7;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BFCI::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "BF";
  switch(this->rm_bit) {
    default: {
      oss << "I";
    break;}
    case 15: {
      oss << "C";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->imm1;
  oss << ", ";
  oss << std::showbase << std::hex << this->imm0;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::BIC_i::BIC_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles) {

} // BIC_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::BIC_i::~BIC_i() {

} // ~BIC_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BIC_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  result = rn & ~operand;
  rd = result;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::BIC_i::replicate() const throw() {
  return new BIC_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BIC_i::get_name() const throw() {
  return "BIC_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BIC_i::get_id() const throw() {
  return 61;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::BIC_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BIC_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "BIC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::BIC_r::BIC_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles) {

} // BIC_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::BIC_r::~BIC_r() {

} // ~BIC_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BIC_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  result = rn & ~operand;
  rd = result;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::BIC_r::replicate() const throw() {
  return new BIC_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BIC_r::get_name() const throw() {
  return "BIC_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BIC_r::get_id() const throw() {
  return 62;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::BIC_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BIC_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "BIC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::BIC_sr::BIC_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // BIC_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::BIC_sr::~BIC_sr() {

} // ~BIC_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BIC_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid BIC encoding: rn|rd|rs|rm = 0xF.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);

  result = rn & ~operand;
  rd = result;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::BIC_sr::replicate() const throw() {
  return new BIC_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BIC_sr::get_name() const throw() {
  return "BIC_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BIC_sr::get_id() const throw() {
  return 63;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::BIC_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BIC_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "BIC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::CLZ::CLZ(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // CLZ()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::CLZ::~CLZ() {

} // ~CLZ()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CLZ::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid CLZ encoding: rd|rm = 0xF.");

  if ((rn_bit != 15) || (rs_bit != 15))
  THROW_WARNING("Invalid CLZ encoding: rn|rs != 0xF.");

  // NOTE: Binary search algorithm for counting leading zeros taken from Henry
  // S. Warren, "Hacker's Delight, " 2003.
  unsigned input = rm,
  result = 32;
  if (input) {
    result = 0;
    if (!(input & 0xFFFF0000)) {
      result += 16;
      input <<= 16;
    }
    if (!(input & 0xFF000000)) {
      result += 8;
      input <<= 8;
    }
    if (!(input & 0xF0000000)) {
      result += 4;
      input <<= 4;
    }
    if (!(input & 0xC0000000)) {
      result += 2;
      input <<= 2;
    }
    if (!(input & 0x80000000)) {
      result += 1;
      input <<= 1;
    }
  }
  rd = result;
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::CLZ::replicate() const throw() {
  return new CLZ(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CLZ::get_name() const throw() {
  return "CLZ";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CLZ::get_id() const throw() {
  return 64;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::CLZ::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CLZ::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "CLZ";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::PKH::PKH(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // PKH()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::PKH::~PKH() {

} // ~PKH()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::PKH::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid PKH encoding: rn|rd|rm = 0xF.");

  shift_op = (op1a & 0x1) << 1;
  shift_amm = (imm << 1) | ((op1a >> 1) & 0x2);
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  if (shift_op) {
    rd = (rn & 0xFFFF0000) | (operand & 0x0000FFFF);
  } else {
    rd = (operand & 0xFFFF0000) | (rn & 0x0000FFFF);
  }
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::PKH::replicate() const throw() {
  return new PKH(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::PKH::get_name() const throw() {
  return "PKH";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::PKH::get_id() const throw() {
  return 65;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::PKH::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->imm = (bitstring & 0xf00) >> 8;
  this->op1a = (bitstring & 0xc0) >> 6;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::PKH::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "PKH";
  switch(this->op1a) {
    case 0: {
      oss << "BT";
    break;}
    case 1: {
      oss << "TB";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->op1a) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "ASR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->imm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::RBIT::RBIT(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // RBIT()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::RBIT::~RBIT() {

} // ~RBIT()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::RBIT::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid RBIT encoding: rd|rm = 0xF.");

  if ((rn_bit != 15) || (rs_bit != 15))
  THROW_WARNING("Invalid RBIT encoding: rn|rs != 0xF.");

  unsigned result = rm;
  result = (result << 16) | (result >> 16)
  | ((result & 0x00FF00FF) << 8) | ((result & 0xFF00FF00) >> 8)
  | ((result & 0x0F0F0F0F) << 4) | ((result & 0xF0F0F0F0) >> 4)
  | ((result & 0x33333333) << 2) | ((result & 0xCCCCCCCC) >> 2)
  | ((result & 0x55555555) << 1) | ((result & 0xAAAAAAAA) >> 1);
  rd = result;
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::RBIT::replicate() const throw() {
  return new RBIT(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::RBIT::get_name() const throw() {
  return "RBIT";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::RBIT::get_id() const throw() {
  return 66;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::RBIT::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::RBIT::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "RBIT";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::REV::REV(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // REV()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::REV::~REV() {

} // ~REV()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::REV::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid REV encoding: rd|rm = 0xF.");

  if ((rn_bit != 15) || (rs_bit != 15))
  THROW_WARNING("Invalid REV encoding: rn|rs != 0xF.");

  unsigned result = rm;
  result = (result << 16) | (result >> 16)
  | ((result & 0x00FF00FF) << 8) | ((result & 0xFF00FF00) >> 8);
  rd = result;
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::REV::replicate() const throw() {
  return new REV(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::REV::get_name() const throw() {
  return "REV";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::REV::get_id() const throw() {
  return 67;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::REV::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::REV::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "REV";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::REV16::REV16(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // REV16()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::REV16::~REV16() {

} // ~REV16()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::REV16::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid REV16 encoding: rd|rm = 0xF.");

  if ((rn_bit != 15) || (rs_bit != 15))
  THROW_WARNING("Invalid REV16 encoding: rn|rs != 0xF.");

  unsigned result = rm;
  result = ((result & 0x00FF00FF) << 8) | ((result & 0xFF00FF00) >> 8);
  rd = result;
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::REV16::replicate() const throw() {
  return new REV16(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::REV16::get_name() const throw() {
  return "REV16";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::REV16::get_id() const throw() {
  return 68;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::REV16::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::REV16::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "REV16";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::REVSH::REVSH(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // REVSH()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::REVSH::~REVSH() {

} // ~REVSH()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::REVSH::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid REVSH encoding: rd|rm = 0xF.");

  if ((rn_bit != 15) || (rs_bit != 15))
  THROW_WARNING("Invalid REVSH encoding: rn|rs != 0xF.");

  unsigned result = rm;
  result = ((result & 0x000000FF) << 8) | ((result & 0x0000FF00) >> 8);
  if (result & 0x00008000) {
    result |= 0xFFFF0000;
  }
  rd = result;
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::REVSH::replicate() const throw() {
  return new REVSH(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::REVSH::get_name() const throw() {
  return "REVSH";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::REVSH::get_id() const throw() {
  return 69;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::REVSH::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::REVSH::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "REVSH";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::USBFX::USBFX(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // USBFX()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::USBFX::~USBFX() {

} // ~USBFX()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USBFX::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid UBFX/SBFX encoding: rd|rm = 0xF.");

  unsigned msb = imm1 + imm0;
  if (msb <= 31) {
    unsigned mask = ((unsigned)0xFFFFFFFF >> (32 - imm0 - 1)) << imm1;
    int result = ((unsigned)rm & mask) >> imm1;
    // Unsigned vs. signed
    if (u) rd = result;
    else rd = sign_extend(result, imm0+1);
  }
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::USBFX::replicate() const throw() {
  return new USBFX(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USBFX::get_name() const throw() {
  return "USBFX";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::USBFX::get_id() const throw() {
  return 70;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::USBFX::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->u = (bitstring & 0x400000) >> 22;
  this->imm0 = (bitstring & 0x1f0000) >> 16;
  this->imm1 = (bitstring & 0xf80) >> 7;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::USBFX::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  switch(this->u) {
    case 0: {
      oss << "S";
    break;}
    case 1: {
      oss << "U";
    break;}
  }
  oss << "BFX";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->imm1;
  oss << ", ";
  oss << std::showbase << std::hex << this->imm0;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::SEL::SEL(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // SEL()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::SEL::~SEL() {

} // ~SEL()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SEL::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid SEL encoding: rn|rd|rm = 0xF.");

  if (rs_bit != 15)
  THROW_WARNING("Invalid SEL encoding: rs != 0xF.");

  unsigned result;
  for (unsigned i = 0; i < 4; ++i) {
    if (CPSR[CPSR_GE] & (0x1 << i)) {
      result |= rn & (0x000000FF << (i << 3));
    } else {
      result |= rm & (0x000000FF << (i << 3));
    }
  }
  rd = result;
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::SEL::replicate() const throw() {
  return new SEL(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SEL::get_name() const throw() {
  return "SEL";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SEL::get_id() const throw() {
  return 71;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::SEL::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SEL::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "SEL";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::CMN_i::CMN_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // CMN_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::CMN_i::~CMN_i() {

} // ~CMN_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CMN_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit)
  THROW_WARNING("Invalid CMN encoding: rd != 0x0.");
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  //carry = 0
  AddWithCarry(rn, operand, 0);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::CMN_i::replicate() const throw() {
  return new CMN_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CMN_i::get_name() const throw() {
  return "CMN_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CMN_i::get_id() const throw() {
  return 72;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::CMN_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CMN_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "CMN";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::CMN_r::CMN_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // CMN_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::CMN_r::~CMN_r() {

} // ~CMN_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CMN_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit)
  THROW_WARNING("Invalid CMN encoding: rd != 0x0.");
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  //carry = 0
  AddWithCarry(rn, operand, 0);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::CMN_r::replicate() const throw() {
  return new CMN_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CMN_r::get_name() const throw() {
  return "CMN_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CMN_r::get_id() const throw() {
  return 73;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::CMN_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CMN_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "CMN";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::CMN_sr::CMN_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // CMN_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::CMN_sr::~CMN_sr() {

} // ~CMN_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CMN_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid CMN encoding: rn|rs|rm = 0xF.");

  if (rd_bit)
  THROW_WARNING("Invalid CMN encoding: rd != 0x0.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);

  //carry = 0
  AddWithCarry(rn, operand, 0);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::CMN_sr::replicate() const throw() {
  return new CMN_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CMN_sr::get_name() const throw() {
  return "CMN_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CMN_sr::get_id() const throw() {
  return 74;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::CMN_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CMN_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "CMN";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::CMP_i::CMP_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // CMP_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::CMP_i::~CMP_i() {

} // ~CMP_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CMP_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit)
  THROW_WARNING("Invalid CMP encoding: rd != 0x0.");
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  carry = 0;
  update_psr_sub(rn, operand, 0);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::CMP_i::replicate() const throw() {
  return new CMP_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CMP_i::get_name() const throw() {
  return "CMP_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CMP_i::get_id() const throw() {
  return 75;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::CMP_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CMP_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "CMP";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::CMP_r::CMP_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // CMP_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::CMP_r::~CMP_r() {

} // ~CMP_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CMP_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit)
  THROW_WARNING("Invalid CMP encoding: rd != 0x0.");
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  carry = 0;
  update_psr_sub(rn, operand, 0);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::CMP_r::replicate() const throw() {
  return new CMP_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CMP_r::get_name() const throw() {
  return "CMP_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CMP_r::get_id() const throw() {
  return 76;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::CMP_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CMP_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "CMP";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::CMP_sr::CMP_sr(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeRegShiftOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // CMP_sr()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::CMP_sr::~CMP_sr() {

} // ~CMP_sr()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CMP_sr::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid CMP encoding: rn|rs|rm = 0xF.");

  if (rd_bit)
  THROW_WARNING("Invalid CMP encoding: rd != 0x0.");
  this->total_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs, this->rs_bit,
  this->shift_op, this->operand, this->carry);

  //carry = 0
  update_psr_sub(rn, operand, 0);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::CMP_sr::replicate() const throw() {
  return new CMP_sr(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CMP_sr::get_name() const throw() {
  return "CMP_sr";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CMP_sr::get_id() const throw() {
  return 77;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::CMP_sr::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CMP_sr::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "CMP";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDR_i::LDR_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // LDR_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDR_i::~LDR_i() {

} // ~LDR_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDR_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  //if ((rn_bit != 15) && !p && u && !w && (rn_bit == 13) && (imm == 0x004))
  // POP is caught by the decoder as a subinstruction and never redirects here.

  if ((rn_bit != 15) && (!p || w) && (rn_bit == rd_bit))
  THROW_EXCEPTION("Invalid LDR/LDRT (immediate) encoding: rn = rd and writeback.");

  if ((rn_bit != 15) && (!p && w) && ((rn_bit == 15) || (rd_bit == 15)))
  THROW_EXCEPTION("Invalid LDRT (immediate) encoding: rn|rd = 0xF.");

  if ((rn_bit == 15) && (!p || w))
  THROW_WARNING("Invalid LDR (literal) encoding: p != 1 or w != 0.");

  operand = imm;
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15)
  address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);

  if (rd_bit == 15) {
    // Load word-aligned memory in PC.
    PC = data_memory.read_word(address) & 0xFFFFFFFC;
    stall(4);
    flush();
  } else {
    rd = data_memory.read_word(address);
    stall(2);
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDR_i::replicate() const throw() {
  return new LDR_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDR_i::get_name() const throw() {
  return "LDR_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDR_i::get_id() const throw() {
  return 78;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDR_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xfff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDR_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDR";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDR_r::LDR_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // LDR_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDR_r::~LDR_r() {

} // ~LDR_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDR_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid LDR/LDRT (register) encoding: (rn = 0xF or rn = rd) and writeback.");

  if ((!p && w) && (rd_bit == 15))
  THROW_EXCEPTION("Invalid LDRT (register) encoding: rd = 0xF.");

  if (rm_bit == 15)
  THROW_EXCEPTION("Invalid LDR/LDRT (register) encoding: rm = 0xF.");
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15)
  address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);

  if (rd_bit == 15) {
    // Load word-aligned memory in PC.
    PC = data_memory.read_word(address) & 0xFFFFFFFC;
    stall(4);
    flush();
  } else {
    rd = data_memory.read_word(address);
    stall(2);
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDR_r::replicate() const throw() {
  return new LDR_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDR_r::get_name() const throw() {
  return "LDR_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDR_r::get_id() const throw() {
  return 79;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDR_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDR_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDR";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->shift_amm;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDREX::LDREX(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // LDREX()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDREX::~LDREX() {

} // ~LDREX()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDREX::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15))
  THROW_EXCEPTION("Invalid LDREX encoding: rn|rd = 0xF.");

  if ((rs_bit != 15) || (rm_bit != 15))
  THROW_WARNING("Invalid LDREX encoding: rs|rm != 0xF.");

  rd = data_memory.read_word(rn);
  stall(2);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDREX::replicate() const throw() {
  return new LDREX(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDREX::get_name() const throw() {
  return "LDREX";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDREX::get_id() const throw() {
  return 80;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDREX::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDREX::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDREX";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDRB_i::LDRB_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // LDRB_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDRB_i::~LDRB_i() {

} // ~LDRB_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRB_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit != 15) && (!p || w) && (rn_bit == rd_bit))
  THROW_EXCEPTION("Invalid LDRB/LDRBT (immediate) encoding: rn = rd and writeback.");

  if ((rn_bit != 15) && (!p && w) && (rn_bit == 15))
  THROW_EXCEPTION("Invalid LDRBT (immediate) encoding: rn = 0xF.");

  if (rd_bit == 15)
  THROW_EXCEPTION("Invalid LDRB/LDRBT (immediate/literal) encoding: rd = 0xF.");

  if ((rn_bit == 15) && (!p || w))
  THROW_WARNING("Invalid LDRB (literal) encoding: p != 1 or w != 0.");

  operand = imm;
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15)
  address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);

  rd = data_memory.read_byte(address);
  stall(2);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDRB_i::replicate() const throw() {
  return new LDRB_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRB_i::get_name() const throw() {
  return "LDRB_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRB_i::get_id() const throw() {
  return 81;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDRB_i::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xfff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRB_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDRB_r::LDRB_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // LDRB_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDRB_r::~LDRB_r() {

} // ~LDRB_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRB_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid LDRB/LDRBT (register) encoding: (rn = 0xF or rn = rd) and writeback.");

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid LDRB/LDRBT (register) encoding: rd|rm = 0xF.");
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15)
  address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);

  rd = data_memory.read_byte(address);
  stall(2);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDRB_r::replicate() const throw() {
  return new LDRB_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRB_r::get_name() const throw() {
  return "LDRB_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRB_r::get_id() const throw() {
  return 82;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDRB_r::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRB_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->shift_amm;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDREXB::LDREXB(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // LDREXB()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDREXB::~LDREXB() {

} // ~LDREXB()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDREXB::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15))
  THROW_EXCEPTION("Invalid LDREXB encoding: rn|rd = 0xF.");

  if ((rs_bit != 15) || (rm_bit != 15))
  THROW_WARNING("Invalid LDREXB encoding: rs|rm != 0xF.");

  rd = data_memory.read_byte(rn);
  stall(2);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDREXB::replicate() const throw() {
  return new LDREXB(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDREXB::get_name() const throw() {
  return "LDREXB";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDREXB::get_id() const throw() {
  return 83;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDREXB::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDREXB::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDREXB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDRSB_i::LDRSB_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // LDRSB_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDRSB_i::~LDRSB_i() {

} // ~LDRSB_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRSB_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit != 15) && (!p || w) && (rn_bit == rd_bit))
  THROW_EXCEPTION("Invalid LDRSB/LDRSBT (immediate) encoding: rn = rd and writeback.");

  if ((rn_bit != 15) && (!p && w) && (rn_bit == 15))
  THROW_EXCEPTION("Invalid LDRSBT (immediate) encoding: rn = 0xF.");

  if (rd_bit == 15)
  THROW_EXCEPTION("Invalid LDRSB/LDRSBT (immediate/literal) encoding: rd = 0xF.");

  if ((rn_bit == 15) && (!p || w))
  THROW_WARNING("Invalid LDRSB (literal) encoding: p != 1 or w != 0.");

  operand = (imm << 4) | rm_bit;
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15) {
    operand = (imm << 4) | rm_bit;
    address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);
  }

  rd = (int)sign_extend(data_memory.read_byte(address), 8);
  stall(2);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDRSB_i::replicate() const throw() {
  return new LDRSB_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRSB_i::get_name() const throw() {
  return "LDRSB_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRSB_i::get_id() const throw() {
  return 84;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDRSB_i::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRSB_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRSB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDRSB_r::LDRSB_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // LDRSB_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDRSB_r::~LDRSB_r() {

} // ~LDRSB_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRSB_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid LDRSB/LDRSBT (register) encoding: (rn = 0xF or rn = rd) and writeback.");

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid LDRSB/LDRSBT (register) encoding: rd|rm = 0xF.");

  if (imm)
  THROW_WARNING("Invalid LDRSH/LDRSHT (register) encoding: rs != 0x0.");

  operand = rm;
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15) {
    operand = (imm << 4) | rm_bit;
    address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);
  }

  rd = (int)sign_extend(data_memory.read_byte(address), 8);
  stall(2);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDRSB_r::replicate() const throw() {
  return new LDRSB_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRSB_r::get_name() const throw() {
  return "LDRSB_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRSB_r::get_id() const throw() {
  return 85;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDRSB_r::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRSB_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRSB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDRH_i::LDRH_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // LDRH_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDRH_i::~LDRH_i() {

} // ~LDRH_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRH_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit != 15) && (!p || w) && (rn_bit == rd_bit))
  THROW_EXCEPTION("Invalid LDRH/LDRHT (immediate) encoding: rn = rd and writeback.");

  if ((rn_bit != 15) && (!p && w) && (rn_bit == 15))
  THROW_EXCEPTION("Invalid LDRHT (immediate) encoding: rn = 0xF.");

  if (rd_bit == 15)
  THROW_EXCEPTION("Invalid LDRH/LDRHT (immediate/literal) encoding: rd = 0xF.");

  if ((rn_bit == 15) && (p == w))
  THROW_EXCEPTION("Invalid LDRH (literal) encoding: p = w.");

  operand = (imm << 4) | rm_bit;
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15) {
    operand = (imm << 4) | rm_bit;
    address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);
  }

  rd = data_memory.read_half(address);
  stall(2);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDRH_i::replicate() const throw() {
  return new LDRH_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRH_i::get_name() const throw() {
  return "LDRH_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRH_i::get_id() const throw() {
  return 86;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDRH_i::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRH_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRH";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDRH_r::LDRH_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // LDRH_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDRH_r::~LDRH_r() {

} // ~LDRH_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRH_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid LDRH/LDRHT (register) encoding: (rn = 0xF or rn = rd) and writeback.");

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid LDRH/LDRHT (register) encoding: rd|rm = 0xF.");

  if (imm)
  THROW_WARNING("Invalid LDRSH/LDRSHT (register) encoding: rs != 0x0.");

  operand = rm;
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15) {
    operand = (imm << 4) | rm_bit;
    address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);
  }

  rd = data_memory.read_half(address);
  stall(2);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDRH_r::replicate() const throw() {
  return new LDRH_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRH_r::get_name() const throw() {
  return "LDRH_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRH_r::get_id() const throw() {
  return 87;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDRH_r::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRH_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRH";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDREXH::LDREXH(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // LDREXH()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDREXH::~LDREXH() {

} // ~LDREXH()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDREXH::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15))
  THROW_EXCEPTION("Invalid LDREXH encoding: rn|rd = 0xF.");

  if ((rs_bit != 15) || (rm_bit != 15))
  THROW_WARNING("Invalid LDREXH encoding: rs|rm != 0xF.");

  rd = data_memory.read_half(rn);
  stall(2);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDREXH::replicate() const throw() {
  return new LDREXH(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDREXH::get_name() const throw() {
  return "LDREXH";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDREXH::get_id() const throw() {
  return 88;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDREXH::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDREXH::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDREXH";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDRSH_i::LDRSH_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // LDRSH_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDRSH_i::~LDRSH_i() {

} // ~LDRSH_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRSH_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit != 15) && (!p || w) && (rn_bit == rd_bit))
  THROW_EXCEPTION("Invalid LDRSH/LDRSHT (immediate) encoding: rn = rd and writeback.");

  if ((rn_bit != 15) && (!p && w) && (rn_bit == 15))
  THROW_EXCEPTION("Invalid LDRSHT (immediate) encoding: rn = 0xF.");

  if (rd_bit == 15)
  THROW_EXCEPTION("Invalid LDRSH/LDRSHT (immediate/literal) encoding: rd = 0xF.");

  if ((rn_bit == 15) && (!p || w))
  THROW_WARNING("Invalid LDRSH (literal) encoding: p != 1 or w != 0.");

  operand = (imm << 4) | rm_bit;
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15) {
    operand = (imm << 4) | rm_bit;
    address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);
  }

  rd = (int)sign_extend(data_memory.read_half(address), 16);
  stall(2);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDRSH_i::replicate() const throw() {
  return new LDRSH_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRSH_i::get_name() const throw() {
  return "LDRSH_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRSH_i::get_id() const throw() {
  return 89;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDRSH_i::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRSH_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRSH";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDRSH_r::LDRSH_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // LDRSH_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDRSH_r::~LDRSH_r() {

} // ~LDRSH_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRSH_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid LDRSH/LDRSHT (register) encoding: (rn = 0xF or rn = rd) and writeback.");

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid LDRSH/LDRSHT (register) encoding: rd|rm = 0xF.");

  if (imm)
  THROW_WARNING("Invalid LDRSH/LDRSHT (register) encoding: rs != 0x0.");

  operand = rm;
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15) {
    operand = (imm << 4) | rm_bit;
    address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);
  }

  rd = (int)sign_extend(data_memory.read_half(address), 16);
  stall(2);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDRSH_r::replicate() const throw() {
  return new LDRSH_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRSH_r::get_name() const throw() {
  return "LDRSH_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRSH_r::get_id() const throw() {
  return 90;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDRSH_r::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRSH_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRSH";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDRD_i::LDRD_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // LDRD_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDRD_i::~LDRD_i() {

} // ~LDRD_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRD_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit != 15) && (!p || w) && ((rn_bit == rd_bit) || (rn_bit == rd_bit+1)))
  THROW_EXCEPTION("Invalid LDRD (immediate) encoding: rn = rd|rd+1 and writeback.");

  if ((rn_bit != 15) && !p && w)
  THROW_EXCEPTION("Invalid LDRD (immediate) encoding: p = 0 and w = 1. There is no LDRDT instruction.");

  if (rd_bit == 14)
  THROW_EXCEPTION("Invalid LDRD (immediate/literal) encoding: rd = 0xE.");

  if (rd_bit & 0x1)
  THROW_EXCEPTION("Invalid LDRD (immediate/literal) encoding: rd[0] = 1.");

  if ((rn_bit == 15) && (!p || w))
  THROW_WARNING("Invalid LDRD (literal) encoding: p != 1 or w != 0.");

  operand = (imm << 4) | rm_bit;
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15) {
    operand = (imm << 4) | rm_bit;
    address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);
  }

  rd = data_memory.read_word(address);
  REGS[rd_bit+1] = data_memory.read_word(address+4);
  stall(2);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDRD_i::replicate() const throw() {
  return new LDRD_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRD_i::get_name() const throw() {
  return "LDRD_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRD_i::get_id() const throw() {
  return 91;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDRD_i::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRD_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRD";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDRD_r::LDRD_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // LDRD_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDRD_r::~LDRD_r() {

} // ~LDRD_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRD_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit) || (rn_bit == rd_bit+1)))
  THROW_EXCEPTION("Invalid LDRD (register) encoding: (rn = 0xF or rn = rd|rd+1) and writeback.");

  if (!p && w)
  THROW_EXCEPTION("Invalid LDRD (register) encoding: p = 0 and w = 1. There is no LDRDT instruction.");

  if ((rd_bit == 14) || (rm_bit == 15) || (rm_bit == rd_bit) || (rm_bit ==
  rd_bit+1))
  THROW_EXCEPTION("Invalid LDRD (register) encoding: rd = 0xE or rm = 0xF or rm = rd|rd+1.");

  if (rd_bit & 0x1)
  THROW_EXCEPTION("Invalid LDRD (register) encoding: rd[0] = 1.");

  if (imm)
  THROW_WARNING("Invalid LDRD (register) encoding: rs != 0x0.");

  operand = rm;
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15) {
    operand = (imm << 4) | rm_bit;
    address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);
  }

  rd = data_memory.read_word(address);
  REGS[rd_bit+1] = data_memory.read_word(address+4);
  stall(2);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDRD_r::replicate() const throw() {
  return new LDRD_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRD_r::get_name() const throw() {
  return "LDRD_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDRD_r::get_id() const throw() {
  return 92;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDRD_r::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDRD_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRD";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDREXD::LDREXD(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // LDREXD()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDREXD::~LDREXD() {

} // ~LDREXD()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDREXD::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 14) || (rd_bit & 0x1))
  THROW_EXCEPTION("Invalid LDREXD encoding: rn = 0xF or rd = 0xE or rd[0] = 1.");

  if ((rs_bit != 15) || (rm_bit != 15))
  THROW_WARNING("Invalid LDREXD encoding: rs|rm != 0xF.");

  rd = data_memory.read_word(rn);
  REGS[rd_bit+1] = data_memory.read_word(rn+4);
  stall(2);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDREXD::replicate() const throw() {
  return new LDREXD(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDREXD::get_name() const throw() {
  return "LDREXD";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDREXD::get_id() const throw() {
  return 93;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDREXD::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDREXD::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDREXD";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STR_i::STR_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // STR_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STR_i::~STR_i() {

} // ~STR_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STR_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  //if (p && !u && w && (rn_bit == 13) && (imm == 0x004))
  // PUSH is caught by the decoder as a subinstruction and never redirects here.

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid STR/STRT (immediate) encoding: (rn = 0xF or rn = rd) and writeback.");

  operand = imm;
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  data_memory.write_word(address, rd);
  stall(1);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STR_i::replicate() const throw() {
  return new STR_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STR_i::get_name() const throw() {
  return "STR_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STR_i::get_id() const throw() {
  return 94;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STR_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xfff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STR_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STR";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STR_r::STR_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // STR_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STR_r::~STR_r() {

} // ~STR_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STR_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid STR/STRT (register) encoding: (rn = 0xF or rn = rd) and writeback.");

  if (rm_bit == 15)
  THROW_EXCEPTION("Invalid STR/STRT (register) encoding: rm = 0xF.");
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  data_memory.write_word(address, rd);
  stall(1);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STR_r::replicate() const throw() {
  return new STR_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STR_r::get_name() const throw() {
  return "STR_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STR_r::get_id() const throw() {
  return 95;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STR_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STR_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STR";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->shift_amm;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STREX::STREX(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // STREX()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STREX::~STREX() {

} // ~STREX()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STREX::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid STREX encoding: rn|rd|rm = 0xF.");

  if ((rn_bit == rd_bit) || (rd_bit == rm_bit))
  THROW_EXCEPTION("Invalid STREX encoding: rn|rm = rd.");

  if (rs_bit != 15)
  THROW_WARNING("Invalid STREX encoding: rs != 0xF.");

  data_memory.write_word(rn, rd);
  stall(1);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STREX::replicate() const throw() {
  return new STREX(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STREX::get_name() const throw() {
  return "STREX";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STREX::get_id() const throw() {
  return 96;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STREX::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STREX::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STREX";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STRB_i::STRB_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // STRB_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STRB_i::~STRB_i() {

} // ~STRB_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STRB_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid STRB/STRBT (immediate) encoding: (rn = 0xF or rn = rd) and writeback.");

  if (rd_bit == 15)
  THROW_EXCEPTION("Invalid STRB/STRBT (immediate) encoding: rd = 0xF.");

  operand = imm;
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  data_memory.write_byte(address, (unsigned char)(rd & 0x000000FF));
  stall(1);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STRB_i::replicate() const throw() {
  return new STRB_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STRB_i::get_name() const throw() {
  return "STRB_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STRB_i::get_id() const throw() {
  return 97;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STRB_i::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xfff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STRB_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STRB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STRB_r::STRB_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  DecodeImmShiftOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // STRB_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STRB_r::~STRB_r() {

} // ~STRB_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STRB_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid STRB/STRBT (register) encoding: (rn = 0xF or rn = rd) and writeback.");

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid STRB/STRBT (register) encoding: rd|rm = 0xF.");
  this->total_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  data_memory.write_byte(address, (unsigned char)(rd & 0x000000FF));
  stall(1);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STRB_r::replicate() const throw() {
  return new STRB_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STRB_r::get_name() const throw() {
  return "STRB_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STRB_r::get_id() const throw() {
  return 98;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STRB_r::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STRB_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STRB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->shift_amm;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STREXB::STREXB(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // STREXB()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STREXB::~STREXB() {

} // ~STREXB()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STREXB::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid STREXB encoding: rn|rd|rm = 0xF.");

  if ((rn_bit == rd_bit) || (rd_bit == rm_bit))
  THROW_EXCEPTION("Invalid STREXB encoding: rn|rm = rd.");

  if (rs_bit != 15)
  THROW_WARNING("Invalid STREXB encoding: rs != 0xF.");

  data_memory.write_byte(rn, (unsigned char)(rd & 0x000000FF));
  stall(1);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STREXB::replicate() const throw() {
  return new STREXB(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STREXB::get_name() const throw() {
  return "STREXB";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STREXB::get_id() const throw() {
  return 99;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STREXB::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STREXB::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STREXB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STRH_i::STRH_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // STRH_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STRH_i::~STRH_i() {

} // ~STRH_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STRH_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid STRH/STRHT (immediate) encoding: (rn = 15 or rn = rd) and writeback.");

  if (rd_bit == 15)
  THROW_EXCEPTION("Invalid STRH/STRHT (immediate) encoding: rd = 0xF.");

  operand = (imm << 4) | rm_bit;
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  data_memory.write_half(address, (unsigned short)(rd & 0x0000FFFF));
  stall(1);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STRH_i::replicate() const throw() {
  return new STRH_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STRH_i::get_name() const throw() {
  return "STRH_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STRH_i::get_id() const throw() {
  return 100;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STRH_i::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STRH_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STRH";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STRH_r::STRH_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // STRH_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STRH_r::~STRH_r() {

} // ~STRH_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STRH_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid STRH/STRHT (register) encoding: (rn = 0xF or rn = rd) and writeback.");

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid STRH/STRHT (register) encoding: rd|rm = 0xF.");

  if (imm)
  THROW_WARNING("Invalid STRH/STRHT (register) encoding: rs != 0x0.");

  operand = rm;
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  data_memory.write_half(address, (unsigned short)(rd & 0x0000FFFF));
  stall(1);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STRH_r::replicate() const throw() {
  return new STRH_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STRH_r::get_name() const throw() {
  return "STRH_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STRH_r::get_id() const throw() {
  return 101;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STRH_r::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STRH_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STRH";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STREXH::STREXH(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // STREXH()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STREXH::~STREXH() {

} // ~STREXH()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STREXH::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid STREXH encoding: rn|rd|rm = 0xF.");

  if ((rn_bit == rd_bit) || (rd_bit == rm_bit))
  THROW_EXCEPTION("Invalid STREXH encoding: rn|rm = rd.");

  if (rs_bit != 15)
  THROW_WARNING("Invalid STREXH encoding: rs != 0xF.");

  data_memory.write_half(rn, (unsigned char)(rd & 0x0000FFFF));
  stall(1);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STREXH::replicate() const throw() {
  return new STREXH(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STREXH::get_name() const throw() {
  return "STREXH";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STREXH::get_id() const throw() {
  return 102;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STREXH::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STREXH::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STREXH";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STRD::STRD(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // STRD()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STRD::~STRD() {

} // ~STRD()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STRD::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit) || (rn_bit == rd_bit+1)))
  THROW_EXCEPTION("Invalid LDRD (immediate) encoding: rn = rd|rd+1 and writeback.");

  if (!p && w)
  THROW_EXCEPTION("Invalid STRD (immediate) encoding: p = 0 and w = 1. There is no STRDT instruction.");

  if (rd_bit == 14)
  THROW_EXCEPTION("Invalid STRD (immediate) encoding: rd = 0xE.");

  if (rd_bit & 0x1)
  THROW_EXCEPTION("Invalid STRD (immediate) encoding: rd[0] = 1.");

  operand = (imm << 4) | rm_bit;
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  data_memory.write_word(address, rd);
  data_memory.write_word(address+4, REGS[rd_bit+1]);
  stall(1);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STRD::replicate() const throw() {
  return new STRD(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STRD::get_name() const throw() {
  return "STRD";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STRD::get_id() const throw() {
  return 103;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STRD::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STRD::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STRD";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STRD_r::STRD_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSOffsetOp(R, data_memory, total_cycles) {

} // STRD_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STRD_r::~STRD_r() {

} // ~STRD_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STRD_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit) || (rn_bit == rd_bit+1)))
  THROW_EXCEPTION("Invalid STRD (register) encoding: (rn = 0xF or rn = rd|rd+1) and writeback.");

  if (!p && w)
  THROW_EXCEPTION("Invalid STRD (register) encoding: p = 0 and w = 1. There is no STRDT instruction.");

  if ((rd_bit == 14) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid STRD (register) encoding: rd = 0xE or rm = 0xF or rm = rd|rd+1.");

  if (rd_bit & 0x1)
  THROW_EXCEPTION("Invalid STRD (register) encoding: rd[0] = 1.");

  if (imm)
  THROW_WARNING("Invalid STRD (register) encoding: rs != 0x0.");

  operand = rm;
  this->total_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  data_memory.write_word(address, rd);
  data_memory.write_word(address+4, REGS[rd_bit+1]);
  stall(1);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STRD_r::replicate() const throw() {
  return new STRD_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STRD_r::get_name() const throw() {
  return "STRD_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STRD_r::get_id() const throw() {
  return 104;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STRD_r::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STRD_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STRD";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STREXD::STREXD(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // STREXD()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STREXD::~STREXD() {

} // ~STREXD()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STREXD::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 14))
  THROW_EXCEPTION("Invalid STREXD encoding: rn|rd = 0xF or rm = 0xE.");

  if (rm_bit & 0x1)
  THROW_EXCEPTION("Invalid STREXD encoding: rm[0] = 1.");

  if ((rn_bit == rd_bit) || (rd_bit == rm_bit) || (rd_bit == rm_bit+1))
  THROW_EXCEPTION("Invalid STREXD encoding: rn|rm|rm+1 = rd.");

  if (rs_bit != 15)
  THROW_WARNING("Invalid STREXD encoding: rs != 0xF.");

  data_memory.write_word(rn, rd);
  data_memory.write_word(rn+4, REGS[rd_bit+1]);
  stall(1);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STREXD::replicate() const throw() {
  return new STREXD(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STREXD::get_name() const throw() {
  return "STREXD";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STREXD::get_id() const throw() {
  return 105;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STREXD::set_params(const unsigned& bitstring) throw()
{
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STREXD::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STREXD";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDM::LDM(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSMReglistOp(R, data_memory, total_cycles) {

} // LDM()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDM::~LDM() {

} // ~LDM()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDM::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  unsigned mode = (s? ((reg_list & 0x8000)? 2 /* exception return */
  : 1 /* user registers */)
  : 0 /* user mode*/);

  //if (!mode && w && (rn_bit == 13) && (BitCount(reg_list) > 1))
  // POP is caught by the decoder as a subinstruction and never redirects here.

  if (rn_bit == 15)
  THROW_EXCEPTION("Invalid LDM encoding: rn = 0xF.");

  if ((!mode || (mode == 1)) && !reg_list)
  THROW_EXCEPTION("Invalid LDM encoding: reg_list = 0x0.");

  if (w && (reg_list & (0x1 << rn_bit)))
  THROW_EXCEPTION("Invalid LDM encoding: w = 1 and reg_list[rn] = 1.");

  if ((mode == 1) && w)
  THROW_WARNING("Invalid LDM (user registers) encoding: w != 0.");

# ifdef ACC_MODEL
  for (int i = 0; i < 16; i++) {
    if ((reg_list & (0x00000001 << i)) != 0) {
      REGS[i].lock();
    }
  }
# endif
  this->total_cycles += LSMReglist(this->rn, this->rn_bit, this->p, this->u,
  this->reg_list, this->start_address, this->wb_address);

  unsigned num_regs_to_load = 0;
  unsigned load_latency = 0;

  if (!s || (reg_list & 0x00008000)) {
    // LDMxx or LDMxx (exception return)
    // Load memory in register i.
    for (int i = 0; i < 15; i++) {
      if ((reg_list & (0x00000001 << i)) != 0) {
        REGS[i] = data_memory.read_word(start_address);
        start_address += 4;
        num_regs_to_load++;
      }
    }
    load_latency = num_regs_to_load + 1;

    // Load memory in PC.
    // If the PC is among reg_list, this is like performing a branch.
    if (reg_list & 0x00008000) {
      if (s) {
        // LDMxx (exception return)
        unsigned value = 0, mode = CPSR[CPSR_M], mask = 0;
        int spsr_idx = get_spsr_idx(mode);
        if (spsr_idx >= 0) {
          value = SPSR[spsr_idx];
          mask = psr_mask(value, 0xF, mode, false, true);
          // If the mode is going to change, update the aliases.
          if ((mask & 0x1F) && (mode != (value & 0x1F))) {
            update_alias(mode, value & 0x1F);
          }
          if (mask) {
            CPSR = (CPSR & !mask) | (value & mask);
          }
        }
      }
      if (!(s && (CPSR[CPSR_M] == 0x1A) && CPSR[CPSR_J] && CPSR[CPSR_T]))
      BranchWritePC(data_memory.read_word(start_address));
      num_regs_to_load++;
      load_latency += 2;
      flush();
    }

    // Optionally write back to base register.
    if (w && !(reg_list & (0x00000001 << rn_bit))) {
      // The writeback address is written back to the base register.
      rn = wb_address;
    }
  } else {
    // LDMxx (user registers)
    for (int i = 0; i < 15; i++) {
      if ((reg_list & (0x00000001 << i)) != 0) {
        // Load user mode registers.
        REGS[i] = data_memory.read_word(start_address);
        start_address += 4;
        num_regs_to_load++;
      }
    }
    load_latency = num_regs_to_load + 1;
  }
  stall(load_latency);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDM::replicate() const throw() {
  return new LDM(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDM::get_name() const throw() {
  return "LDM";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDM::get_id() const throw() {
  return 106;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDM::set_params(const unsigned& bitstring) throw() {
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->s = (bitstring & 0x400000) >> 22;
  this->w = (bitstring & 0x200000) >> 21;
  this->reg_list = (bitstring & 0xffff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDM::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDM";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  oss << ", {";
  oss << std::showbase << std::hex << this->reg_list;
  oss << "}";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDMIB::LDMIB(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSMReglistOp(R, data_memory, total_cycles) {

} // LDMIB()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDMIB::~LDMIB() {

} // ~LDMIB()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDMIB::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  unsigned mode = (s? ((reg_list & 0x8000)? 2 /* exception return */
  : 1 /* user registers */)
  : 0 /* user mode*/);

  //if (!mode && w && (rn_bit == 13) && (BitCount(reg_list) > 1))
  // POP is caught by the decoder as a subinstruction and never redirects here.

  if (rn_bit == 15)
  THROW_EXCEPTION("Invalid LDM encoding: rn = 0xF.");

  if ((!mode || (mode == 1)) && !reg_list)
  THROW_EXCEPTION("Invalid LDM encoding: reg_list = 0x0.");

  if (w && (reg_list & (0x1 << rn_bit)))
  THROW_EXCEPTION("Invalid LDM encoding: w = 1 and reg_list[rn] = 1.");

  if ((mode == 1) && w)
  THROW_WARNING("Invalid LDM (user registers) encoding: w != 0.");

# ifdef ACC_MODEL
  for (int i = 0; i < 16; i++) {
    if ((reg_list & (0x00000001 << i)) != 0) {
      REGS[i].lock();
    }
  }
# endif
  this->total_cycles += LSMReglist(this->rn, this->rn_bit, this->p, this->u,
  this->reg_list, this->start_address, this->wb_address);

  unsigned num_regs_to_load = 0;
  unsigned load_latency = 0;

  if (!s || (reg_list & 0x00008000)) {
    // LDMxx or LDMxx (exception return)
    // Load memory in register i.
    for (int i = 0; i < 15; i++) {
      if ((reg_list & (0x00000001 << i)) != 0) {
        REGS[i] = data_memory.read_word(start_address);
        start_address += 4;
        num_regs_to_load++;
      }
    }
    load_latency = num_regs_to_load + 1;

    // Load memory in PC.
    // If the PC is among reg_list, this is like performing a branch.
    if (reg_list & 0x00008000) {
      if (s) {
        // LDMxx (exception return)
        unsigned value = 0, mode = CPSR[CPSR_M], mask = 0;
        int spsr_idx = get_spsr_idx(mode);
        if (spsr_idx >= 0) {
          value = SPSR[spsr_idx];
          mask = psr_mask(value, 0xF, mode, false, true);
          // If the mode is going to change, update the aliases.
          if ((mask & 0x1F) && (mode != (value & 0x1F))) {
            update_alias(mode, value & 0x1F);
          }
          if (mask) {
            CPSR = (CPSR & !mask) | (value & mask);
          }
        }
      }
      if (!(s && (CPSR[CPSR_M] == 0x1A) && CPSR[CPSR_J] && CPSR[CPSR_T]))
      BranchWritePC(data_memory.read_word(start_address));
      num_regs_to_load++;
      load_latency += 2;
      flush();
    }

    // Optionally write back to base register.
    if (w && !(reg_list & (0x00000001 << rn_bit))) {
      // The writeback address is written back to the base register.
      rn = wb_address;
    }
  } else {
    // LDMxx (user registers)
    for (int i = 0; i < 15; i++) {
      if ((reg_list & (0x00000001 << i)) != 0) {
        // Load user mode registers.
        REGS[i] = data_memory.read_word(start_address);
        start_address += 4;
        num_regs_to_load++;
      }
    }
    load_latency = num_regs_to_load + 1;
  }
  stall(load_latency);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDMIB::replicate() const throw() {
  return new LDMIB(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDMIB::get_name() const throw() {
  return "LDMIB";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDMIB::get_id() const throw() {
  return 107;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDMIB::set_params(const unsigned& bitstring) throw() {
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->s = (bitstring & 0x400000) >> 22;
  this->w = (bitstring & 0x200000) >> 21;
  this->reg_list = (bitstring & 0xffff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDMIB::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDMIB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  oss << ", {";
  oss << std::showbase << std::hex << this->reg_list;
  oss << "}";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDMDA::LDMDA(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSMReglistOp(R, data_memory, total_cycles) {

} // LDMDA()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDMDA::~LDMDA() {

} // ~LDMDA()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDMDA::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  unsigned mode = (s? ((reg_list & 0x8000)? 2 /* exception return */
  : 1 /* user registers */)
  : 0 /* user mode*/);

  //if (!mode && w && (rn_bit == 13) && (BitCount(reg_list) > 1))
  // POP is caught by the decoder as a subinstruction and never redirects here.

  if (rn_bit == 15)
  THROW_EXCEPTION("Invalid LDM encoding: rn = 0xF.");

  if ((!mode || (mode == 1)) && !reg_list)
  THROW_EXCEPTION("Invalid LDM encoding: reg_list = 0x0.");

  if (w && (reg_list & (0x1 << rn_bit)))
  THROW_EXCEPTION("Invalid LDM encoding: w = 1 and reg_list[rn] = 1.");

  if ((mode == 1) && w)
  THROW_WARNING("Invalid LDM (user registers) encoding: w != 0.");

# ifdef ACC_MODEL
  for (int i = 0; i < 16; i++) {
    if ((reg_list & (0x00000001 << i)) != 0) {
      REGS[i].lock();
    }
  }
# endif
  this->total_cycles += LSMReglist(this->rn, this->rn_bit, this->p, this->u,
  this->reg_list, this->start_address, this->wb_address);

  unsigned num_regs_to_load = 0;
  unsigned load_latency = 0;

  if (!s || (reg_list & 0x00008000)) {
    // LDMxx or LDMxx (exception return)
    // Load memory in register i.
    for (int i = 0; i < 15; i++) {
      if ((reg_list & (0x00000001 << i)) != 0) {
        REGS[i] = data_memory.read_word(start_address);
        start_address += 4;
        num_regs_to_load++;
      }
    }
    load_latency = num_regs_to_load + 1;

    // Load memory in PC.
    // If the PC is among reg_list, this is like performing a branch.
    if (reg_list & 0x00008000) {
      if (s) {
        // LDMxx (exception return)
        unsigned value = 0, mode = CPSR[CPSR_M], mask = 0;
        int spsr_idx = get_spsr_idx(mode);
        if (spsr_idx >= 0) {
          value = SPSR[spsr_idx];
          mask = psr_mask(value, 0xF, mode, false, true);
          // If the mode is going to change, update the aliases.
          if ((mask & 0x1F) && (mode != (value & 0x1F))) {
            update_alias(mode, value & 0x1F);
          }
          if (mask) {
            CPSR = (CPSR & !mask) | (value & mask);
          }
        }
      }
      if (!(s && (CPSR[CPSR_M] == 0x1A) && CPSR[CPSR_J] && CPSR[CPSR_T]))
      BranchWritePC(data_memory.read_word(start_address));
      num_regs_to_load++;
      load_latency += 2;
      flush();
    }

    // Optionally write back to base register.
    if (w && !(reg_list & (0x00000001 << rn_bit))) {
      // The writeback address is written back to the base register.
      rn = wb_address;
    }
  } else {
    // LDMxx (user registers)
    for (int i = 0; i < 15; i++) {
      if ((reg_list & (0x00000001 << i)) != 0) {
        // Load user mode registers.
        REGS[i] = data_memory.read_word(start_address);
        start_address += 4;
        num_regs_to_load++;
      }
    }
    load_latency = num_regs_to_load + 1;
  }
  stall(load_latency);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDMDA::replicate() const throw() {
  return new LDMDA(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDMDA::get_name() const throw() {
  return "LDMDA";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDMDA::get_id() const throw() {
  return 108;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDMDA::set_params(const unsigned& bitstring) throw() {
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->s = (bitstring & 0x400000) >> 22;
  this->w = (bitstring & 0x200000) >> 21;
  this->reg_list = (bitstring & 0xffff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDMDA::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDMDA";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  oss << ", {";
  oss << std::showbase << std::hex << this->reg_list;
  oss << "}";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDMDB::LDMDB(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSMReglistOp(R, data_memory, total_cycles) {

} // LDMDB()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDMDB::~LDMDB() {

} // ~LDMDB()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDMDB::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  unsigned mode = (s? ((reg_list & 0x8000)? 2 /* exception return */
  : 1 /* user registers */)
  : 0 /* user mode*/);

  //if (!mode && w && (rn_bit == 13) && (BitCount(reg_list) > 1))
  // POP is caught by the decoder as a subinstruction and never redirects here.

  if (rn_bit == 15)
  THROW_EXCEPTION("Invalid LDM encoding: rn = 0xF.");

  if ((!mode || (mode == 1)) && !reg_list)
  THROW_EXCEPTION("Invalid LDM encoding: reg_list = 0x0.");

  if (w && (reg_list & (0x1 << rn_bit)))
  THROW_EXCEPTION("Invalid LDM encoding: w = 1 and reg_list[rn] = 1.");

  if ((mode == 1) && w)
  THROW_WARNING("Invalid LDM (user registers) encoding: w != 0.");

# ifdef ACC_MODEL
  for (int i = 0; i < 16; i++) {
    if ((reg_list & (0x00000001 << i)) != 0) {
      REGS[i].lock();
    }
  }
# endif
  this->total_cycles += LSMReglist(this->rn, this->rn_bit, this->p, this->u,
  this->reg_list, this->start_address, this->wb_address);

  unsigned num_regs_to_load = 0;
  unsigned load_latency = 0;

  if (!s || (reg_list & 0x00008000)) {
    // LDMxx or LDMxx (exception return)
    // Load memory in register i.
    for (int i = 0; i < 15; i++) {
      if ((reg_list & (0x00000001 << i)) != 0) {
        REGS[i] = data_memory.read_word(start_address);
        start_address += 4;
        num_regs_to_load++;
      }
    }
    load_latency = num_regs_to_load + 1;

    // Load memory in PC.
    // If the PC is among reg_list, this is like performing a branch.
    if (reg_list & 0x00008000) {
      if (s) {
        // LDMxx (exception return)
        unsigned value = 0, mode = CPSR[CPSR_M], mask = 0;
        int spsr_idx = get_spsr_idx(mode);
        if (spsr_idx >= 0) {
          value = SPSR[spsr_idx];
          mask = psr_mask(value, 0xF, mode, false, true);
          // If the mode is going to change, update the aliases.
          if ((mask & 0x1F) && (mode != (value & 0x1F))) {
            update_alias(mode, value & 0x1F);
          }
          if (mask) {
            CPSR = (CPSR & !mask) | (value & mask);
          }
        }
      }
      if (!(s && (CPSR[CPSR_M] == 0x1A) && CPSR[CPSR_J] && CPSR[CPSR_T]))
      BranchWritePC(data_memory.read_word(start_address));
      num_regs_to_load++;
      load_latency += 2;
      flush();
    }

    // Optionally write back to base register.
    if (w && !(reg_list & (0x00000001 << rn_bit))) {
      // The writeback address is written back to the base register.
      rn = wb_address;
    }
  } else {
    // LDMxx (user registers)
    for (int i = 0; i < 15; i++) {
      if ((reg_list & (0x00000001 << i)) != 0) {
        // Load user mode registers.
        REGS[i] = data_memory.read_word(start_address);
        start_address += 4;
        num_regs_to_load++;
      }
    }
    load_latency = num_regs_to_load + 1;
  }
  stall(load_latency);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDMDB::replicate() const throw() {
  return new LDMDB(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDMDB::get_name() const throw() {
  return "LDMDB";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDMDB::get_id() const throw() {
  return 109;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDMDB::set_params(const unsigned& bitstring) throw() {
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->s = (bitstring & 0x400000) >> 22;
  this->w = (bitstring & 0x200000) >> 21;
  this->reg_list = (bitstring & 0xffff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDMDB::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDMDB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  oss << ", {";
  oss << std::showbase << std::hex << this->reg_list;
  oss << "}";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::POP_single::POP_single(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // POP_single()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::POP_single::~POP_single() {

} // ~POP_single()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::POP_single::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (imm0 == 13)
  THROW_EXCEPTION("Invalid POP (single) encoding: rd = 0xD.");

# ifdef ACC_MODEL
  REGS[imm0].lock();
# endif
  unsigned reg_list = (0x1 << imm0);

  unsigned start_address = SP;
  unsigned num_regs_to_load = 0;
  unsigned load_latency = 0;

  for (int i = 0; i < 15; i++) {
    if ((reg_list & (0x00000001 << i)) != 0) {
      // Load user mode registers.
      REGS[i] = data_memory.read_word(start_address);
      start_address += 4;
      num_regs_to_load++;
    }
  }

  // Load memory in PC.
  // If the PC is among reg_list, this is like performing a branch.
  if (reg_list & 0x00008000) {
    BranchWritePC(data_memory.read_word(start_address));
    num_regs_to_load++;
    load_latency += 2;
    flush();
  }

  // Update SP.
  SP += 4 * num_regs_to_load;

  load_latency = num_regs_to_load + 1;
  stall(load_latency);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::POP_single::replicate() const throw() {
  return new POP_single(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::POP_single::get_name() const throw() {
  return "POP_single";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::POP_single::get_id() const throw() {
  return 110;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::POP_single::set_params(const unsigned& bitstring)
throw() {
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->imm0 = (bitstring & 0xf000) >> 12;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::POP_single::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "POP";
  oss << std::showbase << std::hex << this->cond;
  oss << " {";
  oss << std::showbase << std::hex << this->imm0;
  oss << "}";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::POP_block::POP_block(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // POP_block()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::POP_block::~POP_block() {

} // ~POP_block()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::POP_block::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  unsigned reg_list = (imm0 << 12) | imm1;

  if (reg_list & (0x1 << 13))
  THROW_EXCEPTION("Invalid POP (block) encoding: reg_list[13] = 1.");

# ifdef ACC_MODEL
  for (int i = 0; i < 16; i++) {
    if ((reg_list & (0x00000001 << i)) != 0) {
      REGS[i].lock();
    }
  }
# endif

  unsigned start_address = SP;
  unsigned num_regs_to_load = 0;
  unsigned load_latency = 0;

  for (int i = 0; i < 15; i++) {
    if ((reg_list & (0x00000001 << i)) != 0) {
      // Load user mode registers.
      REGS[i] = data_memory.read_word(start_address);
      start_address += 4;
      num_regs_to_load++;
    }
  }

  // Load memory in PC.
  // If the PC is among reg_list, this is like performing a branch.
  if (reg_list & 0x00008000) {
    BranchWritePC(data_memory.read_word(start_address));
    num_regs_to_load++;
    load_latency += 2;
    flush();
  }

  // Update SP.
  SP += 4 * num_regs_to_load;

  load_latency = num_regs_to_load + 1;
  stall(load_latency);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::POP_block::replicate() const throw() {
  return new POP_block(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::POP_block::get_name() const throw() {
  return "POP_block";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::POP_block::get_id() const throw() {
  return 111;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::POP_block::set_params(const unsigned& bitstring)
throw() {
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->imm0 = (bitstring & 0xf000) >> 12;
  this->imm1 = (bitstring & 0xfff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::POP_block::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "POP";
  oss << std::showbase << std::hex << this->cond;
  oss << " {";
  oss << std::showbase << std::hex << (((this->imm0 << 12) & (unsigned)0xF000) |
  (this->imm1 & ((unsigned)0xFFF)));
  oss << "}";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STM::STM(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSMReglistOp(R, data_memory, total_cycles) {

} // STM()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STM::~STM() {

} // ~STM()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STM::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  //if (!s && w && (rn_bit == 13) && (BitCount(reg_list) > 1))
  // PUSH is caught by the decoder as a subinstruction and never redirects here.

  if (rn_bit == 15)
  THROW_EXCEPTION("Invalid STM encoding: rn = 0xF.");

  if (!reg_list)
  THROW_EXCEPTION("Invalid STM encoding: reg_list = 0x0.");

  if (s && w)
  THROW_WARNING("Invalid STM (user registers) encoding: w != 0.");

# ifdef ACC_MODEL
  for (int i = 0; i < 16; i++) {
    if ((reg_list & (0x00000001 << i)) != 0) {
      REGS[i].isLocked();
    }
  }
# endif
  this->total_cycles += LSMReglist(this->rn, this->rn_bit, this->p, this->u,
  this->reg_list, this->start_address, this->wb_address);

  unsigned num_regs_to_store = 0;
  start_address &= 0xFFFFFFFC;

  if (!s) {
    // STMxx common registers
    for (int i = 0; i < 16; i++) {
      if ((reg_list & (0x00000001 << i)) != 0) {
        data_memory.write_word(start_address, REGS[i]);
        start_address += 4;
        num_regs_to_store++;
      }
    }
    // Update base register if necessary.
    // NOTE: Using the writeback strategy and putting the base register in the
    // list of registers to be saved is defined by the ARM as an undefined
    // operation, unless it is first in the register list. This implies that the
    // write back happens in parallel to the storing of the first register.
    if (w)
    rn = wb_address;
  } else {
    // STMxx (user registers)
    for (int i = 0; i < 16; i++) {
      if ((reg_list & (0x00000001 << i)) != 0) {
        // Store user mode registers.
        data_memory.write_word(start_address, REGS[i]);
        start_address += 4;
        num_regs_to_store++;
      }
    }
  }
  stall(num_regs_to_store);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STM::replicate() const throw() {
  return new STM(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STM::get_name() const throw() {
  return "STM";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STM::get_id() const throw() {
  return 112;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STM::set_params(const unsigned& bitstring) throw() {
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->s = (bitstring & 0x400000) >> 22;
  this->w = (bitstring & 0x200000) >> 21;
  this->reg_list = (bitstring & 0xffff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STM::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STM";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  oss << ", {";
  oss << std::showbase << std::hex << this->reg_list;
  oss << "}";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STMIB::STMIB(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSMReglistOp(R, data_memory, total_cycles) {

} // STMIB()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STMIB::~STMIB() {

} // ~STMIB()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STMIB::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  //if (!s && w && (rn_bit == 13) && (BitCount(reg_list) > 1))
  // PUSH is caught by the decoder as a subinstruction and never redirects here.

  if (rn_bit == 15)
  THROW_EXCEPTION("Invalid STM encoding: rn = 0xF.");

  if (!reg_list)
  THROW_EXCEPTION("Invalid STM encoding: reg_list = 0x0.");

  if (s && w)
  THROW_WARNING("Invalid STM (user registers) encoding: w != 0.");

# ifdef ACC_MODEL
  for (int i = 0; i < 16; i++) {
    if ((reg_list & (0x00000001 << i)) != 0) {
      REGS[i].isLocked();
    }
  }
# endif
  this->total_cycles += LSMReglist(this->rn, this->rn_bit, this->p, this->u,
  this->reg_list, this->start_address, this->wb_address);

  unsigned num_regs_to_store = 0;
  start_address &= 0xFFFFFFFC;

  if (!s) {
    // STMxx common registers
    for (int i = 0; i < 16; i++) {
      if ((reg_list & (0x00000001 << i)) != 0) {
        data_memory.write_word(start_address, REGS[i]);
        start_address += 4;
        num_regs_to_store++;
      }
    }
    // Update base register if necessary.
    // NOTE: Using the writeback strategy and putting the base register in the
    // list of registers to be saved is defined by the ARM as an undefined
    // operation, unless it is first in the register list. This implies that the
    // write back happens in parallel to the storing of the first register.
    if (w)
    rn = wb_address;
  } else {
    // STMxx (user registers)
    for (int i = 0; i < 16; i++) {
      if ((reg_list & (0x00000001 << i)) != 0) {
        // Store user mode registers.
        data_memory.write_word(start_address, REGS[i]);
        start_address += 4;
        num_regs_to_store++;
      }
    }
  }
  stall(num_regs_to_store);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STMIB::replicate() const throw() {
  return new STMIB(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STMIB::get_name() const throw() {
  return "STMIB";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STMIB::get_id() const throw() {
  return 113;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STMIB::set_params(const unsigned& bitstring) throw() {
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->s = (bitstring & 0x400000) >> 22;
  this->w = (bitstring & 0x200000) >> 21;
  this->reg_list = (bitstring & 0xffff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STMIB::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STMIB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  oss << ", {";
  oss << std::showbase << std::hex << this->reg_list;
  oss << "}";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STMDA::STMDA(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSMReglistOp(R, data_memory, total_cycles) {

} // STMDA()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STMDA::~STMDA() {

} // ~STMDA()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STMDA::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  //if (!s && w && (rn_bit == 13) && (BitCount(reg_list) > 1))
  // PUSH is caught by the decoder as a subinstruction and never redirects here.

  if (rn_bit == 15)
  THROW_EXCEPTION("Invalid STM encoding: rn = 0xF.");

  if (!reg_list)
  THROW_EXCEPTION("Invalid STM encoding: reg_list = 0x0.");

  if (s && w)
  THROW_WARNING("Invalid STM (user registers) encoding: w != 0.");

# ifdef ACC_MODEL
  for (int i = 0; i < 16; i++) {
    if ((reg_list & (0x00000001 << i)) != 0) {
      REGS[i].isLocked();
    }
  }
# endif
  this->total_cycles += LSMReglist(this->rn, this->rn_bit, this->p, this->u,
  this->reg_list, this->start_address, this->wb_address);

  unsigned num_regs_to_store = 0;
  start_address &= 0xFFFFFFFC;

  if (!s) {
    // STMxx common registers
    for (int i = 0; i < 16; i++) {
      if ((reg_list & (0x00000001 << i)) != 0) {
        data_memory.write_word(start_address, REGS[i]);
        start_address += 4;
        num_regs_to_store++;
      }
    }
    // Update base register if necessary.
    // NOTE: Using the writeback strategy and putting the base register in the
    // list of registers to be saved is defined by the ARM as an undefined
    // operation, unless it is first in the register list. This implies that the
    // write back happens in parallel to the storing of the first register.
    if (w)
    rn = wb_address;
  } else {
    // STMxx (user registers)
    for (int i = 0; i < 16; i++) {
      if ((reg_list & (0x00000001 << i)) != 0) {
        // Store user mode registers.
        data_memory.write_word(start_address, REGS[i]);
        start_address += 4;
        num_regs_to_store++;
      }
    }
  }
  stall(num_regs_to_store);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STMDA::replicate() const throw() {
  return new STMDA(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STMDA::get_name() const throw() {
  return "STMDA";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STMDA::get_id() const throw() {
  return 114;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STMDA::set_params(const unsigned& bitstring) throw() {
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->s = (bitstring & 0x400000) >> 22;
  this->w = (bitstring & 0x200000) >> 21;
  this->reg_list = (bitstring & 0xffff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STMDA::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STMDA";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  oss << ", {";
  oss << std::showbase << std::hex << this->reg_list;
  oss << "}";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STMDB::STMDB(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  LSMReglistOp(R, data_memory, total_cycles) {

} // STMDB()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STMDB::~STMDB() {

} // ~STMDB()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STMDB::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  //if (!s && w && (rn_bit == 13) && (BitCount(reg_list) > 1))
  // PUSH is caught by the decoder as a subinstruction and never redirects here.

  if (rn_bit == 15)
  THROW_EXCEPTION("Invalid STM encoding: rn = 0xF.");

  if (!reg_list)
  THROW_EXCEPTION("Invalid STM encoding: reg_list = 0x0.");

  if (s && w)
  THROW_WARNING("Invalid STM (user registers) encoding: w != 0.");

# ifdef ACC_MODEL
  for (int i = 0; i < 16; i++) {
    if ((reg_list & (0x00000001 << i)) != 0) {
      REGS[i].isLocked();
    }
  }
# endif
  this->total_cycles += LSMReglist(this->rn, this->rn_bit, this->p, this->u,
  this->reg_list, this->start_address, this->wb_address);

  unsigned num_regs_to_store = 0;
  start_address &= 0xFFFFFFFC;

  if (!s) {
    // STMxx common registers
    for (int i = 0; i < 16; i++) {
      if ((reg_list & (0x00000001 << i)) != 0) {
        data_memory.write_word(start_address, REGS[i]);
        start_address += 4;
        num_regs_to_store++;
      }
    }
    // Update base register if necessary.
    // NOTE: Using the writeback strategy and putting the base register in the
    // list of registers to be saved is defined by the ARM as an undefined
    // operation, unless it is first in the register list. This implies that the
    // write back happens in parallel to the storing of the first register.
    if (w)
    rn = wb_address;
  } else {
    // STMxx (user registers)
    for (int i = 0; i < 16; i++) {
      if ((reg_list & (0x00000001 << i)) != 0) {
        // Store user mode registers.
        data_memory.write_word(start_address, REGS[i]);
        start_address += 4;
        num_regs_to_store++;
      }
    }
  }
  stall(num_regs_to_store);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STMDB::replicate() const throw() {
  return new STMDB(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STMDB::get_name() const throw() {
  return "STMDB";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STMDB::get_id() const throw() {
  return 115;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STMDB::set_params(const unsigned& bitstring) throw() {
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->s = (bitstring & 0x400000) >> 22;
  this->w = (bitstring & 0x200000) >> 21;
  this->reg_list = (bitstring & 0xffff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STMDB::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STMDB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  oss << ", {";
  oss << std::showbase << std::hex << this->reg_list;
  oss << "}";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::PUSH_single::PUSH_single(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // PUSH_single()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::PUSH_single::~PUSH_single() {

} // ~PUSH_single()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::PUSH_single::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (imm0 == 13)
  THROW_EXCEPTION("Invalid PUSH (single) encoding: rd = 0xD.");

# ifdef ACC_MODEL
  REGS[imm0].isLocked();
# endif
  unsigned reg_list = (0x1 << imm0);

  unsigned input = reg_list;
  unsigned num_regs_to_store = 0;
  for (; input; num_regs_to_store++) {
    // Clear least significant bit set.
    input &= input - 1;
  }
  unsigned start_address = SP - 4 * num_regs_to_store;

  for (int i = 0; i < 16; i++) {
    if ((reg_list & (0x00000001 << i)) != 0) {
      // Store user mode registers.
      data_memory.write_word(start_address, REGS[i]);
      start_address += 4;
    }
  }

  // Update SP.
  SP -= 4 * num_regs_to_store;

  stall(num_regs_to_store);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::PUSH_single::replicate() const throw() {
  return new PUSH_single(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::PUSH_single::get_name() const throw() {
  return "PUSH_single";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::PUSH_single::get_id() const throw() {
  return 116;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::PUSH_single::set_params(const unsigned& bitstring)
throw() {
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->imm0 = (bitstring & 0xf000) >> 12;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::PUSH_single::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "PUSH";
  oss << std::showbase << std::hex << this->cond;
  oss << " {";
  oss << std::showbase << std::hex << this->imm0;
  oss << "}";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::PUSH_block::PUSH_block(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // PUSH_block()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::PUSH_block::~PUSH_block() {

} // ~PUSH_block()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::PUSH_block::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  unsigned reg_list = (imm0 << 12) | imm1;

# ifdef ACC_MODEL
  for (int i = 0; i < 16; i++) {
    if ((reg_list & (0x00000001 << i)) != 0) {
      REGS[i].isLocked();
    }
  }
# endif

  unsigned input = reg_list;
  unsigned num_regs_to_store = 0;
  for (; input; num_regs_to_store++) {
    // Clear least significant bit set.
    input &= input - 1;
  }
  unsigned start_address = SP - 4 * num_regs_to_store;

  for (int i = 0; i < 16; i++) {
    if ((reg_list & (0x00000001 << i)) != 0) {
      // Store user mode registers.
      data_memory.write_word(start_address, REGS[i]);
      start_address += 4;
    }
  }

  // Update SP.
  SP -= 4 * num_regs_to_store;

  stall(num_regs_to_store);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::PUSH_block::replicate() const throw() {
  return new PUSH_block(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::PUSH_block::get_name() const throw() {
  return "PUSH_block";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::PUSH_block::get_id() const throw() {
  return 117;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::PUSH_block::set_params(const unsigned& bitstring)
throw() {
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->imm0 = (bitstring & 0xf000) >> 12;
  this->imm1 = (bitstring & 0xfff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::PUSH_block::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "PUSH";
  oss << std::showbase << std::hex << this->cond;
  oss << " {";
  oss << std::showbase << std::hex << (((this->imm0 << 12) & (unsigned)0xF000) |
  (this->imm1 & ((unsigned)0xFFF)));
  oss << "}";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::MOV_i::MOV_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles) {

} // MOV_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::MOV_i::~MOV_i() {

} // ~MOV_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MOV_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  rd = operand;
  result = operand;
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::MOV_i::replicate() const throw() {
  return new MOV_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MOV_i::get_name() const throw() {
  return "MOV_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MOV_i::get_id() const throw() {
  return 118;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::MOV_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MOV_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "MOV";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::MOV_r::MOV_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  UpdatePSRBitOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // MOV_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::MOV_r::~MOV_r() {

} // ~MOV_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MOV_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rn_bit)
  THROW_WARNING("Invalid MOV (register) encoding: rn != 0x0.");

  rd = rm;
  result = rm;
  carry = CPSR[CPSR_C];
  this->total_cycles += UpdatePSRBit(this->rn, this->rn_bit, this->rd, this->rd_bit,
  this->s, this->result, this->carry);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::MOV_r::replicate() const throw() {
  return new MOV_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MOV_r::get_name() const throw() {
  return "MOV_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MOV_r::get_id() const throw() {
  return 119;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::MOV_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MOV_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "MOV";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::MOVW::MOVW(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // MOVW()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::MOVW::~MOVW() {

} // ~MOVW()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MOVW::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit == 15)
  THROW_EXCEPTION("Invalid MOVW encoding: rd = 0xF.");

  unsigned imm0 = (imm0a << 2) | imm0b;
  unsigned imm1 = (imm1a << 2) | (b << 1) | imm1b;
  rd = (imm0 << 12) | (imm1 << 8) | (op1 << 4) | imm2;
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::MOVW::replicate() const throw() {
  return new MOVW(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MOVW::get_name() const throw() {
  return "MOVW";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MOVW::get_id() const throw() {
  return 120;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::MOVW::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->imm0a = (bitstring & 0xc0000) >> 18;
  this->imm0b = (bitstring & 0x30000) >> 16;
  this->imm1a = (bitstring & 0xc00) >> 10;
  this->b = (bitstring & 0x200) >> 9;
  this->imm1b = (bitstring & 0x100) >> 8;
  this->op1 = (bitstring & 0xf0) >> 4;
  this->imm2 = (bitstring & 0xf);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MOVW::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "MOVW";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->imm0a;
  oss << std::showbase << std::hex << this->imm0b;
  oss << std::showbase << std::hex << this->imm1a;
  oss << std::showbase << std::hex << this->b;
  oss << std::showbase << std::hex << this->imm1b;
  oss << std::showbase << std::hex << this->op1;
  oss << std::showbase << std::hex << this->imm2;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::MOVT::MOVT(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // MOVT()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::MOVT::~MOVT() {

} // ~MOVT()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MOVT::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit == 15)
  THROW_EXCEPTION("Invalid MOVT encoding: rd = 0xF.");

  unsigned imm0 = (imm0a << 2) | imm0b;
  unsigned imm1 = (imm1a << 2) | (b << 1) | imm1b;
  rd = (rd & 0x0000FFFF) | (imm0 << 28) | (imm1 << 24) | (op1 << 20) | (imm2 <<
  16);
  {
    unsigned num_cycles = 0;

    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles = 2;
      flush();
    }

    this->total_cycles += num_cycles;
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::MOVT::replicate() const throw() {
  return new MOVT(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MOVT::get_name() const throw() {
  return "MOVT";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MOVT::get_id() const throw() {
  return 121;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::MOVT::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->imm0a = (bitstring & 0xc0000) >> 18;
  this->imm0b = (bitstring & 0x30000) >> 16;
  this->imm1a = (bitstring & 0xc00) >> 10;
  this->b = (bitstring & 0x200) >> 9;
  this->imm1b = (bitstring & 0x100) >> 8;
  this->op1 = (bitstring & 0xf0) >> 4;
  this->imm2 = (bitstring & 0xf);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MOVT::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "MOVT";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->imm0a;
  oss << std::showbase << std::hex << this->imm0b;
  oss << std::showbase << std::hex << this->imm1a;
  oss << std::showbase << std::hex << this->b;
  oss << std::showbase << std::hex << this->imm1b;
  oss << std::showbase << std::hex << this->op1;
  oss << std::showbase << std::hex << this->imm2;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::SWP::SWP(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // SWP()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::SWP::~SWP() {

} // ~SWP()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SWP::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid SWP/SWPB encoding: rn|rd|rm = 0xF.");

  if ((rn_bit == rd_bit) || (rn_bit == rm_bit))
  THROW_EXCEPTION("Invalid SWP/SWPB encoding: rn = rd|rm.");

  if (rs_bit)
  THROW_WARNING("Invalid SWP/SWPB encoding: rs != 0x0.");

  // Needed in case rd == rm.
  unsigned temp;
  if (b) {
    temp = data_memory.read_byte(rn);
    data_memory.write_byte(rn, rm & 0x000000FF);
    rd = temp & 0x000000FF;
  }
  else {
    temp = data_memory.read_word(rn);
    if ((rn & 0x00000003) != 0x0) {
      bool carry_dummy;
      temp = ROR(temp, (rn & 0x00000003) << 3, carry_dummy);
    }
    data_memory.write_word(rn, rm);
    rd = temp;
  }
  stall(3);
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::SWP::replicate() const throw() {
  return new SWP(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SWP::get_name() const throw() {
  return "SWP";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SWP::get_id() const throw() {
  return 122;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::SWP::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->b = (bitstring & 0x400000) >> 22;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SWP::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "SWP";
  switch(this->b) {
    case 1: {
      oss << "B";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::MRS::MRS(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // MRS()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::MRS::~MRS() {

} // ~MRS()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MRS::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  unsigned imm0 = (imm0a << 2) | imm0b;

  if (rd_bit == 15)
  THROW_EXCEPTION("Invalid MRS (reg/banked) encoding: rd = 0xF.");

  if (!b && (imm0 != 0xF))
  THROW_WARNING("Invalid MRS (reg) encoding: imm0 != 0xF.");

  if (imm1a)
  THROW_WARNING("Invalid MRS (reg/banked) encoding: imm1[3:2] != 0x0.");

  if (!b && imm1b)
  THROW_WARNING("Invalid MRS (reg) encoding: imm1[0] != 0x0.");

  if (imm2)
  THROW_WARNING("Invalid MRS (reg/banked) encoding: imm2 != 0x0.");

  // Move from Special Register
  if (!b) {
    // Read CPSR/SPSR
    if (!r) {
      if (CPSR[CPSR_M] & 0xF) {
        // Read CPSR for execution mode != USR
        rd = CPSR & 0xF8FF03DF;
      } else {
        // Read CPSR for execution mode = USR
        rd = CPSR & 0xF8FF0000;
      }
      // Read SPSR for execution modes != USR || SYS
    } else {
      int spsr_idx = get_spsr_idx(CPSR[CPSR_M]);
      if (spsr_idx >= 0) {
        rd = SPSR[spsr_idx];
      } else {
        THROW_EXCEPTION("MRS cannot read the SPSR in USR or SYS mode.");
      }
    }
    // Move from Banked Register
  } else {
    unsigned sys_mode = (imm1b << 4) | imm0;
    // Read banked registers for execution modes != USR
    if (!r) {
      if ((CPSR[CPSR_M] & 0xF) && valid_banked_reg_access(sys_mode)) {
        switch((sys_mode >> 3) & 0x3) {
          case 0x0:
          // Banked USR registers (R8_usr)
          rd = RB[8 + (sys_mode & 0x7)];
          break;
          case 0x1:
          // Banked FIQ registers (R8_fiq)
          rd = RB[18 + (sys_mode & 0x7)];
          break;
          case 0x2:
          // Banked IRQ/SVC/ABT/UND registers
          switch (sys_mode & 0x7) {
            case 0x0:
            case 0x1:
            // Banked IRQ registers (LR_irq)
            rd = RB[17 - (sys_mode & 0x1)];
            break;
            case 0x2:
            case 0x3:
            // Banked SVC registers (LR_svc)
            rd = RB[30 - (sys_mode & 0x1)];
            break;
            case 0x4:
            case 0x5:
            // Banked ABT registers (LR_abt)
            rd = RB[28 - (sys_mode & 0x1)];
            break;
            case 0x6:
            case 0x7:
            // Banked UND registers (LR_und)
            rd = RB[26 - (sys_mode & 0x1)];
            break;
          } break;
          case 0x3:
          // Banked MON/HYP registers
          if (!(sys_mode & 0x2)) {
            // Banked LR_MON / SP_MON registers (LR_mon)
            rd = RB[34 - (sys_mode & 0x1)];
          } else {
            // Banked ELR_HYP / SP_HYP registers (ELR_hyp)
            rd = RB[32 - (sys_mode & 0x1)];
          }
        }
      } else {
        THROW_EXCEPTION("MRS cannot read banked registers in USR mode.");
      }
      // Read SPSR for execution modes != USR
    } else {
      unsigned cur_mode = CPSR[CPSR_M];
      if (cur_mode & 0xF) {
        switch(sys_mode) {
          case 0x0E:
          // Banked LR_IRQ / SP_IRQ registers: Inaccessible from IRQ mode
          if (cur_mode != (unsigned)EXECMODE::FIQ) rd = SPSR_FIQ;
          break;
          case 0x10:
          if (cur_mode != (unsigned)EXECMODE::IRQ) rd = SPSR_IRQ;
          break;
          case 0x12:
          if (cur_mode != (unsigned)EXECMODE::SVC) rd = SPSR_SVC;
          break;
          case 0x14:
          if (cur_mode != (unsigned)EXECMODE::ABT) rd = SPSR_ABT;
          break;
          case 0x16:
          if (cur_mode != (unsigned)EXECMODE::UND) rd = SPSR_UND;
          break;
          case 0x1C:
          if (cur_mode != (unsigned)EXECMODE::MON) rd = SPSR_MON;
          break;
          case 0x1E:
          if (cur_mode != (unsigned)EXECMODE::MON) rd = SPSR_HYP;
          break;
        }
      } else {
        THROW_EXCEPTION("MRS cannot read the SPSR in USR mode.");
      }
    }
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::MRS::replicate() const throw() {
  return new MRS(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MRS::get_name() const throw() {
  return "MRS";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MRS::get_id() const throw() {
  return 123;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::MRS::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->r = (bitstring & 0x400000) >> 22;
  this->imm0a = (bitstring & 0xc0000) >> 18;
  this->imm0b = (bitstring & 0x30000) >> 16;
  this->imm1a = (bitstring & 0xc00) >> 10;
  this->b = (bitstring & 0x200) >> 9;
  this->imm1b = (bitstring & 0x100) >> 8;
  this->imm2 = (bitstring & 0xf);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MRS::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "MRS";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", ";
  switch(this->r) {
    case 0: {
      oss << "CPSR";
    break;}
    case 1: {
      oss << "SPSR";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::MSR_i::MSR_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ARMExpandImmOp(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // MSR_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::MSR_i::~MSR_i() {

} // ~MSR_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MSR_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  unsigned imm0 = (imm0a << 2) | imm0b;

  if (r && !imm0)
  THROW_EXCEPTION("Invalid MSR (imm, sys) encoding: imm0 = 0x0.");

  if (rd_bit != 15)
  THROW_WARNING("Invalid MSR (imm) encoding: rd != 0xF.");

  // Needed by ARMExpandImm().
  rotate = (imm1a << 2) | (b << 1) | imm1b;
  imm = (op1 << 4) | imm2;

  // Needed by opCode shared with msr_reg_instr.
  unsigned id = 1;
  this->total_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  // Move to Special Register (immediate or register)
  if (id || (!id && !b)) {
    // Write CPSR/SPSR
    if (!r) {
      unsigned mode = CPSR[CPSR_M];
      unsigned mask = psr_mask(operand, imm0, mode, false, false);
      // If the mode is going to change, update the aliases.
      if ((mask & 0x1F) && (mode != (operand & 0x1F))) {
        update_alias(mode, operand & 0x1F);
      }
      if (mask) {
        CPSR = (CPSR & !mask) | (operand & mask);
      }
      if ((CPSR[CPSR_M] == (unsigned)EXECMODE::HYP) && CPSR[CPSR_J] && CPSR[CPSR_T])
      {
        THROW_EXCEPTION("MSR cannot set CPSR Jazelle and Thumb flags in HYP mode.");
      }
      // Write SPSR for execution modes != USR || SYS
    } else {
      unsigned mask;
      int spsr_idx = get_spsr_idx(CPSR[CPSR_M]);
      if (spsr_idx >= 0) {
        mask = psr_mask(operand, imm0, CPSR[CPSR_M], true, false);
        if (mask) SPSR[spsr_idx] = (SPSR[spsr_idx] & !mask) | (operand & mask);
      } else {
        THROW_EXCEPTION("MSR cannot write the SPSR in USR or SYS mode.");
      }
    }
    // Move to Banked Register
  } else {
    unsigned sys_mode = (imm1b << 4) | imm0;
    // Write banked registers for execution modes != USR
    if (!r) {
      if ((CPSR[CPSR_M] & 0xF) && valid_banked_reg_access(sys_mode)) {
        switch((sys_mode >> 3) & 0x3) {
          case 0x0:
          // Banked USR registers (R8_usr)
          RB[8 + (sys_mode & 0x7)] = operand;
          break;
          case 0x1:
          // Banked FIQ registers (R8_fiq)
          RB[18 + (sys_mode & 0x7)] = operand;
          break;
          case 0x2:
          // Banked IRQ/SVC/ABT/UND registers
          switch (sys_mode & 0x7) {
            case 0x0:
            case 0x1:
            // Banked IRQ registers (LR_irq)
            RB[17 - (sys_mode & 0x1)] = operand;
            break;
            case 0x2:
            case 0x3:
            // Banked SVC registers (LR_svc)
            RB[30 - (sys_mode & 0x1)] = operand;
            break;
            case 0x4:
            case 0x5:
            // Banked ABT registers (LR_abt)
            RB[28 - (sys_mode & 0x1)] = operand;
            break;
            case 0x6:
            case 0x7:
            // Banked UND registers (LR_und)
            RB[26 - (sys_mode & 0x1)] = operand;
            break;
          } break;
          case 0x3:
          // Banked MON/HYP registers
          if (!(sys_mode & 0x2)) {
            // Banked LR_MON / SP_MON registers (LR_mon)
            RB[34 - (sys_mode & 0x1)] = operand;
          } else {
            // Banked ELR_HYP / SP_HYP registers (ELR_hyp)
            RB[32 - (sys_mode & 0x1)] = operand;
          }
        }
      } else {
        THROW_EXCEPTION("MSR cannot write banked registers in USR mode.");
      }
      // Write SPSR for execution modes != USR
    } else {
      unsigned cur_mode = CPSR[CPSR_M];
      if (cur_mode & 0xF) {
        switch(sys_mode) {
          case 0x0E:
          if (cur_mode != (unsigned)EXECMODE::FIQ) SPSR_FIQ = operand;
          break;
          case 0x10:
          if (cur_mode != (unsigned)EXECMODE::IRQ) SPSR_IRQ = operand;
          break;
          case 0x12:
          if (cur_mode != (unsigned)EXECMODE::SVC) SPSR_SVC = operand;
          break;
          case 0x14:
          if (cur_mode != (unsigned)EXECMODE::ABT) SPSR_ABT = operand;
          break;
          case 0x16:
          if (cur_mode != (unsigned)EXECMODE::UND) SPSR_UND = operand;
          break;
          case 0x1C:
          if (cur_mode != (unsigned)EXECMODE::MON) SPSR_MON = operand;
          break;
          case 0x1E:
          if (cur_mode != (unsigned)EXECMODE::MON) SPSR_HYP = operand;
          break;
        }
      } else {
        THROW_EXCEPTION("MSR cannot write the SPSR in USR mode.");
      }
    }
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::MSR_i::replicate() const throw() {
  return new MSR_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MSR_i::get_name() const throw() {
  return "MSR_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MSR_i::get_id() const throw() {
  return 124;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::MSR_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->r = (bitstring & 0x400000) >> 22;
  this->imm0a = (bitstring & 0xc0000) >> 18;
  this->imm0b = (bitstring & 0x30000) >> 16;
  this->imm1a = (bitstring & 0xc00) >> 10;
  this->b = (bitstring & 0x200) >> 9;
  this->imm1b = (bitstring & 0x100) >> 8;
  this->op1 = (bitstring & 0xf0) >> 4;
  this->imm2 = (bitstring & 0xf);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MSR_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "MSR";
  oss << std::showbase << std::hex << this->cond;
  oss << " ";
  switch(this->r) {
    case 0: {
      oss << "CPSR";
    break;}
    case 1: {
      oss << "SPSR";
    break;}
  }
  oss << ", ";
  oss << std::showbase << std::hex << this->imm1a;
  oss << std::showbase << std::hex << this->b;
  oss << std::showbase << std::hex << this->imm1b;
  oss << std::showbase << std::hex << this->op1;
  oss << std::showbase << std::hex << this->imm2;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::MSR_r::MSR_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // MSR_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::MSR_r::~MSR_r() {

} // ~MSR_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MSR_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  unsigned imm0 = (imm0a << 2) | imm0b;

  if (!b && !imm0)
  THROW_EXCEPTION("Invalid MSR (reg) encoding: imm0 = 0x0.");

  if (imm2 == 15)
  THROW_EXCEPTION("Invalid MSR (reg/banked) encoding: rn = 0xF.");

  if (b && rd_bit != 0xF)
  THROW_WARNING("Invalid MSR (reg/banked) encoding: rd != 0xF.");

  if (imm1a)
  THROW_WARNING("Invalid MSR (reg/banked) encoding: b[10:11] != 0x0.");

  if (!b && imm1b)
  THROW_WARNING("Invalid MSR (reg) encoding: b[8] != 0x0.");

  // Needed by opCode shared with msr_imm_instr.
  unsigned id = 0;
  unsigned operand = REGS[imm2];

  // Move to Special Register (immediate or register)
  if (id || (!id && !b)) {
    // Write CPSR/SPSR
    if (!r) {
      unsigned mode = CPSR[CPSR_M];
      unsigned mask = psr_mask(operand, imm0, mode, false, false);
      // If the mode is going to change, update the aliases.
      if ((mask & 0x1F) && (mode != (operand & 0x1F))) {
        update_alias(mode, operand & 0x1F);
      }
      if (mask) {
        CPSR = (CPSR & !mask) | (operand & mask);
      }
      if ((CPSR[CPSR_M] == (unsigned)EXECMODE::HYP) && CPSR[CPSR_J] && CPSR[CPSR_T])
      {
        THROW_EXCEPTION("MSR cannot set CPSR Jazelle and Thumb flags in HYP mode.");
      }
      // Write SPSR for execution modes != USR || SYS
    } else {
      unsigned mask;
      int spsr_idx = get_spsr_idx(CPSR[CPSR_M]);
      if (spsr_idx >= 0) {
        mask = psr_mask(operand, imm0, CPSR[CPSR_M], true, false);
        if (mask) SPSR[spsr_idx] = (SPSR[spsr_idx] & !mask) | (operand & mask);
      } else {
        THROW_EXCEPTION("MSR cannot write the SPSR in USR or SYS mode.");
      }
    }
    // Move to Banked Register
  } else {
    unsigned sys_mode = (imm1b << 4) | imm0;
    // Write banked registers for execution modes != USR
    if (!r) {
      if ((CPSR[CPSR_M] & 0xF) && valid_banked_reg_access(sys_mode)) {
        switch((sys_mode >> 3) & 0x3) {
          case 0x0:
          // Banked USR registers (R8_usr)
          RB[8 + (sys_mode & 0x7)] = operand;
          break;
          case 0x1:
          // Banked FIQ registers (R8_fiq)
          RB[18 + (sys_mode & 0x7)] = operand;
          break;
          case 0x2:
          // Banked IRQ/SVC/ABT/UND registers
          switch (sys_mode & 0x7) {
            case 0x0:
            case 0x1:
            // Banked IRQ registers (LR_irq)
            RB[17 - (sys_mode & 0x1)] = operand;
            break;
            case 0x2:
            case 0x3:
            // Banked SVC registers (LR_svc)
            RB[30 - (sys_mode & 0x1)] = operand;
            break;
            case 0x4:
            case 0x5:
            // Banked ABT registers (LR_abt)
            RB[28 - (sys_mode & 0x1)] = operand;
            break;
            case 0x6:
            case 0x7:
            // Banked UND registers (LR_und)
            RB[26 - (sys_mode & 0x1)] = operand;
            break;
          } break;
          case 0x3:
          // Banked MON/HYP registers
          if (!(sys_mode & 0x2)) {
            // Banked LR_MON / SP_MON registers (LR_mon)
            RB[34 - (sys_mode & 0x1)] = operand;
          } else {
            // Banked ELR_HYP / SP_HYP registers (ELR_hyp)
            RB[32 - (sys_mode & 0x1)] = operand;
          }
        }
      } else {
        THROW_EXCEPTION("MSR cannot write banked registers in USR mode.");
      }
      // Write SPSR for execution modes != USR
    } else {
      unsigned cur_mode = CPSR[CPSR_M];
      if (cur_mode & 0xF) {
        switch(sys_mode) {
          case 0x0E:
          if (cur_mode != (unsigned)EXECMODE::FIQ) SPSR_FIQ = operand;
          break;
          case 0x10:
          if (cur_mode != (unsigned)EXECMODE::IRQ) SPSR_IRQ = operand;
          break;
          case 0x12:
          if (cur_mode != (unsigned)EXECMODE::SVC) SPSR_SVC = operand;
          break;
          case 0x14:
          if (cur_mode != (unsigned)EXECMODE::ABT) SPSR_ABT = operand;
          break;
          case 0x16:
          if (cur_mode != (unsigned)EXECMODE::UND) SPSR_UND = operand;
          break;
          case 0x1C:
          if (cur_mode != (unsigned)EXECMODE::MON) SPSR_MON = operand;
          break;
          case 0x1E:
          if (cur_mode != (unsigned)EXECMODE::MON) SPSR_HYP = operand;
          break;
        }
      } else {
        THROW_EXCEPTION("MSR cannot write the SPSR in USR mode.");
      }
    }
  }
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::MSR_r::replicate() const throw() {
  return new MSR_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MSR_r::get_name() const throw() {
  return "MSR_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MSR_r::get_id() const throw() {
  return 125;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::MSR_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->r = (bitstring & 0x400000) >> 22;
  this->imm0a = (bitstring & 0xc0000) >> 18;
  this->imm0b = (bitstring & 0x30000) >> 16;
  this->imm1a = (bitstring & 0xc00) >> 10;
  this->b = (bitstring & 0x200) >> 9;
  this->imm1b = (bitstring & 0x100) >> 8;
  this->imm2 = (bitstring & 0xf);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MSR_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "MSR";
  oss << std::showbase << std::hex << this->cond;
  oss << " ";
  switch(this->r) {
    case 0: {
      oss << "CPSR";
    break;}
    case 1: {
      oss << "SPSR";
    break;}
  }
  oss << ", ";
  oss << std::showbase << std::hex << this->imm2;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::B::B(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // B()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::B::~B() {

} // ~B()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::B::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  RB[15] = PC + (((int)sign_extend(offset, 24)) << 2);
  stall(2);
  flush();
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::B::replicate() const throw() {
  return new B(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::B::get_name() const throw() {
  return "B";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::B::get_id() const throw() {
  return 126;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::B::set_params(const unsigned& bitstring) throw() {
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->offset = (bitstring & 0xffffff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::B::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "B";
  oss << std::showbase << std::hex << this->cond;
  oss << " PC + ";
  oss << std::showbase << std::hex << ((((int)sign_extend(this->offset, 24)) <<
  2));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::BL::BL(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // BL()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::BL::~BL() {

} // ~BL()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BL::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  // RB[15] has been incremented and holds the address of the next instruction.
  LR = RB[15];
  RB[15] = PC + (((int)sign_extend(offset, 24)) << 2);
  stall(2);
  flush();
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::BL::replicate() const throw() {
  return new BL(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BL::get_name() const throw() {
  return "BL";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BL::get_id() const throw() {
  return 127;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::BL::set_params(const unsigned& bitstring) throw() {
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->offset = (bitstring & 0xffffff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BL::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "BL";
  oss << std::showbase << std::hex << this->cond;
  oss << " PC + ";
  oss << std::showbase << std::hex << ((((int)sign_extend(this->offset, 24)) <<
  2));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::BX::BX(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // BX()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::BX::~BX() {

} // ~BX()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BX::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit != 15) || (rd_bit != 15) || (rs_bit != 15))
  THROW_WARNING("Invalid BX encoding: rn|rd|rs != 0xF.");

  BranchWritePC(rm);
  stall(2);
  flush();
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::BX::replicate() const throw() {
  return new BX(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BX::get_name() const throw() {
  return "BX";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BX::get_id() const throw() {
  return 128;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::BX::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BX::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "BX";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::BLX_i::BLX_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // BLX_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::BLX_i::~BLX_i() {

} // ~BLX_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BLX_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  // RB[15] has been incremented and holds the address of the next instruction.
  LR = RB[15];
  BranchWritePC((((int)sign_extend(offset, 24)) << 2) | (l << 1));
  stall(2);
  flush();
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::BLX_i::replicate() const throw() {
  return new BLX_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BLX_i::get_name() const throw() {
  return "BLX_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BLX_i::get_id() const throw() {
  return 129;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::BLX_i::set_params(const unsigned& bitstring) throw() {
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->l = (bitstring & 0x1000000) >> 24;
  this->offset = (bitstring & 0xffffff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BLX_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "BLX PC + ";
  oss << std::showbase << std::hex << ((((int)sign_extend(this->offset, 24)) <<
  2));
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::BLX_r::BLX_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // BLX_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::BLX_r::~BLX_r() {

} // ~BLX_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BLX_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rm_bit == 15)
  THROW_EXCEPTION("Invalid BLX encoding: rm = 0xF.");

  if ((rn_bit != 15) || (rd_bit != 15) || (rs_bit != 15))
  THROW_WARNING("Invalid BLX encoding: rn|rd|rs != 0xF.");

  // RB[15] has been incremented and holds the address of the next instruction.
  LR = RB[15];
  BranchWritePC(rm);
  stall(2);
  flush();
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::BLX_r::replicate() const throw() {
  return new BLX_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BLX_r::get_name() const throw() {
  return "BLX_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BLX_r::get_id() const throw() {
  return 130;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::BLX_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BLX_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "BLX";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::BXJ::BXJ(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // BXJ()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::BXJ::~BXJ() {

} // ~BXJ()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BXJ::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rm_bit == 15)
  THROW_EXCEPTION("Invalid BXJ encoding: rm = 0xF.");

  if ((rn_bit != 15) || (rd_bit != 15) || (rs_bit != 15))
  THROW_WARNING("Invalid BXJ encoding: rn|rd|rs != 0xF.");

  BranchWritePC(rm);
  stall(2);
  flush();
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::BXJ::replicate() const throw() {
  return new BXJ(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BXJ::get_name() const throw() {
  return "BXJ";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BXJ::get_id() const throw() {
  return 131;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::BXJ::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BXJ::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "BXJ";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::BKPT::BKPT(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // BKPT()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::BKPT::~BKPT() {

} // ~BKPT()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BKPT::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (cond != 0xE)
  THROW_EXCEPTION("Invalid BKPT encoding: cond != 0xE.");

  // R14_abt = address of BKPT instr + 4.
  LR_ABT = PC + 4;
  SPSR_ABT = CPSR;

  CPSR &= 0xFFFFFFF0;
  CPSR |= 0x00000007;   // Enter abort mode.

  CPSR &= 0xFFFFFFEF;   // CPSR[5]= 0: Execute in ARM state.
  CPSR |= 0x00000080;   // CPSR[7]= 1: Disable normal interrupts.

  //if high vectors configured then
  //PC = 0xFFFF000C;
  //else
  PC = 0x0000000C;

  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::BKPT::replicate() const throw() {
  return new BKPT(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BKPT::get_name() const throw() {
  return "BKPT";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::BKPT::get_id() const throw() {
  return 132;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::BKPT::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::BKPT::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "BKPT R";
  oss << std::dec << this->rn_bit;
  oss << std::dec << this->rd_bit;
  oss << std::dec << this->rs_bit;
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::CLREX::CLREX(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // CLREX()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::CLREX::~CLREX() {

} // ~CLREX()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CLREX::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }

  if ((rn_bit != 15) || (rd_bit != 15) || (rm_bit != 15))
  THROW_WARNING("Invalid CLREX encoding: rn|rd|rm != 0xF.");

  if (rs_bit != 0)
  THROW_WARNING("Invalid CLREX encoding: rs != 0x0.");

  THROW_WARNING("Unimplemented instruction CLREX.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::CLREX::replicate() const throw() {
  return new CLREX(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CLREX::get_name() const throw() {
  return "CLREX";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CLREX::get_id() const throw() {
  return 133;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::CLREX::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CLREX::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "C";
  oss << "L";
  oss << "R";
  oss << "E";
  oss << "X";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::CPS::CPS(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // CPS()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::CPS::~CPS() {

} // ~CPS()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CPS::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }

  unsigned mode = (mode0 << 4) | mode1;

  if (mode && !M)
  THROW_EXCEPTION("Invalid CPS encoding: M = 0 and mode != 0x0.");

  if ((op2 & 0x2) && !A && !I && !F)
  THROW_EXCEPTION("Invalid CPS encoding: imod[1] = 1 and A:I:F = 0x0.");

  if (!(op2 & 0x2) && (A || I || F))
  THROW_EXCEPTION("Invalid CPS encoding: imod[1] = 0 and A:I:F != 0x0.");

  if (!op2 && !M)
  THROW_EXCEPTION("Invalid CPS encoding: imod = 0x0 and M = 0.");

  if (op2 == 1)
  THROW_EXCEPTION("Invalid CPS encoding: imod = 0x1.");

  if (b15to10)
  THROW_WARNING("Invalid CPS encoding: bit[15:10] != 0x0.");

  if (E)
  THROW_WARNING("Invalid CPS encoding: bit[9] != 0x0.");

  THROW_WARNING("Unimplemented instruction CPS.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::CPS::replicate() const throw() {
  return new CPS(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CPS::get_name() const throw() {
  return "CPS";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CPS::get_id() const throw() {
  return 134;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::CPS::set_params(const unsigned& bitstring) throw() {
  this->op2 = (bitstring & 0xc0000) >> 18;
  this->M = (bitstring & 0x20000) >> 17;
  this->b15to10 = (bitstring & 0xfc00) >> 10;
  this->E = (bitstring & 0x200) >> 9;
  this->A = (bitstring & 0x100) >> 8;
  this->I = (bitstring & 0x80) >> 7;
  this->F = (bitstring & 0x40) >> 6;
  this->mode0 = (bitstring & 0x10) >> 4;
  this->mode1 = (bitstring & 0xf);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CPS::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "CPS ";
  oss << std::showbase << std::hex << this->mode0;
  oss << std::showbase << std::hex << this->mode1;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::DBG::DBG(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // DBG()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::DBG::~DBG() {

} // ~DBG()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::DBG::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit != 15)
  THROW_WARNING("Invalid DBG encoding: rd != 0xF.");

  if (rs_bit)
  THROW_WARNING("Invalid DBG encoding: rs != 0x0.");

  THROW_WARNING("Unimplemented instruction DBG.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::DBG::replicate() const throw() {
  return new DBG(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::DBG::get_name() const throw() {
  return "DBG";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::DBG::get_id() const throw() {
  return 135;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::DBG::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->rm = (bitstring & 0xf);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::DBG::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "DBG R";
  oss << std::showbase << std::hex << this->rm;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::DMB::DMB(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // DMB()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::DMB::~DMB() {

} // ~DMB()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::DMB::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }

  if ((rn_bit != 15) || (rd_bit != 15))
  THROW_WARNING("Invalid DMB encoding: rn|rd != 0xF.");

  if (rs_bit)
  THROW_WARNING("Invalid DMB encoding: rs != 0x0.");

  THROW_WARNING("Unimplemented instruction DMB.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::DMB::replicate() const throw() {
  return new DMB(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::DMB::get_name() const throw() {
  return "DMB";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::DMB::get_id() const throw() {
  return 136;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::DMB::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::DMB::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "DMB ";
  switch(this->rm_bit) {
    case 2: {
      oss << "OSHST";
    break;}
    case 3: {
      oss << "OSH";
    break;}
    case 6: {
      oss << "NSHST";
    break;}
    case 7: {
      oss << "NSH";
    break;}
    case 10: {
      oss << "ISHST";
    break;}
    case 11: {
      oss << "ISH";
    break;}
    case 14: {
      oss << "ST";
    break;}
    case 15: {
      oss << "SY";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::DSB::DSB(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // DSB()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::DSB::~DSB() {

} // ~DSB()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::DSB::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }

  if ((rn_bit != 15) || (rd_bit != 15))
  THROW_WARNING("Invalid DSB encoding: rn|rd != 0xF.");

  if (rs_bit)
  THROW_WARNING("Invalid DSB encoding: rs != 0x0.");

  THROW_WARNING("Unimplemented instruction DSB.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::DSB::replicate() const throw() {
  return new DSB(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::DSB::get_name() const throw() {
  return "DSB";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::DSB::get_id() const throw() {
  return 137;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::DSB::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::DSB::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "DSB ";
  switch(this->rm_bit) {
    case 2: {
      oss << "OSHST";
    break;}
    case 3: {
      oss << "OSH";
    break;}
    case 6: {
      oss << "NSHST";
    break;}
    case 7: {
      oss << "NSH";
    break;}
    case 10: {
      oss << "ISHST";
    break;}
    case 11: {
      oss << "ISH";
    break;}
    case 14: {
      oss << "ST";
    break;}
    case 15: {
      oss << "SY";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::ISB::ISB(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // ISB()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::ISB::~ISB() {

} // ~ISB()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ISB::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }

  if ((rn_bit != 15) || (rd_bit != 15))
  THROW_WARNING("Invalid ISB encoding: rn|rd != 0xF.");

  if (rs_bit)
  THROW_WARNING("Invalid ISB encoding: rs != 0x0.");

  THROW_WARNING("Unimplemented instruction ISB.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::ISB::replicate() const throw() {
  return new ISB(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ISB::get_name() const throw() {
  return "ISB";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::ISB::get_id() const throw() {
  return 138;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::ISB::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::ISB::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "ISB ";
  switch(this->rm_bit) {
    case 15: {
      oss << "SY";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::NOP::NOP(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // NOP()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::NOP::~NOP() {

} // ~NOP()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::NOP::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit != 15)
  THROW_WARNING("Invalid NOP encoding: rd != 0xF.");

  if (rs_bit)
  THROW_WARNING("Invalid NOP encoding: rs != 0x0.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::NOP::replicate() const throw() {
  return new NOP(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::NOP::get_name() const throw() {
  return "NOP";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::NOP::get_id() const throw() {
  return 139;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::NOP::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::NOP::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "NOP";
  oss << std::showbase << std::hex << this->cond;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::PLI_i::PLI_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // PLI_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::PLI_i::~PLI_i() {

} // ~PLI_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::PLI_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }

  if (rd_bit != 15)
  THROW_WARNING("Invalid PLI (immediate/literal) encoding: rd != 0xF.");

  THROW_WARNING("Unimplemented instruction PLI.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::PLI_i::replicate() const throw() {
  return new PLI_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::PLI_i::get_name() const throw() {
  return "PLI_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::PLI_i::get_id() const throw() {
  return 140;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::PLI_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->u = (bitstring & 0x800000) >> 23;
  this->op1a = (bitstring & 0xe0) >> 5;
  this->op1b = (bitstring & 0x10) >> 4;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::PLI_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "PLI [";
  oss << "rn";
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rs_bit;
  oss << std::showbase << std::hex << this->op1a;
  oss << std::showbase << std::hex << this->op1b;
  oss << std::dec << this->rm_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::PLI_r::PLI_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // PLI_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::PLI_r::~PLI_r() {

} // ~PLI_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::PLI_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }

  if (rm_bit == 15)
  THROW_EXCEPTION("Invalid PLI (register) encoding: rm = 0xF.");

  if (rd_bit != 15)
  THROW_WARNING("Invalid PLI (register) encoding: rd != 0xF.");

  THROW_WARNING("Unimplemented instruction PLI.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::PLI_r::replicate() const throw() {
  return new PLI_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::PLI_r::get_name() const throw() {
  return "PLI_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::PLI_r::get_id() const throw() {
  return 141;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::PLI_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->u = (bitstring & 0x800000) >> 23;
  this->op1a = (bitstring & 0xe0) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::PLI_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "PLI [";
  oss << "rn";
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::PLD_i::PLD_i(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // PLD_i()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::PLD_i::~PLD_i() {

} // ~PLD_i()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::PLD_i::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }

  THROW_WARNING("Unimplemented instruction PLD.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::PLD_i::replicate() const throw() {
  return new PLD_i(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::PLD_i::get_name() const throw() {
  return "PLD_i";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::PLD_i::get_id() const throw() {
  return 142;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::PLD_i::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->u = (bitstring & 0x800000) >> 23;
  this->r = (bitstring & 0x400000) >> 22;
  this->op1a = (bitstring & 0xe0) >> 5;
  this->op1b = (bitstring & 0x10) >> 4;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::PLD_i::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "PLD";
  switch(this->r) {
    case 0: {
      oss << "W";
    break;}
  }
  oss << " [";
  oss << "rn";
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rs_bit;
  oss << std::showbase << std::hex << this->op1a;
  oss << std::showbase << std::hex << this->op1b;
  oss << std::dec << this->rm_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::PLD_r::PLD_r(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // PLD_r()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::PLD_r::~PLD_r() {

} // ~PLD_r()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::PLD_r::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }

  if (!r && (rn_bit == 15))
  THROW_EXCEPTION("Invalid PLD (register) encoding: r =0 and rn = 0xF.");

  if (rm_bit == 15)
  THROW_EXCEPTION("Invalid PLD (register) encoding: rm = 0xF.");

  if (rd_bit != 15)
  THROW_WARNING("Invalid PLD (register) encoding: rd != 0xF.");

  THROW_WARNING("Unimplemented instruction PLD.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::PLD_r::replicate() const throw() {
  return new PLD_r(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::PLD_r::get_name() const throw() {
  return "PLD_r";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::PLD_r::get_id() const throw() {
  return 143;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::PLD_r::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->u = (bitstring & 0x800000) >> 23;
  this->r = (bitstring & 0x400000) >> 22;
  this->op1a = (bitstring & 0xe0) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::PLD_r::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "PLD";
  switch(this->r) {
    case 0: {
      oss << "W";
    break;}
  }
  oss << " [";
  oss << "rn";
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::RFE::RFE(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // RFE()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::RFE::~RFE() {

} // ~RFE()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::RFE::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }

  if (rn_bit == 15)
  THROW_EXCEPTION("Invalid RFE encoding: rn = 0xF.");

  if (imm0)
  THROW_WARNING("Invalid RFE encoding: rd != 0x0.");

  if (imm1 != 0xA)
  THROW_WARNING("Invalid RFE encoding: rs != 0xA.");

  if (imm1)
  THROW_WARNING("Invalid RFE encoding: op1 != 0x0.");

  if (imm2)
  THROW_WARNING("Invalid RFE encoding: rm != 0x0.");

  THROW_WARNING("Unimplemented instruction RFE.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::RFE::replicate() const throw() {
  return new RFE(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::RFE::get_name() const throw() {
  return "RFE";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::RFE::get_id() const throw() {
  return 144;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::RFE::set_params(const unsigned& bitstring) throw() {
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm0 = (bitstring & 0xf000) >> 12;
  this->imm1 = (bitstring & 0xf00) >> 8;
  this->op1 = (bitstring & 0xf0) >> 4;
  this->imm2 = (bitstring & 0xf);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::RFE::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "RFE";
  switch(this->u) {
    case 0: {
      oss << "D";
    break;}
    case 1: {
      oss << "I";
    break;}
  }
  switch(this->p) {
    case 0: {
      oss << "A";
    break;}
    case 1: {
      oss << "B";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rn_bit;
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::SETEND::SETEND(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // SETEND()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::SETEND::~SETEND() {

} // ~SETEND()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SETEND::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }

  if (op2)
  THROW_WARNING("Invalid SETEND encoding: bit[19:18] != 0x0.");

  if (M)
  THROW_WARNING("Invalid SETEND encoding: bit[17] != 0.");

  if (b15to10)
  THROW_WARNING("Invalid SETEND encoding: bit[15:9] != 0x0.");

  if (A)
  THROW_WARNING("Invalid SETEND encoding: bit[8] != 0.");

  if (mode1)
  THROW_WARNING("Invalid SETEND encoding: bit[3:0] != 0x0.");

  THROW_WARNING("Unimplemented instruction SETEND.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::SETEND::replicate() const throw() {
  return new SETEND(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SETEND::get_name() const throw() {
  return "SETEND";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SETEND::get_id() const throw() {
  return 145;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::SETEND::set_params(const unsigned& bitstring) throw()
{
  this->op2 = (bitstring & 0xc0000) >> 18;
  this->M = (bitstring & 0x20000) >> 17;
  this->b15to10 = (bitstring & 0xfc00) >> 10;
  this->E = (bitstring & 0x200) >> 9;
  this->A = (bitstring & 0x100) >> 8;
  this->mode1 = (bitstring & 0xf);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SETEND::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "SETEND ";
  switch(this->E) {
    case 0: {
      oss << "LE";
    break;}
    case 1: {
      oss << "BE";
    break;}
  }
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::SEV::SEV(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // SEV()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::SEV::~SEV() {

} // ~SEV()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SEV::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit != 15)
  THROW_WARNING("Invalid SEV encoding: rd != 0xF.");

  if (rs_bit)
  THROW_WARNING("Invalid SEV encoding: rs != 0x0.");

  THROW_WARNING("Unimplemented instruction SEV.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::SEV::replicate() const throw() {
  return new SEV(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SEV::get_name() const throw() {
  return "SEV";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SEV::get_id() const throw() {
  return 146;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::SEV::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SEV::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "SEV";
  oss << std::showbase << std::hex << this->cond;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::SRS::SRS(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles) {

} // SRS()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::SRS::~SRS() {

} // ~SRS()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SRS::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }

  if (rn_bit != 0xD)
  THROW_WARNING("Invalid SRS encoding: rn != 0xD.");

  if (imm0)
  THROW_WARNING("Invalid SRS encoding: rd != 0x0.");

  if (imm1 != 0x5)
  THROW_WARNING("Invalid SRS encoding: rs != 0x5.");

  if (imm1 & 0xE)
  THROW_WARNING("Invalid SRS encoding: op1[3:1] != 0x0.");

  unsigned mode = ((imm1 << 4) & 0x10) | imm2;

  THROW_WARNING("Unimplemented instruction SRS.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::SRS::replicate() const throw() {
  return new SRS(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SRS::get_name() const throw() {
  return "SRS";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SRS::get_id() const throw() {
  return 147;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::SRS::set_params(const unsigned& bitstring) throw() {
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm0 = (bitstring & 0xf000) >> 12;
  this->imm1 = (bitstring & 0xf00) >> 8;
  this->op1 = (bitstring & 0xf0) >> 4;
  this->imm2 = (bitstring & 0xf);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SRS::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "SRS";
  switch(this->u) {
    case 0: {
      oss << "D";
    break;}
    case 1: {
      oss << "I";
    break;}
  }
  switch(this->p) {
    case 0: {
      oss << "A";
    break;}
    case 1: {
      oss << "B";
    break;}
  }
  oss << " ";
  oss << "SP";
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->imm2;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::SVC::SVC(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // SVC()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::SVC::~SVC() {

} // ~SVC()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SVC::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  // CallSupervisor(swi_number);
  // Calls the Supervisor, with appropriate trapping etc.
  /*// Will be taken to Hyp mode so must set HSR.
  if ((CPSR[CPSR_M] == (unsigned)EXECMODE::HYP)
  || (HaveVirtExt() && !IsSecure() && (CPSR[CPSR_M] == (unsigned)EXECMODE::USR)
  && HCR[HCR_TGE] == 1)) {
    unsigned HSR_value = 0;
    if (CurrentCond(this->bitstring) cond == 0xE) {
      HSR_value |= (swi_number & 0xFFFF);
    }
    WriteHSR(0x11, HSR_value);
  }*/

  // TakeSVCException();
  // Determine return information. SPSR is to be the current CPSR, after changing
  // the IT[] bits to give them the correct values for the following instruction,
  // and LR is to be the current PC minus 2 for Thumb or 4 for ARM, to change
  // the PC offsets of 4 or 8 respectively from the address of the current
  // instruction into the required address of the next instruction, the SVC
  // instruction having size 2 bytes for Thumb or 4 bytes for ARM.

  ITAdvance();
  unsigned LR_value = ((CPSR[CPSR_T] == 1)? PC-2 : PC-4);
  unsigned SPSR_value = CPSR;
  unsigned vect_offset = 8;

  /* TODO
  bool take_to_hyp = false, route_to_hyp = false;
  // Check whether to take exception to Hyp mode: If in Hyp mode, stay in Hyp
  // mode.
  take_to_hyp = (HaveVirtExt() && HaveSecurityExt() && SCR[SCR_NS] == 1 &&
  CPSR[CPSR_M] == (unsigned)EXECMODE::HYP);

  // If HCR.TGE is set to 1, take to Hyp mode through Hyp Trap vector.
  route_to_hyp = (HaveVirtExt() && HaveSecurityExt() && !IsSecure() && HCR[HCR_TGE]
  == 1 && CPSR[CPSR_M] == (unsigned)EXECMODE::USR);

  // if HCR.TGE == '1' and in a Non-secure PL1 mode, the effect is UNPREDICTABLE

  if (take_to_hyp) {
    EnterHypMode(SPSR_value, LR_value, vect_offset);
  } else if (route_to_hyp) {
    EnterHypMode(SPSR_value, LR_value, 20);
  } else {
    // Enter Supervisor mode, and ensure Secure state if initially in Monitor
    // mode. This affects the Banked versions of various registers accessed
    // later in the code.
    if (CPSR[CPSR_M] == (unsigned)EXECMODE::MON) SCR[SCR_NS] = 0;*/

    // Make further CPSR changes: IRQs disabled, IT state reset, instruction set
    // and endianness set to SCTLR-configured values.
    //CPSR &= 0xF9FF03FF;
    CPSR[CPSR_IT72] = CPSR[CPSR_IT10] = 0;

    //CPSR &= 0xFEFFFFFF;
    CPSR[CPSR_J] = 0;

    //CPSR[CPSR_E] = SCTLR[SCTLR_EE]; // EE=0: little-endian; EE=1: big-endian

    // Disable normal interrupts.
    //CPSR |= 0x00000080;
    CPSR[CPSR_I] = 1;

    // Execute in ARM state.
    //CPSR &= 0xFFFFFFDF
    CPSR[CPSR_T] = 0;//SCTLR[SCTLR_TE]; // TE=0: ARM; TE=1: Thumb

    // Enter supervisor mode.
    //CPSR &= 0xFFFFFFF0; CPSR |= 0x00000003;
    CPSR[CPSR_M] = (unsigned)EXECMODE::SVC;

    // Write return information to registers.
    SPSR[get_spsr_idx(CPSR[CPSR_M])] = SPSR_value;
    Rmode(14, CPSR[CPSR_M], true, LR_value);

    // Branch to SVC vector.
    PC = ExcVectorBase() + vect_offset;
  //}
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::SVC::replicate() const throw() {
  return new SVC(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SVC::get_name() const throw() {
  return "SVC";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SVC::get_id() const throw() {
  return 148;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::SVC::set_params(const unsigned& bitstring) throw() {
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->swi_number = (bitstring & 0xffffff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SVC::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "SVC";
  oss << std::showbase << std::hex << this->cond;
  oss << " ";
  oss << std::showbase << std::hex << this->swi_number;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::UDF::UDF(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // UDF()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::UDF::~UDF() {

} // ~UDF()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::UDF::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  THROW_WARNING("Unimplemented instruction UDF.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::UDF::replicate() const throw() {
  return new UDF(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::UDF::get_name() const throw() {
  return "UDF";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::UDF::get_id() const throw() {
  return 149;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::UDF::set_params(const unsigned& bitstring) throw() {
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->imm0 = (bitstring & 0xf0000) >> 16;
  this->imm1 = (bitstring & 0xf000) >> 12;
  this->imm2 = (bitstring & 0xf00) >> 8;
  this->imm3 = (bitstring & 0xf);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::UDF::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "UDF";
  oss << std::showbase << std::hex << this->cond;
  oss << " ";
  oss << std::showbase << std::hex << this->imm0;
  oss << std::showbase << std::hex << this->imm1;
  oss << std::showbase << std::hex << this->imm2;
  oss << std::showbase << std::hex << this->imm3;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::WFE::WFE(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // WFE()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::WFE::~WFE() {

} // ~WFE()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::WFE::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit != 15)
  THROW_WARNING("Invalid WFE encoding: rd != 0xF.");

  if (rs_bit)
  THROW_WARNING("Invalid WFE encoding: rs != 0x0.");

  THROW_WARNING("Unimplemented instruction WFE.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::WFE::replicate() const throw() {
  return new WFE(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::WFE::get_name() const throw() {
  return "WFE";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::WFE::get_id() const throw() {
  return 150;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::WFE::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::WFE::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "WFE";
  oss << std::showbase << std::hex << this->cond;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::WFI::WFI(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // WFI()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::WFI::~WFI() {

} // ~WFI()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::WFI::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit != 15)
  THROW_WARNING("Invalid WFI encoding: rd != 0xF.");

  if (rs_bit)
  THROW_WARNING("Invalid WFI encoding: rs != 0x0.");

  THROW_WARNING("Unimplemented instruction WFI.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::WFI::replicate() const throw() {
  return new WFI(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::WFI::get_name() const throw() {
  return "WFI";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::WFI::get_id() const throw() {
  return 151;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::WFI::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::WFI::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "WFI";
  oss << std::showbase << std::hex << this->cond;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::YIELD::YIELD(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // YIELD()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::YIELD::~YIELD() {

} // ~YIELD()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::YIELD::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit != 15)
  THROW_WARNING("Invalid YIELD encoding: rd != 0xF.");

  if (rs_bit)
  THROW_WARNING("Invalid YIELD encoding: rs != 0x0.");

  THROW_WARNING("Unimplemented instruction YIELD.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::YIELD::replicate() const throw() {
  return new YIELD(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::YIELD::get_name() const throw() {
  return "YIELD";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::YIELD::get_id() const throw() {
  return 152;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::YIELD::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::YIELD::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "YIELD";
  oss << std::showbase << std::hex << this->cond;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::SMC::SMC(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // SMC()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::SMC::~SMC() {

} // ~SMC()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SMC::behavior() {
  this->total_instr_cycles = 0;
  {
    unsigned num_cycles = 0;

    // Check instruction set mode.
    // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
    // JT=11: ThumbEE (16-bit)
    if (CPSR[CPSR_T]) {
      PC +=2;
    } else if (CPSR[CPSR_J]) {
      PC += 1;
    } else {
      PC +=4;
    }

    this->total_cycles += num_cycles;
  }
  this->total_cycles += ConditionPassed(this->cond);

  THROW_WARNING("Unimplemented instruction SMC.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::SMC::replicate() const throw() {
  return new SMC(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SMC::get_name() const throw() {
  return "SMC";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::SMC::get_id() const throw() {
  return 153;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::SMC::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::SMC::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "SMC";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::CDP::CDP(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // CDP()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::CDP::~CDP() {

} // ~CDP()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CDP::behavior() {
  this->total_instr_cycles = 0;
  this->total_cycles += ConditionPassed(this->cond);

  THROW_WARNING("Unimplemented instruction CDP.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::CDP::replicate() const throw() {
  return new CDP(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CDP::get_name() const throw() {
  return "CDP";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::CDP::get_id() const throw() {
  return 154;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::CDP::set_params(const unsigned& bitstring) throw() {
  this->cprn_bit = (bitstring & 0xf0000) >> 16;
  this->cprn.set_alias(CPREGS[this->cprn_bit]);
  this->cprm_bit = (bitstring & 0xf);
  this->cprm.set_alias(CPREGS[this->cprm_bit]);
  this->cprd_bit = (bitstring & 0xf000) >> 12;
  this->cprd.set_alias(CPREGS[this->cprd_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->op0 = (bitstring & 0xf00000) >> 20;
  this->cpnum = (bitstring & 0xf00) >> 8;
  this->op1 = (bitstring & 0xe0) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::CDP::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "CDP";
  oss << std::showbase << std::hex << this->cond;
  oss << " ";
  oss << std::showbase << std::hex << this->cpnum;
  oss << ", ";
  oss << std::showbase << std::hex << this->op0;
  oss << ", ";
  oss << std::dec << this->cprd_bit;
  oss << ", ";
  oss << std::dec << this->cprn_bit;
  oss << ", ";
  oss << std::dec << this->cprm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->op1;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::LDC::LDC(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // LDC()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::LDC::~LDC() {

} // ~LDC()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDC::behavior() {
  this->total_instr_cycles = 0;
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) && (w || (!p && (CurrentInstrSet() != (unsigned)(ISMODE::ARM)))))
  THROW_EXCEPTION("Invalid LDC/LDC2 (literal) encoding: w = 1 or (p = 0 and current instruction set != ARM).");

  THROW_WARNING("Unimplemented instruction LDC.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::LDC::replicate() const throw() {
  return new LDC(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDC::get_name() const throw() {
  return "LDC";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::LDC::get_id() const throw() {
  return 155;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::LDC::set_params(const unsigned& bitstring) throw() {
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cprd_bit = (bitstring & 0xf000) >> 12;
  this->cprd.set_alias(CPREGS[this->cprd_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->d = (bitstring & 0x400000) >> 22;
  this->w = (bitstring & 0x200000) >> 21;
  this->cpnum = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::LDC::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "LDC";
  switch(this->cond) {
    case 15: {
      oss << "2";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " ";
  oss << std::showbase << std::hex << this->cpnum;
  oss << ", ";
  oss << std::dec << this->cprd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::STC::STC(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // STC()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::STC::~STC() {

} // ~STC()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STC::behavior() {
  this->total_instr_cycles = 0;
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) && (w || (CurrentInstrSet() != (unsigned)(ISMODE::ARM))))
  THROW_EXCEPTION("Invalid STC/STC2 encoding: rn = 0xF and (w = 1 or current instruction set != ARM).");

  THROW_WARNING("Unimplemented instruction STC.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::STC::replicate() const throw() {
  return new STC(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STC::get_name() const throw() {
  return "STC";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::STC::get_id() const throw() {
  return 156;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::STC::set_params(const unsigned& bitstring) throw() {
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cprd_bit = (bitstring & 0xf000) >> 12;
  this->cprd.set_alias(CPREGS[this->cprd_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->d = (bitstring & 0x400000) >> 22;
  this->w = (bitstring & 0x200000) >> 21;
  this->cpnum = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::STC::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "STC";
  switch(this->cond) {
    case 15: {
      oss << "2";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " ";
  oss << std::showbase << std::hex << this->cpnum;
  oss << ", ";
  oss << std::dec << this->cprd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::MCR::MCR(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // MCR()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::MCR::~MCR() {

} // ~MCR()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MCR::behavior() {
  this->total_instr_cycles = 0;
  this->total_cycles += ConditionPassed(this->cond);

  if (rd_bit == 15)
  THROW_EXCEPTION("Invalid MCR/MCR2 encoding: rd = 0xF.");

  if ((rd_bit == 13) && (CurrentInstrSet() != (unsigned)(ISMODE::ARM)))
  THROW_EXCEPTION("Invalid MCR/MCR2 encoding: rd = 0xD and current instruction set != ARM.");

  THROW_WARNING("Unimplemented instruction MCR.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::MCR::replicate() const throw() {
  return new MCR(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MCR::get_name() const throw() {
  return "MCR";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MCR::get_id() const throw() {
  return 157;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::MCR::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(CPREGS[this->rn_bit]);
  this->cprm_bit = (bitstring & 0xf);
  this->cprm.set_alias(CPREGS[this->cprm_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->op0 = (bitstring & 0xe00000) >> 21;
  this->cpnum = (bitstring & 0xf00) >> 8;
  this->op1 = (bitstring & 0xe0) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MCR::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "MCR";
  switch(this->cond) {
    case 15: {
      oss << "2";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " ";
  oss << std::showbase << std::hex << this->cpnum;
  oss << ", ";
  oss << std::showbase << std::hex << this->op1;
  oss << ", ";
  oss << std::dec << this->rd_bit;
  oss << ", ";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::dec << this->cprm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::MCRR::MCRR(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // MCRR()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::MCRR::~MCRR() {

} // ~MCRR()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MCRR::behavior() {
  this->total_instr_cycles = 0;
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15))
  THROW_EXCEPTION("Invalid MCRR/MCRR2 encoding: rn|rd = 0xF.");

  if (((rn_bit == 13) || (rd_bit == 13)) && (CurrentInstrSet() != (unsigned)(ISMODE::ARM)))
  THROW_EXCEPTION("Invalid MCRR/MCRR2 encoding: rn|rd = 0xD and current instruction set != ARM.");

  THROW_WARNING("Unimplemented instruction MCRR.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::MCRR::replicate() const throw() {
  return new MCRR(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MCRR::get_name() const throw() {
  return "MCRR";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MCRR::get_id() const throw() {
  return 158;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::MCRR::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cprm_bit = (bitstring & 0xf);
  this->cprm.set_alias(CPREGS[this->cprm_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->cpnum = (bitstring & 0xf00) >> 8;
  this->op1 = (bitstring & 0xe0) >> 5;
  this->e = (bitstring & 0x10) >> 4;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MCRR::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "MCRR";
  switch(this->cond) {
    case 15: {
      oss << "2";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " ";
  oss << std::showbase << std::hex << this->cpnum;
  oss << ", ";
  oss << std::showbase << std::hex << this->op1;
  oss << ", ";
  oss << std::dec << this->rd_bit;
  oss << ", ";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::dec << this->cprm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::MRC::MRC(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // MRC()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::MRC::~MRC() {

} // ~MRC()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MRC::behavior() {
  this->total_instr_cycles = 0;
  this->total_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 13) && (CurrentInstrSet() != (unsigned)(ISMODE::ARM)))
  THROW_EXCEPTION("Invalid MRC/MRC2 encoding: rd = 0xD and current instruction set != ARM.");

  THROW_WARNING("Unimplemented instruction MRC.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::MRC::replicate() const throw() {
  return new MRC(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MRC::get_name() const throw() {
  return "MRC";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MRC::get_id() const throw() {
  return 159;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::MRC::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(CPREGS[this->rn_bit]);
  this->cprm_bit = (bitstring & 0xf);
  this->cprm.set_alias(CPREGS[this->cprm_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->op0 = (bitstring & 0xe00000) >> 21;
  this->cpnum = (bitstring & 0xf00) >> 8;
  this->op1 = (bitstring & 0xe0) >> 5;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MRC::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "MRC";
  switch(this->cond) {
    case 15: {
      oss << "2";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " ";
  oss << std::showbase << std::hex << this->cpnum;
  oss << ", ";
  oss << std::showbase << std::hex << this->op1;
  oss << ", ";
  oss << std::dec << this->rd_bit;
  oss << ", ";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::dec << this->cprm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::MRRC::MRRC(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles) :
  Instruction(R, data_memory, total_cycles),
  ConditionPassedOp(R, data_memory, total_cycles) {

} // MRRC()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::MRRC::~MRRC() {

} // ~MRRC()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MRRC::behavior() {
  this->total_instr_cycles = 0;
  this->total_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15))
  THROW_EXCEPTION("Invalid MRRC/MRRC2 encoding: rn|rd = 0xF.");

  if (rn_bit == rd_bit)
  THROW_EXCEPTION("Invalid MRRC/MRRC2 encoding: rn = rd.");

  if (((rn_bit == 13) || (rd_bit == 13)) && (CurrentInstrSet() != (unsigned)(ISMODE::ARM)))
  THROW_EXCEPTION("Invalid MRRC/MRRC2 encoding: rn|rd = 0xD and current instruction set != ARM.");

  THROW_WARNING("Unimplemented instruction MRRC.");
  return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::MRRC::replicate() const throw() {
  return new MRRC(R, data_memory, total_cycles);
} // replicate()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MRRC::get_name() const throw() {
  return "MRRC";
} // get_name()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::MRRC::get_id() const throw() {
  return 160;
} // get_id()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::MRRC::set_params(const unsigned& bitstring) throw() {
  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cprm_bit = (bitstring & 0xf);
  this->cprm.set_alias(CPREGS[this->cprm_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->cpnum = (bitstring & 0xf00) >> 8;
  this->op1 = (bitstring & 0xe0) >> 5;
  this->e = (bitstring & 0x10) >> 4;
} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::MRRC::get_mnemonic() const throw() {
  std::ostringstream oss (std::ostringstream::out);
  oss << "MRRC";
  switch(this->cond) {
    case 15: {
      oss << "2";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " ";
  oss << std::showbase << std::hex << this->cpnum;
  oss << ", ";
  oss << std::showbase << std::hex << this->op1;
  oss << ", ";
  oss << std::dec << this->rd_bit;
  oss << ", ";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::dec << this->cprm_bit;
  return oss.str();
} // get_mnemonic()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::IRQIntrInstruction::IRQIntrInstruction(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles,
    bool& IRQ) :
  Instruction(R, data_memory, total_cycles),
  IRQ(IRQ) {

} // IRQIntrInstruction()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::IRQIntrInstruction::~IRQIntrInstruction() {

} // ~IRQIntrInstruction()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::IRQIntrInstruction::behavior() {
  this->total_instr_cycles = 0;

  /// B1-1172 Processor modes for taking exceptions.
  /// Determine the mode to which the exception must be taken.

  /// B1-1171 Link values saved on exception entry.
  /// Save link value, indicating the preferred return address for the exception,
  /// depending on exception type, PL1/PL2 taken, current instruction set state.

  /// Save CPSR in the SPSR for the mode to which the exception must be taken.
  CPSR[CPSR_I] = 0;
  // Save current PC.
  LR_IRQ = PC;
  // Save current PSR.
  SPSR_IRQ = CPSR;
  // Switch register bank.
  REGS[13].update_alias(SP_IRQ);
  REGS[14].update_alias(LR_IRQ);
  // Create the new PSR: Reset T, set I and mask (IRQ => 10010).
  CPSR = (CPSR & 0xFFFFFFD0) | 0x00000092;

  /// B1-1181 Processor state on exception entry.
  /// Update the CPSR with new context information for the exception handler.
  /// * Setting CPSR.M to the processor mode to which the exception is taken.
  /// * Setting the appropriate CPSR mask bits. This can disable the corresponding
  /// exceptions, preventing uncontrolled nesting of exception handlers.
  /// * Setting the instruction set state to the state required for exception
  /// entry.
  /// * Setting the endianness to the required value for exception entry.
  /// * Clearing the CPSR.IT[7:0] bits to 0.

  /// In an implementation that includes the Security Exceptions:
  /// * if the exception taken from Monitor mode, clear SCR.NS to 0
  /// * otherwise, leave SCR.NS unchanged.

  /// B1-1164 Exception vectors and the exception base address.
  /// Load the appropriate exception vector into the PC.
  /// Continue execution from the address held in the PC.
  PC = 0x18;return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::IRQIntrInstruction::replicate() const throw()
{
  return new IRQIntrInstruction(R, data_memory, total_cycles, this->IRQ);
} // replicate()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::IRQIntrInstruction::set_params(const unsigned& bitstring)
throw() {

} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::IRQIntrInstruction::get_name() const throw() {
  return "IRQIntrInstruction";
} // get_name()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::IRQIntrInstruction::get_mnemonic() const
throw() {
  return "IRQ";
} // get_mnemonic()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::IRQIntrInstruction::get_id() const throw() {
  return (unsigned)-1;
} // get_id()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

core_armcortexa9_lt::FIQIntrInstruction::FIQIntrInstruction(
    Registers& R,
    LocalMemory& data_memory,
    unsigned& total_cycles,
    bool& FIQ) :
  Instruction(R, data_memory, total_cycles),
  FIQ(FIQ) {

} // FIQIntrInstruction()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::FIQIntrInstruction::~FIQIntrInstruction() {

} // ~FIQIntrInstruction()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::FIQIntrInstruction::behavior() {
  this->total_instr_cycles = 0;

  CPSR[CPSR_F] = 0;
  // Save current PC.
  LR_FIQ = PC;
  // Save current PSR.
  SPSR_FIQ = CPSR;
  // Switch register bank.
  REGS[8].update_alias(R8_FIQ);
  REGS[9].update_alias(R9_FIQ);
  REGS[10].update_alias(R10_FIQ);
  REGS[11].update_alias(R11_FIQ);
  REGS[12].update_alias(R12_FIQ);
  REGS[13].update_alias(SP_FIQ);
  REGS[14].update_alias(LR_FIQ);
  // Create the new PSR: Reset T, set I, F and mask (FIQ => 10001).
  CPSR = (CPSR & 0xFFFFFFD0) | 0x000000D1;
  // Update the PC.
  PC = 0x1C;return this->total_instr_cycles;
} // behavior()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::FIQIntrInstruction::replicate() const throw()
{
  return new FIQIntrInstruction(R, data_memory, total_cycles, this->FIQ);
} // replicate()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::FIQIntrInstruction::set_params(const unsigned& bitstring)
throw() {

} // set_params()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::FIQIntrInstruction::get_name() const throw() {
  return "FIQIntrInstruction";
} // get_name()

/// ----------------------------------------------------------------------------

std::string core_armcortexa9_lt::FIQIntrInstruction::get_mnemonic() const
throw() {
  return "FIQ";
} // get_mnemonic()

/// ----------------------------------------------------------------------------

unsigned core_armcortexa9_lt::FIQIntrInstruction::get_id() const throw() {
  return (unsigned)-1;
} // get_id()

/// ----------------------------------------------------------------------------


/// ****************************************************************************

