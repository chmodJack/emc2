/***************************************************************************//**
*
*           _/       _/_/_/      _/         _/
*         _/_/      _/    _/    _/_/      __/
*       _/  _/     _/    _/    _/ _/    _/_/
*     _/_/_/_/    _/_/_/      _/  _/  _/ _/
*   _/      _/   _/    _/    _/   _/_/  _/
* _/        _/  _/      _/  _/    _/   _/
*
* @brief    This file is part of the SoCRocket ARM ISS generated by TRAP.
* @details  This SystemC model was automatically generated by running
*           $ python ARMArch.py
*           Please refer to the ARM TRAP source files for documentation.
* @author   Lillian Tadros (Technische Universitaet Dortmund)
* @date     2015-2016 Technische Universitaet Dortmund
*
*
* (c) 2014-2016
* Technische Universitaet Dortmund
* Institut fuer Roboterforschung
* Project Embedded Multi-Core Systems for Mixed Criticality
* Applications in Dynamic and Changeable Real-time Environments (EMC2)
*
*
* This file is part of ARMCortexA9.
*
* ARMCortexA9 is free software; you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License as
* published by the Free Software Foundation; either version 3 of the
* License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Affero General Public License for more details.
*
* You should have received a copy of the GNU Affero General Public
* License along with this program; if not, write to the
* Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
* or see <http://www.gnu.org/licenses/>.
*
*******************************************************************************/

#include "registers.hpp"
#include "memory.hpp"
#include "instructions.hpp"

#include <modules/instruction.hpp>
#include <common/report.hpp>
#include <string>
#include <modules/register.hpp>
#include <sstream>


using namespace core_armcortexa9_funclt;

core_armcortexa9_funclt::Instruction::Instruction(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  R(R),
  instr_memory(instr_memory),
  data_memory(data_memory) {

  this->num_instr_cycles = 0;
} // Instruction()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Instruction::behavior() {

  return 0;
} // behavior()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Instruction::BranchWritePC(unsigned addr) {


  /// Writing an address to the PC causes either a simple branch to that address
  /// or an interworking branch that also selects the instruction set to execute
  /// after the branch. A simple branch is performed by the BranchWritePC()
  /// function.
  switch(CurrentInstrSet()) {
    case (unsigned)(ISMODE::ARM):
    // ARM mode 0x0, word align
    PC = addr & 0xFFFFFFFC;
    break;
    case (unsigned)(ISMODE::THUMB):
    // Thumb mode 0x1, half-word align
    PC = addr & 0xFFFFFFFE;
    break;
    case (unsigned)(ISMODE::JAZELLE):
    // Jazelle mode 0x2, no alignment
    if (JazelleAcceptsExecution())
    PC = addr;
    else
    PC = addr & 0xFFFFFFFC;
    break;
    case (unsigned)(ISMODE::THUMBEE):
    // ThumbEE mode 0x3, half-word align
    PC = addr & 0xFFFFFFFE;
    break;
    default:
    THROW_EXCEPTION("Invalid instruction set mode switch " << ios::hex <<
    CurrentInstrSet() << " while updating the PC.");
    break;
  }
} // BranchWritePC()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Instruction::BXWritePC(unsigned addr) {


  // ThumbEE -> ThumbEE
  if (CurrentInstrSet() != 0x3) {
    // ARM/Thumb/Jazelle -> Thumb
    if (addr & 0x1) {
      /* TODO:
      CPSR[CPSR_T] = 0x1;
      CPSR[CPSR_J] = 0x0;
      REGS[15].update_alias(RB[15], 4); */
      THROW_WARNING("Thumb Instruction Set unimplemented.");
      // ARM/Thumb/Jazelle -> ARM
    } else if (!(addr & 0x2)) {
      CPSR[CPSR_J] = CPSR[CPSR_T] = 0x0;
      REGS[15].update_alias(RB[15], 8);
    }
  }

  BranchWritePC(addr);
} // BXWritePC()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Instruction::Rmode(
    unsigned reg_index,
    unsigned mode,
    bool write,
    unsigned value) {


  if ((reg_index < 0) || (reg_index > 14))
  THROW_EXCEPTION("Invalid register " << reg_index << ".");
  /* TODO:
  if (!valid_psr_mode(mode))
  THROW_EXCEPTION("Invalid execution mode " << mode << ".");

  if ((mode == (unsigned)EXECMODE::MON) && !IsSecure())
  THROW_EXCEPTION("Attempted use of Monitor mode in non-secure state.");

  if ((mode == (unsigned)EXECMODE::FIQ) && !IsSecure() && NSACR[NSACR_RFR] == 1)
  THROW_EXCEPTION("Attempted use of FIQ registers reserved by the Security Extensions.");

  if ((reg_index == 13) && write && (value & 0x3) && (CurrentInstrSet() !=
  (unsigned)(ISMODE::ARM)))
  THROW_EXCEPTION("Writes of non word-aligned values to SP are only permitted in ARM state.");*/

  if ((reg_index > 12) && (reg_index < 15)) {
    switch(mode) {
      case (unsigned)EXECMODE::USR:
      case (unsigned)EXECMODE::SYS:
      // RB[0-12]:  R0_usr..R12_usr
      // RB[13-15]: SP_usr, LR_usr, PC
      break;
      case (unsigned)EXECMODE::FIQ:
      // RB[18-24]: R8_fiq..R12_fiq, SP_fiq, LR_fiq
      reg_index += 10;
      break;
      case (unsigned)EXECMODE::IRQ:
      // RB[16-17]: SP_irq, LR_irq
      reg_index += 3;
      break;
      case (unsigned)EXECMODE::SVC:
      // RB[29-30]: SP_svc, LR_svc
      reg_index += 16;
      break;
      case (unsigned)EXECMODE::MON:
      // RB[33-34]: SP_mon, LR_mon
      reg_index += 20;
      break;
      case (unsigned)EXECMODE::ABT:
      // RB[27-28]: SP_abt, LR_abt
      reg_index += 14;
      break;
      case (unsigned)EXECMODE::HYP:
      // RB[31-32]: SP_hyp, ELR_hyp
      // NOTE: HYP mode has access to LR_usr (as LR) as well as ELR_hyp
      if (reg_index == 13)
      reg_index += 18;
      break;
      case (unsigned)EXECMODE::UND:
      // RB[25-26]: SP_und, LR_und
      reg_index += 12;
      break;
      default:
      THROW_EXCEPTION("Invalid execution mode " << next_mode << " while updating the register banks.");
      break;
    }
  } else if ((reg_index > 7) && (reg_index < 15) && (mode == (unsigned)EXECMODE::FIQ))
  {
    // FIQ mode
    // RB[18-24]: R8_fiq..R12_fiq, SP_fiq, LR_fiq
    reg_index += 10;
  }

  if (write) {
    RB[reg_index] = value;
    return 0;
  } else return (RB[reg_index]);
} // Rmode()

// -----------------------------------------------------------------------------

bool core_armcortexa9_funclt::Instruction::valid_banked_reg_access(unsigned
sys_mode) const {


  unsigned cur_mode = CPSR[CPSR_M];
  if (!(valid_psr_mode(cur_mode)))
  return false;

  bool result = true;

  switch((sys_mode >> 3) & 0x3) {
    case 0x0:
    // Banked USR registers
    switch (sys_mode & 0x7) {
      case 0x5:
      // Banked SP_USR register: Inaccessible from SYS mode
      if (cur_mode == (unsigned)EXECMODE::SYS) result = false;
      break;
      case 0x6:
      // Banked LR_USR register: Inaccessible from SYS or HYP
      if ((cur_mode == (unsigned)EXECMODE::HYP) || (cur_mode == (unsigned)EXECMODE::SYS))
      result = false;
      break;
      case 0x7:
      // Undefined sys_mode
      result = false;
      break;
      default:
      // Banked R8-R12: Accessible only in FIQ mode
      if (cur_mode != (unsigned)EXECMODE::FIQ) result = false;
    } break;
    case 0x1:
    // Banked FIQ registers
    if (((sys_mode & 0x7) == 0x7) || (cur_mode == (unsigned)EXECMODE::FIQ) /*
    TODO: || ((NSACR[NSACR_RFR] == 1) && (!IsSecure())) */) {
      result = false;
    } break;
    case 0x2:
    // Banked IRQ/SVC/ABT/UND registers
    switch (sys_mode & 0x7) {
      case 0x0:
      case 0x1:
      // Banked LR_IRQ / SP_IRQ registers: Inaccessible from IRQ mode
      if (cur_mode == (unsigned)EXECMODE::IRQ) result = false;
      break;
      case 0x2:
      case 0x3:
      // Banked LR_SVC / SP_SVC registers: Inaccessible from SVC mode
      if (cur_mode == (unsigned)EXECMODE::SVC) result = false;
      break;
      case 0x4:
      case 0x5:
      // Banked LR_ABT / SP_ABT registers: Inaccessible from ABT mode
      if (cur_mode == (unsigned)EXECMODE::ABT) result = false;
      break;
      case 0x16:
      // Banked LR_UND / SP_UND registers: Inaccessible from UND mode
      if (cur_mode == (unsigned)EXECMODE::UND) result = false;
      break;
    } break;
    case 0x3:
    // Banked MON/HYP registers
    switch (sys_mode & 0x7) {
      case 0x0:
      case 0x1:
      case 0x2:
      case 0x3:
      // Undefined sys_mode
      result = false;
      break;
      case 0x4:
      case 0x5:
      // Banked LR_MON / SP_MON registers: Inaccessible in non-secure state or
      // MON mode
      if (!IsSecure() || (cur_mode == (unsigned)EXECMODE::MON)) result = false;
      break;
      case 0x6:
      // Banked ELR_HYP register: Inaccessible in non-secure state; accessible
      // only from MON mode in secure state
      if ((cur_mode != (unsigned)EXECMODE::MON) && (cur_mode != (unsigned)EXECMODE::HYP))
      result = false;
      break;
      case 0x7:
      // Banked SP_HYP register: Inaccessible in non-secure state; accessible
      // only from MON mode in secure state
      if (cur_mode != (unsigned)EXECMODE::MON) result = false;
      break;
    } break;
  }

  return result;
} // valid_banked_reg_access()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Instruction::update_alias(
    unsigned cur_mode,
    unsigned next_mode) {


  switch(next_mode) {
    case (unsigned)EXECMODE::USR:
    case (unsigned)EXECMODE::SYS:
    // RB[0-12]:  R0_usr..R12_usr
    // RB[13-15]: SP_usr, LR_usr, PC
    REGS[13].update_alias(RB[13]);
    REGS[14].update_alias(RB[14]);
    break;
    case (unsigned)EXECMODE::FIQ:
    // RB[18-24]: R8_fiq..R12_fiq, SP_fiq, LR_fiq
    REGS[8].update_alias(RB[18]);
    REGS[9].update_alias(RB[19]);
    REGS[10].update_alias(RB[20]);
    REGS[11].update_alias(RB[21]);
    REGS[12].update_alias(RB[22]);
    REGS[13].update_alias(RB[23]);
    REGS[14].update_alias(RB[24]);
    break;
    case (unsigned)EXECMODE::IRQ:
    // RB[16-17]: SP_irq, LR_irq
    REGS[13].update_alias(RB[16]);
    REGS[14].update_alias(RB[17]);
    break;
    case (unsigned)EXECMODE::SVC:
    // RB[29-30]: SP_svc, LR_svc
    REGS[13].update_alias(RB[29]);
    REGS[14].update_alias(RB[30]);
    break;
    case (unsigned)EXECMODE::MON:
    // RB[33-34]: SP_mon, LR_mon
    REGS[13].update_alias(RB[33]);
    REGS[14].update_alias(RB[34]);
    break;
    case (unsigned)EXECMODE::ABT:
    // RB[27-28]: SP_abt, LR_abt
    REGS[13].update_alias(RB[27]);
    REGS[14].update_alias(RB[28]);
    break;
    case (unsigned)EXECMODE::HYP:
    // RB[31-32]: SP_hyp, ELR_hyp
    REGS[13].update_alias(RB[31]);
    // NOTE: HYP mode has access to LR_usr (as LR) as well as ELR_hyp
    //REGS[14].update_alias(RB[32]);
    break;
    case (unsigned)EXECMODE::UND:
    // RB[25-26]: SP_und, LR_und
    REGS[13].update_alias(RB[25]);
    REGS[14].update_alias(RB[26]);
    break;
    default:
    THROW_EXCEPTION("Invalid execution mode " << next_mode << " while updating the register banks.");
    break;
  }
  if (cur_mode == (unsigned)EXECMODE::FIQ && next_mode != (unsigned)EXECMODE::FIQ)
  {
    REGS[8].update_alias(RB[8]);
    REGS[9].update_alias(RB[9]);
    REGS[10].update_alias(RB[10]);
    REGS[11].update_alias(RB[11]);
    REGS[12].update_alias(RB[12]);
  }
} // update_alias()

// -----------------------------------------------------------------------------

int core_armcortexa9_funclt::Instruction::get_spsr_idx(unsigned mode) const {


  /// Gives access to the PSRs.
  switch(mode) {
    // return ((&SPSR.<mode>.get_reg() - SPSR) / sizeof(SPSR[0]));
    case (unsigned)EXECMODE::USR:
    case (unsigned)EXECMODE::SYS:
    return -1;
    case (unsigned)EXECMODE::FIQ:
    return 1;
    case (unsigned)EXECMODE::IRQ:
    return 0;
    case (unsigned)EXECMODE::SVC:
    return 4;
    case (unsigned)EXECMODE::MON:
    return 6;
    case (unsigned)EXECMODE::ABT:
    return 3;
    case (unsigned)EXECMODE::HYP:
    return 5;
    case (unsigned)EXECMODE::UND:
    return 2;
    default:
    return -1;
  }
} // get_spsr_idx()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Instruction::restore_spsr() {


  if (!(CPSR[CPSR_M] & 0x10)) {
    THROW_EXCEPTION("Invalid execution mode " << ios::hex << CPSR[CPSR_M] << ": CPSR[4] != 1.");
  }

  unsigned cur_mode = CPSR[CPSR_M];
  switch(cur_mode) {
    case (unsigned)EXECMODE::FIQ:
    CPSR = SPSR_FIQ;
    break;
    case (unsigned)EXECMODE::IRQ:
    CPSR = SPSR_IRQ;
    break;
    case (unsigned)EXECMODE::SVC:
    CPSR = SPSR_SVC;
    break;
    case (unsigned)EXECMODE::MON:
    CPSR = SPSR_MON;
    break;
    case (unsigned)EXECMODE::ABT:
    CPSR = SPSR_ABT;
    break;
    case (unsigned)EXECMODE::HYP:
    CPSR = SPSR_HYP;
    break;
    case (unsigned)EXECMODE::UND:
    CPSR = SPSR_UND;
    break;
    default:
    THROW_EXCEPTION("Invalid execution mode " << ios::hex << cur_mode << " while updating the PSR.");
    break;
  }
  update_alias(cur_mode, CPSR[CPSR_M]);
} // restore_spsr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Instruction::psr_mask(
    unsigned next_value,
    unsigned byte_mask,
    unsigned cur_mode,
    bool is_spsr,
    bool is_exception) const {


  /// Gives access to the PSRs.
  bool is_privileged = cur_mode & 0xF;
  unsigned mask = 0;
  unsigned next_mode = next_value & 0x1F;

  if (is_spsr && (!is_privileged || (cur_mode == (unsigned)EXECMODE::SYS)))
  return 0;

  if (byte_mask & 0x8) {
    if (is_spsr || is_exception) {
      // NZCVQITJ flags
      mask |= 0xFF000000;
    } else {
      // NZCVQ flags
      mask |= 0xF8000000;
    }
  }
  if (byte_mask & 0x4) {
    // GE flags
    mask |= 0x000F0000;
  }
  if (byte_mask & 0x2) {
    // E flag
    mask |= 0x00000200;
    if (is_spsr || is_exception) {
      // IT flags
      mask |= 0x0000FC00;
    }
    if (is_privileged && (is_spsr || IsSecure() /* TODO: || SCR[SCR_AW] */ ||
    HaveVirtExt())) {
      // A flag
      mask |= 0x00000100;
    }
  }
  if (byte_mask & 0x1) {
    if (is_spsr) {
      // IFT flags
      mask |= 0x000000E0;
      if (valid_psr_mode(next_mode)) {
        // cur_mode field
        mask |= 0x0000001F;
      }
    } else {
      if (is_exception) {
        // T flag
        mask |= 0x00000020;
      }
      if (is_privileged) {
        // I flag
        mask |= 0x00000080;
        if (/* TODO: !(SCTLR[SCTLR_NMFI] && (next_value & 0x40))
        && */ (IsSecure() /* TODO: || SCR[SCR_FW] */ || HaveVirtExt())) {
          // F flag
          mask |= 0x00000040;
        }
        if (valid_psr_mode(next_mode)
        // Check for attempts to enter modes only permitted in Secure state from
        // Non-secure state. These are Monitor cur_mode, and FIQ cur_mode if the
        // Security Extensions have reserved it.
        /* TODO: && (IsSecure()
        || ((next_mode != (unsigned)EXECMODE::MON)
        && !((next_mode == (unsigned)EXECMODE::FIQ) && NSACR[NSACR_RFR])))
        // There is no Hyp cur_mode in Secure state.
        && (SCR[SCR_NS] || (next_mode != (unsigned)EXECMODE::HYP))
        // Cannot move into Hyp cur_mode directly from a Non-secure PL1 cur_mode.
        && ((cur_mode == (unsigned)EXECMODE::HYP) || (next_mode != (unsigned)EXECMODE::HYP)
        || IsSecure())
        // Cannot move out of Hyp cur_mode with this function except on an
        // exception return.
        && ((cur_mode != (unsigned)EXECMODE::HYP) || (next_mode == (unsigned)EXECMODE::HYP)
        || is_exception) */) {
          // cur_mode field
          mask |= 0x0000001F;
        }
      }
    }
  }
  return mask;
} // psr_mask()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Instruction::CurrentInstrSet() const {


  /// Returns the current instruction set.
  /// JT=00: ARM; JT=01: Thumb; JT=10: Jazelle; JT=11: ThumbEE
  unsigned current_mode = (CPSR[CPSR_J] << 1) & CPSR[CPSR_T] & (unsigned)0x3;

  return (current_mode);
} // CurrentInstrSet()

// -----------------------------------------------------------------------------

bool core_armcortexa9_funclt::Instruction::valid_psr_mode(unsigned mode) const {


  /// Tests whether a 5-bit mode number corresponds to one of the permitted
  /// modes.
  switch(mode) {
    case (unsigned)EXECMODE::USR:
    case (unsigned)EXECMODE::FIQ:
    case (unsigned)EXECMODE::IRQ:
    case (unsigned)EXECMODE::SVC:
    case (unsigned)EXECMODE::ABT:
    case (unsigned)EXECMODE::UND:
    case (unsigned)EXECMODE::SYS:
    return true;
    case (unsigned)EXECMODE::MON:
    // TODO: return HaveSecurityExt();
    return true;
    case (unsigned)EXECMODE::HYP:
    // TODO: return HaveVirtExt();
    return true;
    default:
    return false;
  }
} // valid_psr_mode()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Instruction::ITAdvance() {


  /// Advances after normal execution of an IT block instruction.
  // unsigned IT = ((CPSR[CPSR_IT72] << 2) & 0xFC) | (CPSR[CPSR_IT10] & 0x3);
  if (!(CPSR[CPSR_IT10] || (CPSR[CPSR_IT72] & 0x1)))
  CPSR[CPSR_IT72] = CPSR[CPSR_IT10] = 0x0;
  else {
    // CPSR[CPSR_IT][0:4] <<= 1
    CPSR[CPSR_IT10] = (CPSR[CPSR_IT10] << 1) & 0x2;
    CPSR[CPSR_IT72] = (CPSR[CPSR_IT72] & 0x38) | ((CPSR[CPSR_IT72] << 1) & 0x6)
    | ((CPSR[CPSR_IT10] >> 1) & 0x1);
    // IT = (IT & 0xE0) | ((IT << 1) & 0x1F);
    // CPSR[CPSR_IT72] = ((IT >> 2) & 0x3F);
    // CPSR[CPSR_IT10] = (IT & 0x3);
  }
} // ITAdvance()

// -----------------------------------------------------------------------------

bool core_armcortexa9_funclt::Instruction::InITBlock() const {


  /// Tests whether the current instruction is in an IT block.
  return (CPSR[CPSR_IT10] || (CPSR[CPSR_IT72] & 0x3));
} // InITBlock()

// -----------------------------------------------------------------------------

bool core_armcortexa9_funclt::Instruction::LastInITBlock() const {


  /// Tests whether the current instruction is the last instruction of an IT
  /// block.
  return ((CPSR[CPSR_IT10] == 0x0) && ((CPSR[CPSR_IT72] & 0x3) == 0x2));
} // LastInITBlock()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Instruction::AddWithCarry(
    int operand1,
    int operand2,
    bool carry) {


  long long result_signed = sign_extend(operand1, 32) + sign_extend(operand2,
  32) + (unsigned)carry;

  // Update N (negative flag) if result is negative (bit[63]).
  CPSR[CPSR_N] = ((result_signed & 0x0000000080000000LL) != 0);

  // Update Z (zero flag) if result is 0.
  CPSR[CPSR_Z] = (result_signed == 0);

  /* Carry and Overflow
  Carry is only relevant for unsigned and meaningless for signed calculations.
  It is interpreted as carry for additions and !borrow for subtractions.
  1. If the addition of two unsigned numbers is a larger positive number than
  the unsigned limit.
  => The carry flag should be added to the next higher word, if any, to obtain
  the correct result.
  2. If the subtraction of two unsigned numbers does NOT require a borrow, i.e.
  if a >= b.
  => The !carry flag should be subtracted from the next higher word, if any, to
  obtain the correct result.

  Overflow is only relevant for signed and meaningless for unsigned calculations.
  1. If the addition/subtraction of two signed numbers is a larger positive
  number than the signed positive limit.
  2. If the addition/subtraction of two signed numbers is a smaller negative
  number than the signed negative limit.
  => In both cases, if this is part of a multi-word addition/subtraction, the
  flag can be ignored. For the last word, an extra bit = !MSB needs to be
  inserted as the new MSB to obtain the correct result.

  Addition Examples
  * 0xF + 0xF = 0x1E => 0xE, carry
  ADDU: 15 + 15 != 14 (carry)
  ADDS: -1 + (-1) = -2
  * 0x7 + 0x7 = 0xE, overflow
  ADDU: 7 + 7 = 14
  ADDS: 7 + 7 != -2 (positive overflow)
  * 0x8 + 0x8 = 0x10 => 0x0, carry, overflow
  ADDU: 8 + 8 != 0 (carry)
  ADDS: -8 + (-8) != 0 (negative overflow)

  Subtraction Examples
  * 0x0 - 0x1 => 0x0 + 0xE + 1 = 0xF, !carry
  SUBU: 0 - 1 != 15 (borrow)
  SUBS: 0 - 1 = -1
  * 0x0 - 0x7 => 0x0 + 0x8 + 1 = 0x9, !carry
  SUBU: 0 - 7 != 9 (borrow)
  SUBS: 0 - 7 = -7
  * 0x0 - 0xF => 0x0 + 0x0 + 1 = 0x1, !carry
  SUBU: 0 - 15 != 1 (borrow)
  SUBS: 0 - (-1) = 1
  * 0x7 - 0 => 0x7 + 0xF + 1 = 0x17 => 0x7, carry
  SUBU: 7 - 0 = 7
  SUBS: 7 - 0 = 7
  * 0x7 - 0x8 => 0x7 + 0x7 + 1 = 0xF, !carry, overflow
  SUBU: 7 - 8 != 15 (borrow)
  SUBS: 7 - (-8) != -1 (positive overflow)
  * 0x8 - 0x7 => 0x8 + 0x8 + 1 = 0x11 = 0x1, carry, overflow
  SUBU: 8 - 7 = 1
  SUBS: (-8) - 7 != 1 (negative overflow)
  */
  /* Update C (carry/!borrow flag) if operation generated a carry. We can either
  test result_unsigned & 0x100000000LL or XOR the MSB of operands and result_signed.
  The first method is easier, but we want to avoid the extra unsigned addition:
  Ex1: 1111b (-1d) + 1000b (-8d)
  -> s = 1 0111b (-9d)
  -> (s & 1000b) != (s & 10000b) -> 1
  Ex2: 1111b (-1d) + 1001b (-7d)
  -> s = 1 1000b (-8d)
  -> (s & 1000b) == (s & 10000b) -> 0
  */
  CPSR[CPSR_C] = (((operand1 ^ operand2 ^ (result_signed >> 1)) & 0x80000000) !=
  0);

  /* Update V (overflow flag) if operation generated an overflow. Since we have
  already calculated result_signed, the easiest test would be (result_signed &
  0x80000000LL) != (result_signed & 0x100000000LL):
  Ex1:
  u: 0111b (7d) + 0111b (7d)
  -> u = 0 1110b (14d)
  -> u & 10000b = 0
  s: 0111b (7d) + 0111b (7d)
  -> s = 0 1110b (14d)
  -> 0 ^ 0 ^ (s & 10000b) = 0
  Ex2:
  u: 0111b (7d) + 1000b (8d)
  -> u = 0 1111b (15d)
  -> u & 10000b = 0
  s: 0111b (7d) + 1000b (-8d)
  -> s = 1 1111b (-1d)
  -> 0 ^ 1 ^ (s & 10000b) = 0
  Ex3:
  u: 0001b (1d) + 1111b (15d)
  -> u = 1 0000b (16d)
  -> u & 10000b = 1
  s: 0001b (1d) + 1111b (-1d)
  -> s = 0 0000b (0d)
  -> 0 ^ 1 ^ (s & 10000b) = 1
  Ex4:
  u: 0001b (1d) + 1110b (14d)
  -> u = 0 1111b (15d)
  -> u & 10000b = 0
  s: 0001b (1d) + 1110b (-2d)
  -> s = 1 1111b (-1d)
  -> 0 ^ 1 ^ (s & 10000b) = 0
  Ex5:
  u: 1000b (8d)  + 1000b (8d)
  -> u = 1 0000b (16d)
  -> u & 10000b = 1
  s: 1000b (-8d) + 1000b (-8d)
  -> s = 1 0000b (-16d)
  -> 1 ^ 1 ^ (s & 10000b) = 1
  */
  CPSR[CPSR_V] = (((result_signed >> 1) & 0x80000000) != (result_signed &
  0x80000000));
} // AddWithCarry()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Instruction::update_psr_bit(
    int result,
    bool carry) {


  // Update N (negative flag) if result is negative (bit[63]).
  CPSR[CPSR_N] = ((result & 0x80000000) != 0);

  // Update Z (zero flag) if result is 0.
  CPSR[CPSR_Z] = (result == 0);

  // Update C (carry flag) if operation generated a carry.
  // 01b (1) + 10b (2|-2) -> 0001b + 1110b = 1111b (15|-1).
  CPSR[CPSR_C] = carry;

  // V (overflow flag) is not updated.
} // update_psr_bit()

// -----------------------------------------------------------------------------

long long core_armcortexa9_funclt::Instruction::sign_extend(
    long long bits,
    unsigned len_bits) const {


  if (len_bits >= 8*sizeof(long long)) return bits;

  // NOTE: This function assumes two's complement, which is implementation
  // defined according to the C++ LRM. Extend only if MSB == 1.
  // if ((bits & ((long long)1 << (len_bits - 1))) != 0)
  //   bits |= (((unsigned long long)0xFFFFFFFF) << len_bits);
  // NOTE: Branchless algorithm courtesy of http://aggregate.ee.engr.uky.edu/MAGIC/.
  bits = ((bits & (((long long)1 << len_bits) - 1)) ^ ((long long)1 << (len_bits
  - 1))) - ((long long)1 << (len_bits - 1));
  return bits;
} // sign_extend()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Instruction::LSL(
    unsigned to_shift,
    unsigned shift_amm,
    bool& carry) {


  unsigned shifted;

  to_shift &= 0xFFFFFFFF;
  if (shift_amm <= 0) return to_shift;
  shifted = ((unsigned long)to_shift << shift_amm) & 0xFFFFFFFF;

  // Carry
  if (shift_amm > 32) carry = 0;
  else carry = to_shift & (0x1 << (32 - shift_amm));

  return shifted;
} // LSL()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Instruction::LSR(
    unsigned to_shift,
    unsigned shift_amm,
    bool& carry) {


  unsigned shifted;

  to_shift &= 0xFFFFFFFF;
  if (shift_amm <= 0) return to_shift;
  shifted = (unsigned long)to_shift >> shift_amm;

  // Carry
  if (shift_amm > 32) carry = 0;
  else carry = to_shift & ((long)1 << (shift_amm - 1));

  return shifted;
} // LSR()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Instruction::ASR(
    unsigned to_shift,
    unsigned shift_amm,
    bool& carry) {


  unsigned shifted;

  to_shift &= 0xFFFFFFFF;
  if (shift_amm <= 0) return to_shift;
  shifted = (unsigned long)to_shift >> shift_amm;

  // Sign Extension and Carry
  bool sign = to_shift & 0x80000000;
  if (shift_amm >= 32) {
    if (sign) shifted = 0xFFFFFFFF;
    carry = sign;
  } else {
    if (sign) shifted = (shifted ^ ((long)1 << (32 - shift_amm - 1))) - ((long)1
    << (32 - shift_amm - 1));
    carry = to_shift & ((long)1 << (shift_amm - 1));
  }

  return shifted & 0xFFFFFFFF;
} // ASR()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Instruction::ROR(
    unsigned to_rotate,
    unsigned rotate_amm,
    bool& carry) {


  unsigned rotated;

  to_rotate &= 0xFFFFFFFF;
  if (rotate_amm <= 0) return to_rotate;
  if (rotate_amm > 31) rotate_amm %= 32;
  rotated = ((unsigned)to_rotate >> rotate_amm) | (to_rotate << (32 - rotate_amm));
  carry = rotated & 0x80000000;
  return rotated;
} // ROR()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Instruction::RRX(
    unsigned to_rotate,
    unsigned rotate_amm,
    bool carry_in,
    bool& carry) {


  unsigned rotated;

  to_rotate &= 0xFFFFFFFF;
  if (rotate_amm <= 0) return to_rotate;
  rotated = (carry_in? 0x80000000 : 0) | ((unsigned)to_rotate >> 1);
  carry = to_rotate & 0x1;
  return rotated;
} // RRX()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Instruction::sat_q(
    long long operand,
    unsigned saturate_to,
    bool is_signed,
    bool set_q_en) const {


  unsigned highest = ((unsigned)0xFFFFFFFF >> (unsigned)(32 - (unsigned)saturate_to
  + is_signed)) & 0xFFFFFFFF;
  int lowest = is_signed? -highest-1 : 0;

  if (operand > highest) {
    if (set_q_en) CPSR[CPSR_Q] = 1;
    return highest;
  } else if (operand < lowest) {
    if (set_q_en) CPSR[CPSR_Q] = 1;
    return lowest & 0xFFFFFFFF;
  } else if (set_q_en) CPSR[CPSR_Q] = 0;
  return operand;
} // sat_q()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Instruction::BitCount(unsigned operand) const
{


  unsigned setbits = 0;
  for (; operand; setbits++) {
    // Clears least significant set bit.
    operand &= operand - 1;
  }
  return setbits;
} // BitCount()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Instruction::ExcVectorBase() const {


  /// Determine the exception base address.
  /* TODO: if (SCTLR[SCTLR_V])
  return 0xFFFF0000;
  else if (HaveSecurityExt())
  return VBAR;
  else */ return 0x0;
} // ExcVectorBase()

// -----------------------------------------------------------------------------

bool core_armcortexa9_funclt::Instruction::HaveLPAE() const {


  /// Returns TRUE if the implementation includes the Large Physical Address
  /// Extension.
  return false;
} // HaveLPAE()

// -----------------------------------------------------------------------------

bool core_armcortexa9_funclt::Instruction::HaveMPExt() const {


  /// Returns TRUE if the implementation includes the Multiprocessing Extensions.
  return false;
} // HaveMPExt()

// -----------------------------------------------------------------------------

bool core_armcortexa9_funclt::Instruction::HaveSecurityExt() const {


  /// Returns TRUE if the implementation includes the Security Extensions.
  return false;
} // HaveSecurityExt()

// -----------------------------------------------------------------------------

bool core_armcortexa9_funclt::Instruction::HaveVirtExt() const {


  /// Returns TRUE if the implementation includes the Virtualization Extensions.
  return false;
} // HaveVirtExt()

// -----------------------------------------------------------------------------

bool core_armcortexa9_funclt::Instruction::IsSecure() const {


  /// Returns TRUE if the processor is in Secure state, or if the implementation
  /// does not include the Security Extensions, and FALSE otherwise.
  return (!HaveSecurityExt() /* TODO: || !SCR[SCR_NS] */ || CPSR[CPSR_M] ==
  (unsigned)((unsigned)EXECMODE::MON));
} // IsSecure()

// -----------------------------------------------------------------------------

bool core_armcortexa9_funclt::Instruction::JazelleAcceptsExecution() {


  /// Indicates whether Jazelle hardware will take over execution when a BXJ
  /// instruction is executed.
  return false;
} // JazelleAcceptsExecution()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::InvalidInstruction::InvalidInstruction(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory) {


} // InvalidInstruction()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::InvalidInstruction::get_id() const throw() {

  return 161;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::InvalidInstruction::get_name() const
throw() {

  return "Invalid";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::InvalidInstruction::get_mnemonic() const
throw() {

  return "invalid";
} // get_mnemonic()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::InvalidInstruction::replicate(Instruction*
instr) const throw() {

  return new InvalidInstruction(R, instr_memory, data_memory);
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::InvalidInstruction::behavior() {

  THROW_EXCEPTION("Invalid instruction at PC=" << std::hex << std::showbase <<
  this->RB[15] << '.');
  return 0;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::ARMExpandImmOp::ARMExpandImmOp(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory) {


} // ARMExpandImmOp()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ARMExpandImmOp::ARMExpandImm(
    unsigned& rotate,
    unsigned& imm,
    unsigned& operand,
    bool& carry) {

  unsigned num_cycles = 0;


  carry = CPSR[CPSR_C];
  operand = ROR(imm, rotate<<1, carry);

  return num_cycles;
} // ARMExpandImm()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::UpdatePSRAddOp::UpdatePSRAddOp(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory) {


} // UpdatePSRAddOp()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::UpdatePSRAddOp::UpdatePSRAdd(
    trap::RegisterAlias<unsigned>& rd,
    unsigned& rd_bit,
    unsigned& s,
    int& operand1,
    int& operand2,
    int& result) {

  unsigned num_cycles = 0;


  if (rd_bit == 15) {
    // SUBS PC
    if (s) {
      unsigned value = 0, mask = 0;
      int spsr_idx = get_spsr_idx(CPSR[CPSR_M]);
      if (spsr_idx >= 0) {
        value = SPSR[spsr_idx];
        mask = psr_mask(value, 0xF, CPSR[CPSR_M], false, true);
        if (mask) CPSR = (CPSR & !mask) | (value & mask);
      }
      if (CPSR[CPSR_J] && CPSR[CPSR_T] && (CPSR[CPSR_M] == (unsigned)EXECMODE::HYP))
      THROW_EXCEPTION("SUBS cannot return to HYP mode in ThumbEE.");
    }
    BranchWritePC(result);
  } else {
    rd = result;
    // Update the flags only for s = 0x1.
    if (s) {
      AddWithCarry(operand1, operand2, 0);
    }
  }

  return num_cycles;
} // UpdatePSRAdd()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::ConditionPassedOp::ConditionPassedOp(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory) {


} // ConditionPassedOp()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ConditionPassedOp::ConditionPassed(unsigned&
cond) {

  unsigned num_cycles = 0;


  /// Uses the ARM/Thumb condition specifier to determine whether the instruction
  /// must be executed.
  if (cond /* TODO: CurrentCond() */!= 0xE) {
    // Of course the previous if is redundant, the case would be enough, but
    // since cond == 0xE is the most common situation, treating it in a particular
    // way makes the code a bit faster.
    switch(cond) {
      case 0x0: {
        // EQ (Equal): CPSR[CPSR_Z]
        if (CPSR[CPSR_Z] == 0x0) {
          annul();
        }
        break;
      }
      case 0x1: {
        // NE (Not equal): !CPSR[CPSR_Z]
        if (CPSR[CPSR_Z] != 0x0) {
          annul();
        }
        break;
      }
      case 0x2: {
        // CS/HS (Carry set / Unsigned higher or same): CPSR[CPSR_V]
        if (CPSR[CPSR_C] == 0x0) {
          annul();
        }
        break;
      }
      case 0x3: {
        // CC/LO (Carry clear / Unsigned lower): !CPSR[CPSR_C]
        if (CPSR[CPSR_C] != 0x0) {
          annul();
        }
        break;
      }
      case 0x4: {
        // MI (Minus): CPSR[CPSR_N]
        if (CPSR[CPSR_N] == 0x0) {
          annul();
        }
        break;
      }
      case 0x5: {
        // PL (Plus): !CPSR[CPSR_N]
        if (CPSR[CPSR_N] != 0x0) {
          annul();
        }
        break;
      }
      case 0x6: {
        // VS (Overflow): CPSR[CPSR_V]
        if (CPSR[CPSR_V] == 0x0) {
          annul();
        }
        break;
      }
      case 0x7: {
        // VC (No overflow): !CPSR[CPSR_V]
        if (CPSR[CPSR_V] != 0x0) {
          annul();
        }
        break;
      }
      case 0x8: {
        // HI (Unsigned higher): !CPSR[CPSR_Z] && CPSR[CPSR_C]
        if ((CPSR & 0x60000000) != 0x20000000) {
          annul();
        }
        break;
      }
      case 0x9: {
        // LS (Unsigned lower or same): CPSR[CPSR_Z] || !CPSR[CPSR_C]
        if ((CPSR & 0x60000000) == 0x20000000) {
          annul();
        }
        break;
      }
      case 0xA: {
        // GE (Signed greater than or equal): CPSR[CPSR_N] == CPSR[CPSR_V]
        if (CPSR[CPSR_N] != CPSR[CPSR_V]) {
          annul();
        }
        break;
      }
      case 0xB: {
        // LT (Signed less than): CPSR[CPSR_N] != CPSR[CPSR_V]
        if (CPSR[CPSR_N] == CPSR[CPSR_V]) {
          annul();
        }
        break;
      }
      case 0xC: {
        // GT (Signed greater than): CPSR[CPSR_N] == CPSR[CPSR_V] && !CPSR[CPSR_Z]
        if ((CPSR[CPSR_Z] != 0x0) || (CPSR[CPSR_V] != CPSR[CPSR_N])) {
          annul();
        }
        break;
      }
      case 0xD: {
        // LE (Signed less than or equal): CPSR[CPSR_N] != CPSR[CPSR_V] ||
        // CPSR[CPSR_Z]
        if ((CPSR[CPSR_Z] == 0x0) && (CPSR[CPSR_V] == CPSR[CPSR_N])) {
          annul();
        }
        break;
      }
      case 0xF: {
        // AL (Always)
        break;
      }
      default: {
        // Unrecognized condition code
        THROW_EXCEPTION("Unrecognized condition code " << cond << ".");
        break;
      }
    }
  }

  return num_cycles;
} // ConditionPassed()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::DecodeImmShiftOp::DecodeImmShiftOp(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory) {


} // DecodeImmShiftOp()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::DecodeImmShiftOp::DecodeImmShift(
    trap::RegisterAlias<unsigned>& rm,
    unsigned& rm_bit,
    unsigned& shift_amm,
    unsigned& shift_op,
    unsigned& operand,
    bool& carry) {

  unsigned num_cycles = 0;


  carry = CPSR[CPSR_C];
  switch(shift_op & 0x3) {
    case 0x0:
    // Logical shift left
    operand = LSL(rm, shift_amm, carry);
    break;
    case 0x1:
    // Logical shift right
    operand = LSR(rm, shift_amm? shift_amm : 32, carry);
    break;
    case 0x2:
    // Arithmetic shift right
    operand = ASR(rm, shift_amm? shift_amm : 32, carry);
    break;
    case 0x3:
    if (shift_amm) {
      // Rotate right
      operand = ROR(rm, shift_amm, carry);
    } else {
      // Rotate right with extend
      operand = RRX(rm, 1, carry, carry);
    }
    break;
  }

  return num_cycles;
} // DecodeImmShift()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::DecodeRegShiftOp::DecodeRegShiftOp(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory) {


} // DecodeRegShiftOp()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::DecodeRegShiftOp::DecodeRegShift(
    trap::RegisterAlias<unsigned>& rm,
    unsigned& rm_bit,
    trap::RegisterAlias<unsigned>& rs,
    unsigned& rs_bit,
    unsigned& shift_op,
    unsigned& operand,
    bool& carry) {

  unsigned num_cycles = 0;


  unsigned shift_amm = rs & 0xFF;
  carry = CPSR[CPSR_C];
  switch(shift_op & 0x3) {
    case 0x0:
    // Logical shift left
    operand = LSL(rm, shift_amm, carry);
    break;
    case 0x1:
    // Logical shift right
    operand = LSR(rm, shift_amm, carry);
    break;
    case 0x2:
    // Arithmetic shift right
    operand = ASR(rm, shift_amm, carry);
    break;
    case 0x3:
    // Rotate right
    operand = ROR(rm, shift_amm, carry);
    break;
  }
  num_cycles += 1;

  return num_cycles;
} // DecodeRegShift()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::UpdatePSRAddWithCarryOp::UpdatePSRAddWithCarryOp(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory) {


} // UpdatePSRAddWithCarryOp()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::UpdatePSRAddWithCarryOp::UpdatePSRAddWithCarry(
    trap::RegisterAlias<unsigned>& rd,
    unsigned& rd_bit,
    unsigned& s,
    int& operand1,
    int& operand2,
    int& result) {

  unsigned num_cycles = 0;


  if (rd_bit == 15) {
    // SUBS PC
    if (s) {
      unsigned value = 0, mask = 0;
      int spsr_idx = get_spsr_idx(CPSR[CPSR_M]);
      if (spsr_idx >= 0) {
        value = SPSR[spsr_idx];
        mask = psr_mask(value, 0xF, CPSR[CPSR_M], false, true);
        if (mask) CPSR = (CPSR & !mask) | (value & mask);
      }
      if (CPSR[CPSR_J] && CPSR[CPSR_T] && (CPSR[CPSR_M] == (unsigned)EXECMODE::HYP))
      THROW_EXCEPTION("SUBS cannot return to HYP mode in ThumbEE.");
    }
    BranchWritePC(result);
  } else {
    rd = result;
    // Update the flags only for s = 0x1.
    if (s) {
      AddWithCarry(operand1, operand2, CPSR[CPSR_C]);
    }
  }

  return num_cycles;
} // UpdatePSRAddWithCarry()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::UpdatePSRSubOp::UpdatePSRSubOp(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory) {


} // UpdatePSRSubOp()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::UpdatePSRSubOp::UpdatePSRSub(
    trap::RegisterAlias<unsigned>& rd,
    unsigned& rd_bit,
    unsigned& s,
    int& operand1,
    int& operand2,
    int& result) {

  unsigned num_cycles = 0;


  if (rd_bit == 15) {
    // SUBS PC
    if (s) {
      unsigned value = 0, mask = 0;
      int spsr_idx = get_spsr_idx(CPSR[CPSR_M]);
      if (spsr_idx >= 0) {
        value = SPSR[spsr_idx];
        mask = psr_mask(value, 0xF, CPSR[CPSR_M], false, true);
        if (mask) CPSR = (CPSR & !mask) | (value & mask);
      }
      if (CPSR[CPSR_J] && CPSR[CPSR_T] && (CPSR[CPSR_M] == (unsigned)EXECMODE::HYP))
      THROW_EXCEPTION("SUBS cannot return to HYP mode in ThumbEE.");
    }
    BranchWritePC(result);
  } else {
    rd = result;
    // Update the flags only for s = 0x1.
    if (s) {
      AddWithCarry(operand1, ~operand2 & 0xFFFFFFFF, 1);
    }
  }

  return num_cycles;
} // UpdatePSRSub()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::UpdatePSRSubWithCarryOp::UpdatePSRSubWithCarryOp(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory) {


} // UpdatePSRSubWithCarryOp()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::UpdatePSRSubWithCarryOp::UpdatePSRSubWithCarry(
    trap::RegisterAlias<unsigned>& rd,
    unsigned& rd_bit,
    unsigned& s,
    int& operand1,
    int& operand2,
    int& result) {

  unsigned num_cycles = 0;


  if (rd_bit == 15) {
    // SUBS PC
    if (s) {
      unsigned value = 0, mask = 0;
      int spsr_idx = get_spsr_idx(CPSR[CPSR_M]);
      if (spsr_idx >= 0) {
        value = SPSR[spsr_idx];
        mask = psr_mask(value, 0xF, CPSR[CPSR_M], false, true);
        if (mask) CPSR = (CPSR & !mask) | (value & mask);
      }
      if (CPSR[CPSR_J] && CPSR[CPSR_T] && (CPSR[CPSR_M] == (unsigned)EXECMODE::HYP))
      THROW_EXCEPTION("SUBS cannot return to HYP mode in ThumbEE.");
    }
    BranchWritePC(result);
  } else {
    rd = result;
    // Update the flags only for s = 0x1.
    if (s) {
      bool carry = CPSR[CPSR_C];
      AddWithCarry(operand1, ~operand2 & 0xFFFFFFFF, carry);
    }
  }

  return num_cycles;
} // UpdatePSRSubWithCarry()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::UpdatePSRMulOp::UpdatePSRMulOp(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory) {


} // UpdatePSRMulOp()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::UpdatePSRMulOp::UpdatePSRMul(
    unsigned& ss,
    unsigned& s,
    unsigned& l,
    long long& result) {

  unsigned num_cycles = 0;


  // Update the flags only for s = 0x1. MLS does not set the flags!
  if (s && (!ss || l)) {
    if (l) {
      // Update N (negative flag) if result is negative (bit[63]).
      CPSR[CPSR_N] = ((result & 0x8000000000000000LL) != 0);
    } else {
      // Update N (negative flag) if result is negative (bit[31]).
      CPSR[CPSR_N] = ((result & 0x80000000) != 0);
    }

    // Update Z (zero flag) if result is 0.
    CPSR[CPSR_Z] = (result == 0);
  }

  return num_cycles;
} // UpdatePSRMul()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::UpdatePSRBitOp::UpdatePSRBitOp(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory) {


} // UpdatePSRBitOp()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::UpdatePSRBitOp::UpdatePSRBit(
    trap::RegisterAlias<unsigned>& rd,
    unsigned& rd_bit,
    unsigned& s,
    int& result,
    bool& carry) {

  unsigned num_cycles = 0;


  if (rd_bit == 15) {
    // SUBS PC
    if (s) {
      unsigned value = 0, mask = 0;
      int spsr_idx = get_spsr_idx(CPSR[CPSR_M]);
      if (spsr_idx >= 0) {
        value = SPSR[spsr_idx];
        mask = psr_mask(value, 0xF, CPSR[CPSR_M], false, true);
        if (mask) CPSR = (CPSR & !mask) | (value & mask);
      }
      if (CPSR[CPSR_J] && CPSR[CPSR_T] && (CPSR[CPSR_M] == (unsigned)EXECMODE::HYP))
      THROW_EXCEPTION("SUBS cannot return to HYP mode in ThumbEE.");
    }
    BranchWritePC(result);
  } else {
    rd = result;
    // Update the flags only for s = 0x1.
    if (s) {
      update_psr_bit(result, carry);
    }
  }

  return num_cycles;
} // UpdatePSRBit()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LSOffsetOp::LSOffsetOp(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory) {


} // LSOffsetOp()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LSOffsetOp::LSOffset(
    trap::RegisterAlias<unsigned>& rn,
    unsigned& rn_bit,
    unsigned& p,
    unsigned& u,
    unsigned& w,
    unsigned& operand,
    unsigned& address) {

  unsigned num_cycles = 0;


  /** Addressing Modes:
  *  Offset: The offset is added to or subtracted from the base address to form
  the memory address.
  *  Pre-indexed: The offset is added to or subtracted form the base address to
  form the memory address. The base register is then updated with this new
  address, to permit automatic indexing through an array or memory block.
  *  Post-indexed: The value of the base register alone is used as the memory
  address. The offset is then added to subtracted from the base register and
  the result stored back in the base register, to permit automatic indexing
  through an array or memory block.
  **/
  unsigned disp = (u? rn + operand : rn - operand);
  // address = (p? disp : rn);
  // rn = ((w || !p)? disp : rn);

  if (p == 1) {
    // offset or pre-indexed
    address = disp;
    if (w == 1) {
      // pre-indexed
      rn = disp;
    }
  } else {
    // post-indexed
    address = rn;
    rn = disp;
  }

  return num_cycles;
} // LSOffset()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LSMReglistOp::LSMReglistOp(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory) {


} // LSMReglistOp()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LSMReglistOp::LSMReglist(
    trap::RegisterAlias<unsigned>& rn,
    unsigned& rn_bit,
    unsigned& p,
    unsigned& u,
    unsigned& reg_list,
    unsigned& start_address,
    unsigned& wb_address) {

  unsigned num_cycles = 0;


  // NOTE: Search algorithm for counting ones taken from Brian W. Kernighan and
  // Dennis M. Ritchie, "The C Programming Language," 1988.
  unsigned input = reg_list;
  unsigned setbits = 0;
  for (; input; setbits++) {
    // Clears least significant set bit.
    input &= input - 1;
  }

  // Calculate start and end addresses of memory where registers will be saved.
  if (u == 1) {
    if (p == 0) {
      // Increment after (u == 1 && p == 0).
      start_address = rn;
      wb_address = start_address + (setbits * 4);
    } else {
      // Increment before (u == 1 && p == 1).
      start_address = rn + 4;
      wb_address = start_address - 4 + (setbits * 4);
    }
  } else {
    if (p == 0) {
      // Decrement after (u == 0 && p == 0).
      start_address = rn - (setbits * 4) + 4;
      wb_address = start_address - 4;
    } else {
      // Decrement before (u == 0 && p == 1).
      start_address = rn - (setbits * 4);
      wb_address = start_address;
    }
  }

  // Note that the addresses are word aligned, so the last 2 bits of the addresses
  // are ignored.
  start_address &= 0xFFFFFFFC;
  wb_address &= 0xFFFFFFFC;

  return num_cycles;
} // LSMReglist()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::ADD_i::ADD_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ARMExpandImmOp(R, instr_memory, data_memory),
  UpdatePSRAddOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // ADD_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ADD_i::get_id() const throw() {

  return 0;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ADD_i::get_name() const throw() {

  return "ADD_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ADD_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->s) {
    default: {
      switch(this->rn_bit) {
        default: {
          oss << "ADD";
        break;}
        case 15: {
          oss << "ADR";
        break;}
      }
    break;}
    case 1: {
      oss << "ADDS";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::ADD_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::ADD_i::replicate(Instruction* instr) const
throw() {

  ADD_i* new_instr = new ADD_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    ADD_i* old_instr = dynamic_cast<ADD_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->rotate = old_instr->rotate;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ADD_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  // ADR
  if (!s && (rn_bit == 15))
  operand1 = PC & 0xFFFFFFFC;
  else
  operand1 = (int)rn;

  operand2 = (int)operand;
  result = operand1 + operand2;
  this->num_instr_cycles += UpdatePSRAdd(this->rd, this->rd_bit, this->s,
  this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::ADD_r::ADD_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  UpdatePSRAddOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // ADD_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ADD_r::get_id() const throw() {

  return 1;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ADD_r::get_name() const throw() {

  return "ADD_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ADD_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "ADD";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::ADD_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::ADD_r::replicate(Instruction* instr) const
throw() {

  ADD_r* new_instr = new ADD_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    ADD_r* old_instr = dynamic_cast<ADD_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ADD_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  // ADR
  if (!s && (rn_bit == 15))
  operand1 = PC & 0xFFFFFFFC;
  else
  operand1 = (int)rn;

  operand2 = (int)operand;
  result = operand1 + operand2;
  this->num_instr_cycles += UpdatePSRAdd(this->rd, this->rd_bit, this->s,
  this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::ADD_sr::ADD_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  UpdatePSRAddOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // ADD_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ADD_sr::get_id() const throw() {

  return 2;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ADD_sr::get_name() const throw() {

  return "ADD_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ADD_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "ADD";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::ADD_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::ADD_sr::replicate(Instruction* instr)
const throw() {

  ADD_sr* new_instr = new ADD_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    ADD_sr* old_instr = dynamic_cast<ADD_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ADD_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid ADD (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  // ADR
  if (!s && (rn_bit == 15))
  operand1 = PC & 0xFFFFFFFC;
  else
  operand1 = (int)rn;

  operand2 = (int)operand;
  result = operand1 + operand2;
  this->num_instr_cycles += UpdatePSRAdd(this->rd, this->rd_bit, this->s,
  this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::ADC_i::ADC_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ARMExpandImmOp(R, instr_memory, data_memory),
  UpdatePSRAddWithCarryOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // ADC_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ADC_i::get_id() const throw() {

  return 3;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ADC_i::get_name() const throw() {

  return "ADC_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ADC_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "ADC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::ADC_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::ADC_i::replicate(Instruction* instr) const
throw() {

  ADC_i* new_instr = new ADC_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    ADC_i* old_instr = dynamic_cast<ADC_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->rotate = old_instr->rotate;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ADC_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  operand1 = (int)rn;
  operand2 = (int)operand;
  result = operand1 + operand2 + (unsigned)CPSR[CPSR_C];
  this->num_instr_cycles += UpdatePSRAddWithCarry(this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::ADC_r::ADC_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  UpdatePSRAddWithCarryOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // ADC_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ADC_r::get_id() const throw() {

  return 4;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ADC_r::get_name() const throw() {

  return "ADC_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ADC_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "ADC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::ADC_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::ADC_r::replicate(Instruction* instr) const
throw() {

  ADC_r* new_instr = new ADC_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    ADC_r* old_instr = dynamic_cast<ADC_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ADC_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  operand1 = (int)rn;
  operand2 = (int)operand;
  result = operand1 + operand2 + (unsigned)CPSR[CPSR_C];
  this->num_instr_cycles += UpdatePSRAddWithCarry(this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::ADC_sr::ADC_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  UpdatePSRAddWithCarryOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // ADC_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ADC_sr::get_id() const throw() {

  return 5;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ADC_sr::get_name() const throw() {

  return "ADC_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ADC_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "ADC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::ADC_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::ADC_sr::replicate(Instruction* instr)
const throw() {

  ADC_sr* new_instr = new ADC_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    ADC_sr* old_instr = dynamic_cast<ADC_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ADC_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid ADC (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  operand1 = (int)rn;
  operand2 = (int)operand;
  result = operand1 + operand2 + (unsigned)CPSR[CPSR_C];
  this->num_instr_cycles += UpdatePSRAddWithCarry(this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::SUB_i::SUB_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ARMExpandImmOp(R, instr_memory, data_memory),
  UpdatePSRSubOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // SUB_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SUB_i::get_id() const throw() {

  return 6;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SUB_i::get_name() const throw() {

  return "SUB_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SUB_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "SUB";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::SUB_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::SUB_i::replicate(Instruction* instr) const
throw() {

  SUB_i* new_instr = new SUB_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    SUB_i* old_instr = dynamic_cast<SUB_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->rotate = old_instr->rotate;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SUB_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  // ADR
  if (!s && (rn_bit == 15))
  operand1 = PC & 0xFFFFFFFC;
  else
  operand1 = (int)rn;
  operand2 = (int)operand;
  result = operand1 - operand2;
  this->num_instr_cycles += UpdatePSRSub(this->rd, this->rd_bit, this->s,
  this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::SUB_r::SUB_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  UpdatePSRSubOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // SUB_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SUB_r::get_id() const throw() {

  return 7;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SUB_r::get_name() const throw() {

  return "SUB_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SUB_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "SUB";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::SUB_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::SUB_r::replicate(Instruction* instr) const
throw() {

  SUB_r* new_instr = new SUB_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    SUB_r* old_instr = dynamic_cast<SUB_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SUB_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  // ADR
  if (!s && (rn_bit == 15))
  operand1 = PC & 0xFFFFFFFC;
  else
  operand1 = (int)rn;
  operand2 = (int)operand;
  result = operand1 - operand2;
  this->num_instr_cycles += UpdatePSRSub(this->rd, this->rd_bit, this->s,
  this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::SUB_sr::SUB_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  UpdatePSRSubOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // SUB_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SUB_sr::get_id() const throw() {

  return 8;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SUB_sr::get_name() const throw() {

  return "SUB_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SUB_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "SUB";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::SUB_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::SUB_sr::replicate(Instruction* instr)
const throw() {

  SUB_sr* new_instr = new SUB_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    SUB_sr* old_instr = dynamic_cast<SUB_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SUB_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid SUB (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  // ADR
  if (!s && (rn_bit == 15))
  operand1 = PC & 0xFFFFFFFC;
  else
  operand1 = (int)rn;
  operand2 = (int)operand;
  result = operand1 - operand2;
  this->num_instr_cycles += UpdatePSRSub(this->rd, this->rd_bit, this->s,
  this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::SBC_i::SBC_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ARMExpandImmOp(R, instr_memory, data_memory),
  UpdatePSRSubWithCarryOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // SBC_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SBC_i::get_id() const throw() {

  return 9;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SBC_i::get_name() const throw() {

  return "SBC_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SBC_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "SBC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::SBC_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::SBC_i::replicate(Instruction* instr) const
throw() {

  SBC_i* new_instr = new SBC_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    SBC_i* old_instr = dynamic_cast<SBC_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->rotate = old_instr->rotate;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SBC_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  operand1 = (int)rn;
  operand2 = (int)operand;
  result = operand1 - operand2;

  if (CPSR[CPSR_C] == 0x0) {
    result = ((int)result) - 1;
  }
  this->num_instr_cycles += UpdatePSRSubWithCarry(this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::SBC_r::SBC_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  UpdatePSRSubWithCarryOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // SBC_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SBC_r::get_id() const throw() {

  return 10;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SBC_r::get_name() const throw() {

  return "SBC_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SBC_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "SBC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::SBC_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::SBC_r::replicate(Instruction* instr) const
throw() {

  SBC_r* new_instr = new SBC_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    SBC_r* old_instr = dynamic_cast<SBC_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SBC_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  operand1 = (int)rn;
  operand2 = (int)operand;
  result = operand1 - operand2;

  if (CPSR[CPSR_C] == 0x0) {
    result = ((int)result) - 1;
  }
  this->num_instr_cycles += UpdatePSRSubWithCarry(this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::SBC_sr::SBC_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  UpdatePSRSubWithCarryOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // SBC_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SBC_sr::get_id() const throw() {

  return 11;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SBC_sr::get_name() const throw() {

  return "SBC_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SBC_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "SBC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::SBC_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::SBC_sr::replicate(Instruction* instr)
const throw() {

  SBC_sr* new_instr = new SBC_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    SBC_sr* old_instr = dynamic_cast<SBC_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SBC_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid SBC (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  operand1 = (int)rn;
  operand2 = (int)operand;
  result = operand1 - operand2;

  if (CPSR[CPSR_C] == 0x0) {
    result = ((int)result) - 1;
  }
  this->num_instr_cycles += UpdatePSRSubWithCarry(this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::RSB_i::RSB_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ARMExpandImmOp(R, instr_memory, data_memory),
  UpdatePSRSubOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // RSB_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::RSB_i::get_id() const throw() {

  return 12;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::RSB_i::get_name() const throw() {

  return "RSB_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::RSB_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "RSB";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::RSB_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::RSB_i::replicate(Instruction* instr) const
throw() {

  RSB_i* new_instr = new RSB_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    RSB_i* old_instr = dynamic_cast<RSB_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->rotate = old_instr->rotate;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::RSB_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  operand1 = (int)operand;
  operand2 = (int)rn;
  result = operand1 - operand2;
  this->num_instr_cycles += UpdatePSRSub(this->rd, this->rd_bit, this->s,
  this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::RSB_r::RSB_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  UpdatePSRSubOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // RSB_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::RSB_r::get_id() const throw() {

  return 13;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::RSB_r::get_name() const throw() {

  return "RSB_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::RSB_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "RSB";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::RSB_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::RSB_r::replicate(Instruction* instr) const
throw() {

  RSB_r* new_instr = new RSB_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    RSB_r* old_instr = dynamic_cast<RSB_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::RSB_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  operand1 = (int)operand;
  operand2 = (int)rn;
  result = operand1 - operand2;
  this->num_instr_cycles += UpdatePSRSub(this->rd, this->rd_bit, this->s,
  this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::RSB_sr::RSB_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  UpdatePSRSubOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // RSB_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::RSB_sr::get_id() const throw() {

  return 14;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::RSB_sr::get_name() const throw() {

  return "RSB_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::RSB_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "RSB";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::RSB_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::RSB_sr::replicate(Instruction* instr)
const throw() {

  RSB_sr* new_instr = new RSB_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    RSB_sr* old_instr = dynamic_cast<RSB_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::RSB_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid RSB (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  operand1 = (int)operand;
  operand2 = (int)rn;
  result = operand1 - operand2;
  this->num_instr_cycles += UpdatePSRSub(this->rd, this->rd_bit, this->s,
  this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::RSC_i::RSC_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ARMExpandImmOp(R, instr_memory, data_memory),
  UpdatePSRSubWithCarryOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // RSC_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::RSC_i::get_id() const throw() {

  return 15;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::RSC_i::get_name() const throw() {

  return "RSC_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::RSC_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "RSC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::RSC_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::RSC_i::replicate(Instruction* instr) const
throw() {

  RSC_i* new_instr = new RSC_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    RSC_i* old_instr = dynamic_cast<RSC_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->rotate = old_instr->rotate;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::RSC_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  operand1 = (int)operand;
  operand2 = (int)rn;
  result = operand1 - operand2;

  if (CPSR[CPSR_C] == 0x0) {
    result = ((int)result) - 1;
  }
  this->num_instr_cycles += UpdatePSRSubWithCarry(this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::RSC_r::RSC_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  UpdatePSRSubWithCarryOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // RSC_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::RSC_r::get_id() const throw() {

  return 16;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::RSC_r::get_name() const throw() {

  return "RSC_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::RSC_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "RSC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::RSC_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::RSC_r::replicate(Instruction* instr) const
throw() {

  RSC_r* new_instr = new RSC_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    RSC_r* old_instr = dynamic_cast<RSC_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::RSC_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  operand1 = (int)operand;
  operand2 = (int)rn;
  result = operand1 - operand2;

  if (CPSR[CPSR_C] == 0x0) {
    result = ((int)result) - 1;
  }
  this->num_instr_cycles += UpdatePSRSubWithCarry(this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::RSC_sr::RSC_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  UpdatePSRSubWithCarryOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // RSC_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::RSC_sr::get_id() const throw() {

  return 17;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::RSC_sr::get_name() const throw() {

  return "RSC_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::RSC_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "RSC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::RSC_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::RSC_sr::replicate(Instruction* instr)
const throw() {

  RSC_sr* new_instr = new RSC_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    RSC_sr* old_instr = dynamic_cast<RSC_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::RSC_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid RSC (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  operand1 = (int)operand;
  operand2 = (int)rn;
  result = operand1 - operand2;

  if (CPSR[CPSR_C] == 0x0) {
    result = ((int)result) - 1;
  }
  this->num_instr_cycles += UpdatePSRSubWithCarry(this->rd, this->rd_bit,
  this->s, this->operand1, this->operand2, this->result);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::USHQADD::USHQADD(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // USHQADD()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USHQADD::get_id() const throw() {

  return 18;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USHQADD::get_name() const throw() {

  return "USHQADD";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USHQADD::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->u) {
    case 0: {
      oss << "S";
    break;}
    case 1: {
      oss << "U";
    break;}
  }
  switch(this->h) {
    case 1: {
      switch(this->nq) {
        case 0: {
          oss << "Q";
        break;}
        case 1: {
          oss << "H";
        break;}
      }
    break;}
  }
  oss << "ADD";
  switch(this->b) {
    case 0: {
      oss << "16";
    break;}
    case 1: {
      oss << "8";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::USHQADD::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->u = (bitstring & 0x400000) >> 22;
  this->h = (bitstring & 0x200000) >> 21;
  this->nq = (bitstring & 0x100000) >> 20;
  this->b = (bitstring & 0x80) >> 7;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::USHQADD::replicate(Instruction* instr)
const throw() {

  USHQADD* new_instr = new USHQADD(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    USHQADD* old_instr = dynamic_cast<USHQADD*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->u = old_instr->u;
      new_instr->h = old_instr->h;
      new_instr->nq = old_instr->nq;
      new_instr->b = old_instr->b;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USHQADD::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (U|S|UH|SH|UQ|Q)ADD(8|16) encoding: rn|rd|rm = 0xF.");

  if (rs_bit != 15)
  THROW_WARNING("Invalid (U|S|UH|SH|UQ|Q)ADD(8|16) encoding: rs != 0xF.");

  int sum1, sum2 = 0, sum3, sum4 = 0, sign;
  unsigned mask;
  unsigned shift2, shift3, shift4;
  int overflow;

  // 16-bit vs. 8-bit
  if (b) {
    // xxADD8
    mask = 0x000000FF;
    shift2 = 8;
    shift3 = 16;
    shift4 = 24;
  } else {
    // xxADD16
    mask = 0x0000FFFF;
    shift2 = 0;
    shift3 = 16;
    shift4 = 0;
  }

  // Unsigned vs. signed
  if (u) {
    // UxADDx
    sum1 = (unsigned)(rn & mask) + (unsigned)(rm & mask);
    sum2 = shift2? ((unsigned)(rn >> shift2) & mask) + ((unsigned)(rm >> shift2)
    & mask) : 0;
    sum3 = ((unsigned)(rn >> shift3) & mask) + ((unsigned)(rm >> shift3) &
    mask);
    sum4 = shift4? ((unsigned)(rn >> shift4) & mask) + ((unsigned)(rm >> shift4)
    & mask) : 0;
    overflow = mask;
  } else {
    // SxADDx
    // Detect sign to enable sign extension.
    sign = 0x1 << (shift2? shift2 - 1 : shift3 - 1);
    sum1 = ((int)(rn & mask) | (rn & sign? ~mask : 0))
    + ((int)(rm & mask) | (rm & sign? ~mask : 0));

    if (shift2) {
      sign = 0x1 << (shift3 - 1);
      sum2 = (((int)(rn >> shift2) & mask) | (rn & sign? ~mask : 0))
      + (((int)(rm >> shift2) & mask) | (rm & sign? ~mask : 0));
    }

    sign = 0x1 << (shift4? shift4 - 1 : 31);
    sum3 = (((int)(rn >> shift3) & mask) | (rn & sign? ~mask : 0))
    + (((int)(rm >> shift3) & mask) | (rm & sign? ~mask : 0));

    if (shift4) {
      sign = 0x1 << 31;
      sum4 = (((int)(rn >> shift4) & mask) | (rn & sign? ~mask : 0))
      + (((int)(rm >> shift4) & mask) | (rm & sign? ~mask : 0));
    }
    overflow = -1;
  }

  // Halving vs. saturating vs. regular
  if (h && nq) {
    // xHADDx
    sum1 >>= 1;
    sum2 >>= 1;
    sum3 >>= 1;
    sum4 >>= 1;
  } else if (!nq) {
    // xQADDx
    sum1 = sat_q(sum1, 16 >> b, !u, false);
    sum2 = sat_q(sum2, 16 >> b, !u, false);
    sum3 = sat_q(sum3, 16 >> b, !u, false);
    sum4 = sat_q(sum4, 16 >> b, !u, false);
  } else {
    // x_ADDx
    CPSR[CPSR_GE] = 0;
    if (sum1 > overflow) {
      CPSR[CPSR_GE] = 0x1;
      if (!shift2) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x2;
    }
    if (sum2 > overflow && shift2) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x2;
    if (sum3 > overflow) {
      CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x4;
      if (!shift4) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x8;
    }
    if (sum4 > overflow && shift4) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x8;
  }

  rd = (shift4? ((sum4 & mask) << shift4) : 0)
  | ((sum3 & mask) << shift3)
  | (shift2? ((sum2 & mask) << shift2) : 0)
  | (sum1 & mask);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::USHQSUB::USHQSUB(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // USHQSUB()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USHQSUB::get_id() const throw() {

  return 19;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USHQSUB::get_name() const throw() {

  return "USHQSUB";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USHQSUB::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->u) {
    case 0: {
      oss << "S";
    break;}
    case 1: {
      oss << "U";
    break;}
  }
  switch(this->h) {
    case 1: {
      switch(this->nq) {
        case 0: {
          oss << "Q";
        break;}
        case 1: {
          oss << "H";
        break;}
      }
    break;}
  }
  oss << "SUB";
  switch(this->b) {
    case 0: {
      oss << "16";
    break;}
    case 1: {
      oss << "8";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::USHQSUB::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->u = (bitstring & 0x400000) >> 22;
  this->h = (bitstring & 0x200000) >> 21;
  this->nq = (bitstring & 0x100000) >> 20;
  this->b = (bitstring & 0x80) >> 7;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::USHQSUB::replicate(Instruction* instr)
const throw() {

  USHQSUB* new_instr = new USHQSUB(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    USHQSUB* old_instr = dynamic_cast<USHQSUB*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->u = old_instr->u;
      new_instr->h = old_instr->h;
      new_instr->nq = old_instr->nq;
      new_instr->b = old_instr->b;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USHQSUB::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (U|S|UH|SH|UQ|Q)SUB(8|16) encoding: rn|rd|rm = 0xF.");

  if (rs_bit != 15)
  THROW_WARNING("Invalid (U|S|UH|SH|UQ|Q)SUB(8|16) encoding: rs != 0xF.");

  int sum1, sum2 = 0, sum3, sum4 = 0, sign;
  unsigned mask;
  unsigned shift2, shift3, shift4;

  // 16-bit vs. 8-bit
  if (b) {
    // xxSUB8
    mask = 0x000000FF;
    shift2 = 8;
    shift3 = 16;
    shift4 = 24;
  } else {
    // xxSUB16
    mask = 0x0000FFFF;
    shift2 = 0;
    shift3 = 16;
    shift4 = 0;
  }

  // Unsigned vs. signed
  if (u) {
    // UxSUBx
    sum1 = (unsigned)(rn & mask) - (unsigned)(rm & mask);
    sum2 = shift2? (((unsigned)rn >> shift2) & mask) - (((unsigned)rm >> shift2)
    & mask) : 0;
    sum3 = (((unsigned)rn >> shift3) & mask) - (((unsigned)rm >> shift3) &
    mask);
    sum4 = shift4? (((unsigned)rn >> shift4) & mask) - (((unsigned)rm >> shift4)
    & mask) : 0;
  } else {
    // SxSUBx
    // Detect sign to enable sign extension.
    sign = 0x1 << (shift2? shift2 - 1 : shift3 - 1);
    sum1 = ((int)(rn & mask) | (rn & sign? ~mask : 0))
    - ((int)(rm & mask) | (rm & sign? ~mask : 0));

    if (shift2) {
      sign = 0x1 << (shift3 - 1);
      sum2 = (((int)(rn >> shift2) & mask) | (rn & sign? ~mask : 0))
      - (((int)(rm >> shift2) & mask) | (rm & sign? ~mask : 0));
    }

    sign = 0x1 << (shift4? shift4 - 1 : 31);
    sum3 = (((int)(rn >> shift3) & mask) | (rn & sign? ~mask : 0))
    - (((int)(rm >> shift3) & mask) | (rm & sign? ~mask : 0));

    if (shift4) {
      sign = 0x1 << 31;
      sum4 = (((int)(rn >> shift4) & mask) | (rn & sign? ~mask : 0))
      - (((int)(rm >> shift4) & mask) | (rm & sign? ~mask : 0));
    }
  }

  // Halving vs. saturating vs. regular
  if (h && nq) {
    // xHSUBx
    sum1 >>= 1;
    sum2 >>= 1;
    sum3 >>= 1;
    sum4 >>= 1;
  } else if (!nq) {
    // xQSUBx
    sum1 = sat_q(sum1, 16 >> b, !u, false);
    sum2 = sat_q(sum2, 16 >> b, !u, false);
    sum3 = sat_q(sum3, 16 >> b, !u, false);
    sum4 = sat_q(sum4, 16 >> b, !u, false);
  } else {
    // x_SUBx
    CPSR[CPSR_GE] = 0;
    if (sum1 >= 0) {
      CPSR[CPSR_GE] = 0x1;
      if (!shift2) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x2;
    }
    if (sum2 >= 0 && shift2) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x2;
    if (sum3 >= 0) {
      CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x4;
      if (!shift4) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x8;
    }
    if (sum4 >= 0 && shift4) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x8;
  }

  rd = (shift4? ((sum4 & mask) << shift4) : 0)
  | ((sum3 & mask) << shift3)
  | (shift2? ((sum2 & mask) << shift2) : 0)
  | (sum1 & mask);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::USADA8::USADA8(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // USADA8()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USADA8::get_id() const throw() {

  return 20;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USADA8::get_name() const throw() {

  return "USADA8";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USADA8::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->ra_bit) {
    default: {
      oss << "USADA8";
    break;}
    case 15: {
      oss << "USAD8";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::USADA8::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf0000) >> 16;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf00) >> 8;
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf);
  this->rn.set_alias(REGS[this->rn_bit]);
  this->ra_bit = (bitstring & 0xf000) >> 12;
  this->ra.set_alias(REGS[this->ra_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::USADA8::replicate(Instruction* instr)
const throw() {

  USADA8* new_instr = new USADA8(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    USADA8* old_instr = dynamic_cast<USADA8*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->ra_bit = old_instr->ra_bit;
      new_instr->ra.set_alias(REGS[new_instr->ra_bit]);
      new_instr->cond = old_instr->cond;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USADA8::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (USAD8/USADA8 encoding: rn|rd|rm = 0xF.");

  int diff1, diff2, diff3, diff4;

  diff1 = (unsigned)(rn & 0x000000FF) - (unsigned)(rm & 0x000000FF);
  diff1 = (diff1 < 0)? -diff1 : diff1;
  diff2 = ((unsigned)(rn & 0x0000FF00) >> 8) - ((unsigned)(rm & 0x0000FF00) >>
  8);
  diff2 = (diff2 < 0)? -diff2 : diff2;
  diff3 = ((unsigned)(rn & 0x00FF0000) >> 16) - ((unsigned)(rm & 0x00FF0000) >>
  16);
  diff3 = (diff3 < 0)? -diff3 : diff3;
  diff4 = ((unsigned)(rn & 0xFF000000) >> 24) - ((unsigned)(rm & 0xFF000000) >>
  24);
  diff4 = (diff4 < 0)? -diff4 : diff4;
  // NOTE: Alternative abs():
  // mask = 0 for diff1 > 0 else mask = 0xFFFFFFFF because of signed shift.
  // int mask = diff1 >> 31;
  // diff1 + mask = diff1 for diff1 > 0 else diff1 + mask = ~abs(diff1)
  // diff1 = (diff1 + mask) ^ mask;

  if (ra != 0xF)
  rd = (ra + diff1 + diff2 + diff3 + diff4) & 0xFFFFFFFF;
  else
  rd = (diff1 + diff2 + diff3 + diff4) & 0xFFFFFFFF;
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::USXTAHB::USXTAHB(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // USXTAHB()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USXTAHB::get_id() const throw() {

  return 21;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USXTAHB::get_name() const throw() {

  return "USXTAHB";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USXTAHB::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->u) {
    case 0: {
      oss << "S";
    break;}
    case 1: {
      oss << "U";
    break;}
  }
  oss << "XT";
  switch(this->rn_bit) {
    default: {
      oss << "A";
    break;}
    case 15: {
      oss << "";
    break;}
  }
  switch(this->h) {
    case 0: {
      oss << "B";
    break;}
    case 1: {
      oss << "H";
    break;}
  }
  switch(this->w) {
    case 0: {
      oss << "16";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->imm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::USXTAHB::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->u = (bitstring & 0x400000) >> 22;
  this->w = (bitstring & 0x200000) >> 21;
  this->h = (bitstring & 0x100000) >> 20;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::USXTAHB::replicate(Instruction* instr)
const throw() {

  USXTAHB* new_instr = new USXTAHB(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    USXTAHB* old_instr = dynamic_cast<USXTAHB*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->u = old_instr->u;
      new_instr->w = old_instr->w;
      new_instr->h = old_instr->h;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USXTAHB::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (UX|SX)(TH|TAH|TB(16)?|TAB(16)?) encoding: rd|rm = 0xF.");

  if (imm & 0x3)
  THROW_WARNING("Invalid (UX|SX)(TH|TAH|TB(16)?|TAB(16)?) encoding: bit[9:8] != 0x0.");

  unsigned mask;
  int result;

  // 16-bit vs. 8-bit source
  // xXTxH
  if (h) mask = 0xFFFF;
  // xXTxBx
  else mask = 0xFF;

  bool carry_dummy;
  result = ROR(rm, (imm << 1) & 0x18, carry_dummy);

  // Extend-to-word vs. extend-to-halfword
  if (w) {
    // xXTxx
    result &= mask;

    // Unsigned vs. signed
    if (!u) result = sign_extend(result, 8 << h);

    // Add vs. non-add
    if (rn_bit != 0xF) result += (unsigned)rn;

    rd = result;
  } else {
    // xXTxB16
    int result2 = (result & 0x00FF0000) >> 16;
    result &= mask;

    // Unsigned vs. signed
    if (!u) {
      result2 = sign_extend(result2, 8) & 0xFFFF;
      result = sign_extend(result, 8) & 0xFFFF;
    }

    // Add vs. non-add
    if (rn_bit != 0xF) {
      result = ((((unsigned)rn & 0xFFFF) + result) & 0xFFFF)
      | ((((((unsigned)rn >> 16) & 0xFFFF) + result2) & 0xFFFF) << 16);
    }
    rd = result;
  }
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::USHQASX::USHQASX(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // USHQASX()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USHQASX::get_id() const throw() {

  return 22;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USHQASX::get_name() const throw() {

  return "USHQASX";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USHQASX::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->u) {
    case 0: {
      oss << "S";
    break;}
    case 1: {
      oss << "U";
    break;}
  }
  switch(this->h) {
    case 1: {
      switch(this->nq) {
        case 0: {
          oss << "Q";
        break;}
        case 1: {
          oss << "H";
        break;}
      }
    break;}
  }
  oss << "ASX";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::USHQASX::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->u = (bitstring & 0x400000) >> 22;
  this->h = (bitstring & 0x200000) >> 21;
  this->nq = (bitstring & 0x100000) >> 20;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::USHQASX::replicate(Instruction* instr)
const throw() {

  USHQASX* new_instr = new USHQASX(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    USHQASX* old_instr = dynamic_cast<USHQASX*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->u = old_instr->u;
      new_instr->h = old_instr->h;
      new_instr->nq = old_instr->nq;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USHQASX::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (U|S|UH|SH|UQ|Q)ASX encoding: rn|rd|rm = 0xF.");

  if (rs_bit != 15)
  THROW_WARNING("Invalid (U|S|UH|SH|UQ|Q)ASX encoding: rs != 0xF.");

  int sum, diff;
  unsigned mask = 0xFFFF;

  // Unsigned vs. signed
  if (u) {
    // UxASX
    sum = (((unsigned)rn >> 16) & mask) + ((unsigned)rm & mask);
    diff = ((unsigned)rn & mask) - (((unsigned)rm >> 16) & mask);
  } else {
    // SxASX
    sum = sign_extend((rn >> 16) & mask, 16) + sign_extend(rm & mask, 16);
    diff = sign_extend(rn & mask, 16) - sign_extend((rm >> 16) & mask, 16);
  }

  // Halving vs. saturating vs. regular
  if (h && nq) {
    // xHASX
    sum >>= 1;
    diff >>= 1;
  } else if (!nq) {
    // xQSAX
    sum = sat_q(sum, 16, !u, false);
    diff = sat_q(diff, 16, !u, false);
  } else {
    // x_ASX
    if (diff >= 0) CPSR[CPSR_GE] = 0x3;
    else CPSR[CPSR_GE] = 0;
    if (u && sum > 0xFFFF) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0xC;
    else if (!u && sum >= 0) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0xC;
  }

  rd = ((sum & mask) << 16) | (diff & mask);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::USHQSAX::USHQSAX(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // USHQSAX()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USHQSAX::get_id() const throw() {

  return 23;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USHQSAX::get_name() const throw() {

  return "USHQSAX";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USHQSAX::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->u) {
    case 0: {
      oss << "S";
    break;}
    case 1: {
      oss << "U";
    break;}
  }
  switch(this->h) {
    case 1: {
      oss << "H";
    break;}
  }
  oss << "SAX";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::USHQSAX::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->u = (bitstring & 0x400000) >> 22;
  this->h = (bitstring & 0x200000) >> 21;
  this->nq = (bitstring & 0x100000) >> 20;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::USHQSAX::replicate(Instruction* instr)
const throw() {

  USHQSAX* new_instr = new USHQSAX(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    USHQSAX* old_instr = dynamic_cast<USHQSAX*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->u = old_instr->u;
      new_instr->h = old_instr->h;
      new_instr->nq = old_instr->nq;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USHQSAX::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (U|S|UH|SH|UQ|Q)SAX encoding: rn|rd|rm = 0xF.");

  if (rs_bit != 15)
  THROW_WARNING("Invalid (U|S|UH|SH|UQ|Q)SAX encoding: rs != 0xF.");

  int sum, diff;
  unsigned mask = 0xFFFF;

  // Unsigned vs. signed
  if (u) {
    // UxSAX
    sum = ((unsigned)rn & mask) + (((unsigned)rm >> 16) & mask);
    diff = (((unsigned)rn >> 16) & mask) - ((unsigned)rm & mask);
  } else {
    // SxSAX
    sum = sign_extend(rn & mask, 16) + sign_extend((rm >> 16) & mask, 16);
    diff = sign_extend((rn >> 16) & mask, 16) - sign_extend(rm & mask, 16);
  }

  // Halving vs. saturating vs. regular
  if (h && nq) {
    // xHSAX
    sum >>= 1;
    diff >>= 1;
  } else if (!nq) {
    // xQSAX
    sum = sat_q(sum, 16, !u, false);
    diff = sat_q(diff, 16, !u, false);
  } else {
    // x_SAX
    if (diff >= 0) CPSR[CPSR_GE] = 0xC;
    else CPSR[CPSR_GE] = 0;
    if (u && sum > 0xFFFF) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x3;
    else if (!u && sum >= 0) CPSR[CPSR_GE] = CPSR[CPSR_GE] | 0x3;
  }

  rd = ((diff & mask) << 16) | (sum & mask);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::USSAT::USSAT(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // USSAT()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USSAT::get_id() const throw() {

  return 24;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USSAT::get_name() const throw() {

  return "USSAT";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USSAT::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->u) {
    case 0: {
      oss << "S";
    break;}
    case 1: {
      oss << "U";
    break;}
  }
  oss << "SAT";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->imm1;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->op1a;
  oss << "0";
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::USSAT::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->u = (bitstring & 0x400000) >> 22;
  this->imm0 = (bitstring & 0x1f0000) >> 16;
  this->imm1 = (bitstring & 0xf80) >> 7;
  this->op1a = (bitstring & 0x40) >> 6;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::USSAT::replicate(Instruction* instr) const
throw() {

  USSAT* new_instr = new USSAT(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    USSAT* old_instr = dynamic_cast<USSAT*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->u = old_instr->u;
      new_instr->imm0 = old_instr->imm0;
      new_instr->imm1 = old_instr->imm1;
      new_instr->op1a = old_instr->op1a;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USSAT::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (U|S)SAT encoding: rd|rm = 0xF.");

  // Needed by DecodeImmShift().
  shift_amm = imm1;
  shift_op = (op1a << 1);
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  rd = sat_q((int)operand, imm0 + !u, !u, true);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::USSAT16::USSAT16(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // USSAT16()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USSAT16::get_id() const throw() {

  return 25;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USSAT16::get_name() const throw() {

  return "USSAT16";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USSAT16::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->u) {
    case 0: {
      oss << "S";
    break;}
    case 1: {
      oss << "U";
    break;}
  }
  oss << "SAT16";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->imm;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::USSAT16::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->u = (bitstring & 0x400000) >> 22;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::USSAT16::replicate(Instruction* instr)
const throw() {

  USSAT16* new_instr = new USSAT16(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    USSAT16* old_instr = dynamic_cast<USSAT16*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->u = old_instr->u;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USSAT16::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (U|S)SAT16 encoding: rd|rm = 0xF.");

  if (imm != 15)
  THROW_WARNING("Invalid (U|S)SAT16 encoding: Bits: [11..8] != 0xF.");

  long long operand = sign_extend(rm & 0x0000FFFF, 16);
  unsigned result = sat_q(operand, imm+!u, !u, true) & 0xFFFF;
  bool is_sat = CPSR[CPSR_Q];
  operand = sign_extend((rm & 0xFFFF0000) >> 16, 16);
  result = result | ((sat_q(operand, imm+!u, !u, true) & 0xFFFF) << 16);
  if (is_sat) CPSR[CPSR_Q] = 1;
  rd = result;
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::QDADDSUB::QDADDSUB(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // QDADDSUB()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::QDADDSUB::get_id() const throw() {

  return 26;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::QDADDSUB::get_name() const throw() {

  return "QDADDSUB";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::QDADDSUB::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "Q";
  switch(this->d) {
    case 1: {
      oss << "D";
    break;}
  }
  switch(this->s) {
    case 0: {
      oss << "ADD";
    break;}
    case 1: {
      oss << "SUB";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::QDADDSUB::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->d = (bitstring & 0x400000) >> 22;
  this->s = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::QDADDSUB::replicate(Instruction* instr)
const throw() {

  QDADDSUB* new_instr = new QDADDSUB(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    QDADDSUB* old_instr = dynamic_cast<QDADDSUB*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->d = old_instr->d;
      new_instr->s = old_instr->s;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::QDADDSUB::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid (Q|QD)(ADD|SUB) encoding: rn|rd|rm = 0xF.");

  if (imm != 0)
  THROW_WARNING("Invalid (U|S|UH|SH|UQ|Q)ASX encoding: bit[11:8] != 0x0.");

  long long operand = sign_extend(rn, 32);

  // Double vs. regular
  if (d) operand = sign_extend(sat_q(operand << 1, 32, true, true), 32);

  // Add vs. subtract
  if (s) operand = sign_extend(rm, 32) - operand;
  else operand = sign_extend(rm, 32) + operand;

  // NOTE: CPSR[CPSR_Q] = sat1 || sat2
  rd = sat_q(operand, 32, 1, !(d && CPSR[CPSR_Q]));
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::MUL::MUL(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  UpdatePSRMulOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // MUL()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::MUL::get_id() const throw() {

  return 27;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::MUL::get_name() const throw() {

  return "MUL";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::MUL::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->a) {
    case 0: {
      oss << "MUL";
    break;}
    case 1: {
      oss << "ML";
    break;}
  }
  switch(this->ss) {
    case 0: {
      oss << "A";
    break;}
    case 1: {
      oss << "S";
    break;}
  }
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", R";
  oss << std::dec << this->ra_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::MUL::set_params(const unsigned& bitstring) throw()
{

  this->rd_bit = (bitstring & 0xf0000) >> 16;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf00) >> 8;
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf);
  this->rn.set_alias(REGS[this->rn_bit]);
  this->ra_bit = (bitstring & 0xf000) >> 12;
  this->ra.set_alias(REGS[this->ra_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->l = (bitstring & 0x800000) >> 23;
  this->ss = (bitstring & 0x400000) >> 22;
  this->a = (bitstring & 0x200000) >> 21;
  this->s = (bitstring & 0x100000) >> 20;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::MUL::replicate(Instruction* instr) const
throw() {

  MUL* new_instr = new MUL(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    MUL* old_instr = dynamic_cast<MUL*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->ra_bit = old_instr->ra_bit;
      new_instr->ra.set_alias(REGS[new_instr->ra_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->l = old_instr->l;
      new_instr->ss = old_instr->ss;
      new_instr->a = old_instr->a;
      new_instr->s = old_instr->s;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::MUL::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15) || (rn_bit == 15))
  THROW_EXCEPTION("Invalid MUL/MLA/MLS encoding: rd|rm|rn = 0xF.");

  if (a && (ra_bit == 15))
  THROW_EXCEPTION("Invalid MLA/MLS encoding: ra = 0xF.");

  if (!a && ra_bit)
  THROW_WARNING("Invalid MUL encoding: ra != 0x0.");

  unsigned latency = 0;

  result = sign_extend(rm, 32) * sign_extend(rn, 32);

  // Accumulate vs. non-accumulate
  if (a) {
    // MLA/MLS
    latency++;
    // Add vs. subtract
    if (ss) {
      // MLS
      result = (sign_extend(ra, 32) - result) & 0x00000000FFFFFFFFLL;
    } else {
      // MLA
      result = (sign_extend(ra, 32) + result) & 0x00000000FFFFFFFFLL;
    }
  }
  rd = result & 0x00000000FFFFFFFFLL;

  // TODO: Compare stall cycles against Cortex A9 spec (rm: bits8-11).
  if ((rm & 0xFFFFFF00) == 0x0 || (rm & 0xFFFFFF00) == 0xFFFFFF00) {
    stall(1+latency);
  } else if ((rm & 0xFFFF0000) == 0x0 || (rm & 0xFFFF0000) == 0xFFFF0000) {
    stall(2+latency);
  } else if ((rm & 0xFF000000) == 0x0 || (rm & 0xFF000000) == 0xFF000000) {
    stall(3+latency);
  } else {
    stall(4+latency);
  }
  this->num_instr_cycles += UpdatePSRMul(this->ss, this->s, this->l, this->result);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::SMMUL::SMMUL(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // SMMUL()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SMMUL::get_id() const throw() {

  return 28;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SMMUL::get_name() const throw() {

  return "SMMUL";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SMMUL::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->ra_bit) {
    default: {
      switch(this->op1a) {
        case 0: {
          oss << "SMMLA";
        break;}
        case 3: {
          oss << "SMMLS";
        break;}
      }
    break;}
    case 15: {
      oss << "SMMUL";
    break;}
  }
  switch(this->op1b) {
    case 1: {
      oss << "R";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", R";
  oss << std::dec << this->ra_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::SMMUL::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf0000) >> 16;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf00) >> 8;
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf);
  this->rn.set_alias(REGS[this->rn_bit]);
  this->ra_bit = (bitstring & 0xf000) >> 12;
  this->ra.set_alias(REGS[this->ra_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->op1a = (bitstring & 0xc0) >> 6;
  this->op1b = (bitstring & 0x20) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::SMMUL::replicate(Instruction* instr) const
throw() {

  SMMUL* new_instr = new SMMUL(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    SMMUL* old_instr = dynamic_cast<SMMUL*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->ra_bit = old_instr->ra_bit;
      new_instr->ra.set_alias(REGS[new_instr->ra_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->op1a = old_instr->op1a;
      new_instr->op1b = old_instr->op1b;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SMMUL::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15) || (rn_bit == 15))
  THROW_EXCEPTION("Invalid SMMUL/SMMLA/SMMLS encoding: rd|rm|rn = 0xF.");

  if ((op1a == 3) && (ra_bit == 15))
  THROW_EXCEPTION("Invalid SMMLS encoding: ra = 0xF.");

  unsigned latency = 0;

  long long result = sign_extend(rm, 32) * sign_extend(rn, 32);

  // Accumulate vs. non-accumulate
  if (ra_bit != 15) {
    // SMMLA/SMMLS
    latency++;
    // Add vs. subtract
    if (op1a == 3) {
      // SMMLS
      result = (sign_extend(ra, 32) << 32) - result;
    } else if (!op1a) {
      // SMMLA
      result = (sign_extend(ra, 32) << 32) + result;
    }
  }

  if (op1b) result += 0x0000000080000000LL;
  rd = (result >> 32) & 0x00000000FFFFFFFFLL;

  // TODO: Compare stall cycles against Cortex A9 spec (rm: bits8-11).
  if (!(rm & 0xFFFFFF00) || (rm & 0xFFFFFF00) == 0xFFFFFF00) {
    stall(1+latency);
  } else if (!(rm & 0xFFFF0000) || (rm & 0xFFFF0000) == 0xFFFF0000) {
    stall(2+latency);
  } else if (!(rm & 0xFF000000) || (rm & 0xFF000000) == 0xFF000000) {
    stall(3+latency);
  } else {
    stall(4+latency);
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::MULL::MULL(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  UpdatePSRMulOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // MULL()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::MULL::get_id() const throw() {

  return 29;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::MULL::get_name() const throw() {

  return "MULL";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::MULL::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->ss) {
    case 0: {
      oss << "U";
    break;}
    case 1: {
      oss << "S";
    break;}
  }
  switch(this->a) {
    case 0: {
      oss << "MULL";
    break;}
    case 1: {
      oss << "MLAL";
    break;}
  }
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->ra_bit;
  oss << ", R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::MULL::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf0000) >> 16;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf00) >> 8;
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf);
  this->rn.set_alias(REGS[this->rn_bit]);
  this->ra_bit = (bitstring & 0xf000) >> 12;
  this->ra.set_alias(REGS[this->ra_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->l = (bitstring & 0x800000) >> 23;
  this->ss = (bitstring & 0x400000) >> 22;
  this->a = (bitstring & 0x200000) >> 21;
  this->s = (bitstring & 0x100000) >> 20;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::MULL::replicate(Instruction* instr) const
throw() {

  MULL* new_instr = new MULL(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    MULL* old_instr = dynamic_cast<MULL*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->ra_bit = old_instr->ra_bit;
      new_instr->ra.set_alias(REGS[new_instr->ra_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->l = old_instr->l;
      new_instr->ss = old_instr->ss;
      new_instr->a = old_instr->a;
      new_instr->s = old_instr->s;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::MULL::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (ra_bit == 15) || (rm_bit == 15) || (rn_bit == 15))
  THROW_EXCEPTION("Invalid UMULL/SMULL/UMLAL/SMLAL encoding: rd|ra|rm|rn = 0xF.");

  if (rd_bit == ra_bit)
  THROW_EXCEPTION("Invalid UMULL/SMULL/UMLAL/SMLAL encoding: rd = ra.");

  unsigned latency = 2;

  // Unsigned vs. signed
  if (ss) {
    // SMULL/SMLAL
    result = (long long)((long long)rm * (long long)rn);
    // Accumulate vs. non-accumulate
    if (a) {
      // SMLAL
      result += (long long)((((long long)rd << 32) & 0xFFFFFFFF00000000LL)
      + ((long long)ra & 0x00000000FFFFFFFFLL));
    }
    rd = (int)(((unsigned long)result >> 32) & 0x00000000FFFFFFFFLL);
    ra = (int)(result & 0x00000000FFFFFFFFLL);
  } else {
    // UMULL/UMLAL
    result = (unsigned long long)((unsigned long long)rm * (unsigned long
    long)rn);
    // Accumulate vs. non-accumulate
    if (a) {
      // UMLAL
      result += (unsigned long long)((((unsigned long long)rd << 32) & 0xFFFFFFFF00000000LL)
      + ((unsigned long long)ra & 0x00000000FFFFFFFFLL));
    }
    rd = (unsigned long)(((unsigned long)result >> 32) & 0x00000000FFFFFFFFLL);
    ra = (unsigned long)(result & 0x00000000FFFFFFFFLL);
  }

  // TODO: Compare stall cycles against Cortex A9 spec (rm: bits8-11).
  if (!(rm & 0xFFFFFF00) || (rm & 0xFFFFFF00) == 0xFFFFFF00) {
    stall(1+latency);
  } else if (!(rm & 0xFFFF0000) || (rm & 0xFFFF0000) == 0xFFFF0000) {
    stall(2+latency);
  } else if (!(rm & 0xFF000000) || (rm & 0xFF000000) == 0xFF000000) {
    stall(3+latency);
  } else {
    stall(4+latency);
  }
  this->num_instr_cycles += UpdatePSRMul(this->ss, this->s, this->l, this->result);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::UMAAL::UMAAL(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // UMAAL()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::UMAAL::get_id() const throw() {

  return 30;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::UMAAL::get_name() const throw() {

  return "UMAAL";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::UMAAL::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "UMAAL";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->ra_bit;
  oss << ", R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::UMAAL::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf0000) >> 16;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf00) >> 8;
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf);
  this->rn.set_alias(REGS[this->rn_bit]);
  this->ra_bit = (bitstring & 0xf000) >> 12;
  this->ra.set_alias(REGS[this->ra_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::UMAAL::replicate(Instruction* instr) const
throw() {

  UMAAL* new_instr = new UMAAL(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    UMAAL* old_instr = dynamic_cast<UMAAL*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->ra_bit = old_instr->ra_bit;
      new_instr->ra.set_alias(REGS[new_instr->ra_bit]);
      new_instr->cond = old_instr->cond;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::UMAAL::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (ra_bit == 15) || (rm_bit == 15) || (rn_bit == 15))
  THROW_EXCEPTION("Invalid UMAAL encoding: rd|ra|rm|rn = 0xF.");

  if (rd_bit == ra_bit)
  THROW_EXCEPTION("Invalid UMAAL encoding: rd = ra.");

  unsigned latency = 2;

  unsigned long long result
  = (unsigned long long)(((unsigned long long)rm * (unsigned long long)rn)
  + (((unsigned long long)rd << 32) & 0xFFFFFFFF00000000LL)
  + ((unsigned long long)ra & 0x00000000FFFFFFFFLL));

  rd = (unsigned)(((unsigned long)result >> 32) & 0x00000000FFFFFFFFLL);
  ra = (unsigned)(result & 0x00000000FFFFFFFFLL);

  // TODO: Compare stall cycles against Cortex A9 spec (rm: bits8-11).
  if (!(rm & 0xFFFFFF00) || (rm & 0xFFFFFF00) == 0xFFFFFF00) {
    stall(1+latency);
  } else if (!(rm & 0xFFFF0000) || (rm & 0xFFFF0000) == 0xFFFF0000) {
    stall(2+latency);
  } else if (!(rm & 0xFF000000) || (rm & 0xFF000000) == 0xFF000000) {
    stall(3+latency);
  } else {
    stall(4+latency);
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::SMULBW::SMULBW(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // SMULBW()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SMULBW::get_id() const throw() {

  return 31;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SMULBW::get_name() const throw() {

  return "SMULBW";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SMULBW::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->op0) {
    case 0: {
      oss << "SMLA";
    break;}
    case 1: {
      oss << "SMULW";
    break;}
    case 2: {
      oss << "SMLAL";
    break;}
    case 3: {
      oss << "SMUL";
    break;}
  }
  switch(this->n) {
    case 0: {
      oss << "B";
    break;}
    case 1: {
      oss << "T";
    break;}
  }
  switch(this->m) {
    case 0: {
      oss << "B";
    break;}
    case 1: {
      oss << "T";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", R";
  oss << std::dec << this->ra_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::SMULBW::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf0000) >> 16;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf00) >> 8;
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf);
  this->rn.set_alias(REGS[this->rn_bit]);
  this->ra_bit = (bitstring & 0xf000) >> 12;
  this->ra.set_alias(REGS[this->ra_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->op0 = (bitstring & 0x600000) >> 21;
  this->m = (bitstring & 0x40) >> 6;
  this->n = (bitstring & 0x20) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::SMULBW::replicate(Instruction* instr)
const throw() {

  SMULBW* new_instr = new SMULBW(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    SMULBW* old_instr = dynamic_cast<SMULBW*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->ra_bit = old_instr->ra_bit;
      new_instr->ra.set_alias(REGS[new_instr->ra_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->op0 = old_instr->op0;
      new_instr->m = old_instr->m;
      new_instr->n = old_instr->n;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SMULBW::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15) || (rn_bit == 15))
  THROW_EXCEPTION("Invalid SMULxx/SMLAxx/SMLALxx/SMULWx/SMLAWx encoding: rd|rm|rn = 0xF.");

  if ((op0 != 3) && !((op0 == 1) && n) && (ra_bit == 15))
  THROW_EXCEPTION("Invalid SMLAxx/SMLALxx/SMLAWx encoding: ra = 0xF.");

  if ((op0 == 2) && (rd_bit == ra_bit))
  THROW_EXCEPTION("Invalid SMLALxx encoding: rd = ra.");

  if ((op0 == 3) && ra_bit)
  THROW_WARNING("Invalid SMULxx encoding: ra != 0x0.");

  if ((op0 == 1) && n && ra_bit)
  THROW_WARNING("Invalid SMULWx encoding: ra != 0x0.");

  unsigned latency = 1;
  unsigned long long result;

  // 16x16=>32-bit vs. 16x16=>64-bit vs. 16x32=>32-bit
  if ((op0 == 3) || !op0) {
    // SMULxx/SMLAxx
    result = (long long)((long long)((rn >> (16 * n)) & 0xFFFF)
    * (long long)((rm >> (16 * m)) & 0xFFFF)
    // SMLAxx; SMULxx: ra = 0
    + (long long)ra);

    rd = (int)(result & 0x00000000FFFFFFFFLL);

    // Update Q (cumulative saturation flag) if result saturates.
    // SMLAxx; SMULxx: result = rd
    CPSR[CPSR_Q] = (result != rd);
  } else if (op0 == 2) {
    // SMLALxx
    result = (long long)((long long)((rn >> (16 * n)) & 0xFFFF)
    * (long long)((rm >> (16 * m)) & 0xFFFF));
    result += (long long)((((long long)rd << 32) & 0xFFFFFFFF00000000LL)
    + ((long long)ra & 0x00000000FFFFFFFFLL));

    rd = (int)(((unsigned long)result >> 32) & 0x00000000FFFFFFFFLL);
    ra = (int)(result & 0x00000000FFFFFFFFLL);
  } else if (op0 == 1) {
    // SMULWx/SMLAWx
    result = (long long)((long long)rn
    * (long long)((rm >> (16 * m)) & 0xFFFF)
    // SMLAWx; SMULWx: ra = 0
    + ((long long)ra << 16));

    rd = (int)(((unsigned long)result >> 16) & 0x00000000FFFFFFFFLL);

    if (!n) {
      // SMLAWx
      // Update Q (cumulative saturation flag) if result saturates.
      CPSR[CPSR_Q] = ((result >> 16) != rd);
    }
  }

  // TODO: Compare stall cycles against Cortex A9 spec (rm: bits8-11).
  if (!(rm & 0xFFFFFF00) || (rm & 0xFFFFFF00) == 0xFFFFFF00) {
    stall(1+latency);
  } else if (!(rm & 0xFFFF0000) || (rm & 0xFFFF0000) == 0xFFFF0000) {
    stall(2+latency);
  } else if (!(rm & 0xFF000000) || (rm & 0xFF000000) == 0xFF000000) {
    stall(3+latency);
  } else {
    stall(4+latency);
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::SMMULD::SMMULD(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // SMMULD()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SMMULD::get_id() const throw() {

  return 32;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SMMULD::get_name() const throw() {

  return "SMMULD";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SMMULD::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->ra_bit) {
    default: {
      oss << "SML";
    break;}
    case 15: {
      oss << "SMU";
    break;}
  }
  switch(this->op1a) {
    case 0: {
      oss << "A";
    break;}
    case 1: {
      oss << "S";
    break;}
  }
  switch(this->l) {
    case 1: {
      oss << "L";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", R";
  oss << std::dec << this->ra_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::SMMULD::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf0000) >> 16;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf00) >> 8;
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf);
  this->rn.set_alias(REGS[this->rn_bit]);
  this->ra_bit = (bitstring & 0xf000) >> 12;
  this->ra.set_alias(REGS[this->ra_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->l = (bitstring & 0x400000) >> 22;
  this->op1a = (bitstring & 0xc0) >> 6;
  this->op1b = (bitstring & 0x20) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::SMMULD::replicate(Instruction* instr)
const throw() {

  SMMULD* new_instr = new SMMULD(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    SMMULD* old_instr = dynamic_cast<SMMULD*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->ra_bit = old_instr->ra_bit;
      new_instr->ra.set_alias(REGS[new_instr->ra_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->l = old_instr->l;
      new_instr->op1a = old_instr->op1a;
      new_instr->op1b = old_instr->op1b;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SMMULD::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15) || (rn_bit == 15))
  THROW_EXCEPTION("Invalid SMUAD/SMUSD/SMLAD/SMLSD/SMLALD/SMLSLD encoding: rd|rm|rn = 0xF.");

  if (l && (ra_bit == 15))
  THROW_EXCEPTION("Invalid SMLALD/SMLSLD encoding: ra = 0xF.");

  if (l && (rd_bit == ra_bit))
  THROW_EXCEPTION("Invalid SMLALD/SMLSLD encoding: rd = ra.");

  unsigned latency = 1;

  long long result = sign_extend(rn & 0xFFFF, 16)
  * (op1b? sign_extend((rm >> 16) & 0xFFFF, 16) : sign_extend(rm & 0xFFFF, 16));

  // Add vs. subtract
  if (op1a) {
    // SMxSxD
    result -= sign_extend((rn >> 16) & 0xFFFF, 16)
    * (op1b? sign_extend(rm & 0xFFFF, 16) : sign_extend((rm >> 16) & 0xFFFF,
    16));
  } else {
    // SMxAxD
    result += sign_extend((rn >> 16) & 0xFFFF, 16)
    * (op1b? sign_extend(rm & 0xFFFF, 16) : sign_extend((rm >> 16) & 0xFFFF,
    16));
  }

  // Accumulate vs. non-accumulate
  if (ra_bit != 15) {
    // 32-bit vs. 64-bit
    if (l) {
      // SMLxLD
      result += ((rd & 0x00000000FFFFFFFFLL) << 32) | (ra & 0x00000000FFFFFFFFLL);
      rd = (unsigned)((result >> 32) & 0x00000000FFFFFFFFLL);
      ra = (unsigned)(result & 0x00000000FFFFFFFFLL);
    } else {
      // SMLxD
      result += sign_extend(ra, 32);
      rd = (unsigned)(result & 0x00000000FFFFFFFFLL);
    }
  } else
  // SMUxD
  rd = (unsigned)(result & 0x00000000FFFFFFFFLL);

  if ((!l && ra_bit != 15) || (!op1a && ra_bit == 15)) {
    // Update Q (cumulative saturation flag) if result saturates
    CPSR[CPSR_Q] = (result != sign_extend(rd, 32));
  }

  // TODO: Compare stall cycles against Cortex A9 spec (rm: bits8-11).
  if (!(rm & 0xFFFFFF00) || (rm & 0xFFFFFF00) == 0xFFFFFF00) {
    stall(1+latency);
  } else if (!(rm & 0xFFFF0000) || (rm & 0xFFFF0000) == 0xFFFF0000) {
    stall(2+latency);
  } else if (!(rm & 0xFF000000) || (rm & 0xFF000000) == 0xFF000000) {
    stall(3+latency);
  } else {
    stall(4+latency);
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::DIV::DIV(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // DIV()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::DIV::get_id() const throw() {

  return 33;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::DIV::get_name() const throw() {

  return "DIV";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::DIV::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->s) {
    case 0: {
      oss << "UDIV";
    break;}
    case 1: {
      oss << "SDIV";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::DIV::set_params(const unsigned& bitstring) throw()
{

  this->rd_bit = (bitstring & 0xf0000) >> 16;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf00) >> 8;
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf);
  this->rn.set_alias(REGS[this->rn_bit]);
  this->ra_bit = (bitstring & 0xf000) >> 12;
  this->ra.set_alias(REGS[this->ra_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x200000) >> 21;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::DIV::replicate(Instruction* instr) const
throw() {

  DIV* new_instr = new DIV(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    DIV* old_instr = dynamic_cast<DIV*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->ra_bit = old_instr->ra_bit;
      new_instr->ra.set_alias(REGS[new_instr->ra_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::DIV::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15) || (rn_bit == 15))
  THROW_EXCEPTION("Invalid UDIV/SDIV encoding: rd|rm|rn = 0xF.");

  if (ra_bit != 15)
  THROW_WARNING("Invalid UDIV/SDIV encoding: ra != 0xF.");

  int result;
  unsigned latency = 0;

  if (rm) {
    // Unsigned vs. signed
    if (s) {
      // SDIV
      if((rn == 0x80000000) && (rm == 0xFFFFFFFF)){
        rd = 0x80000000;
      }else{
        result = (int)((int)rn / (int)rm);
        // Casting to int automatically truncates towards zero (not negative
        // infinity).
        rd = (int)result & 0xFFFFFFFF;
      }
    } else {
      // UDIV
      result = (unsigned)((unsigned)rn / (unsigned)rm);
      rd = (unsigned)result & 0xFFFFFFFF;
    }
  } else {
    // Divide by zero.
    result = 0;
  }

  // TODO: Compare stall cycles against Cortex A9 spec (rm: bits8-11).
  if (!(rm & 0xFFFFFF00) || (rm & 0xFFFFFF00) == 0xFFFFFF00) {
    stall(1+latency);
  } else if (!(rm & 0xFFFF0000) || (rm & 0xFFFF0000) == 0xFFFF0000) {
    stall(2+latency);
  } else if (!(rm & 0xFF000000) || (rm & 0xFF000000) == 0xFF000000) {
    stall(3+latency);
  } else {
    stall(4+latency);
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::AND_i::AND_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ARMExpandImmOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // AND_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::AND_i::get_id() const throw() {

  return 34;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::AND_i::get_name() const throw() {

  return "AND_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::AND_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "AND";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::AND_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::AND_i::replicate(Instruction* instr) const
throw() {

  AND_i* new_instr = new AND_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    AND_i* old_instr = dynamic_cast<AND_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->rotate = old_instr->rotate;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::AND_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  result = rn & operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::AND_r::AND_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // AND_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::AND_r::get_id() const throw() {

  return 35;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::AND_r::get_name() const throw() {

  return "AND_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::AND_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "AND";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::AND_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::AND_r::replicate(Instruction* instr) const
throw() {

  AND_r* new_instr = new AND_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    AND_r* old_instr = dynamic_cast<AND_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::AND_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  result = rn & operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::AND_sr::AND_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // AND_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::AND_sr::get_id() const throw() {

  return 36;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::AND_sr::get_name() const throw() {

  return "AND_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::AND_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "AND";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::AND_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::AND_sr::replicate(Instruction* instr)
const throw() {

  AND_sr* new_instr = new AND_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    AND_sr* old_instr = dynamic_cast<AND_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::AND_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid AND (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  result = rn & operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::EOR_i::EOR_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ARMExpandImmOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // EOR_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::EOR_i::get_id() const throw() {

  return 37;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::EOR_i::get_name() const throw() {

  return "EOR_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::EOR_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "EOR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::EOR_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::EOR_i::replicate(Instruction* instr) const
throw() {

  EOR_i* new_instr = new EOR_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    EOR_i* old_instr = dynamic_cast<EOR_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->rotate = old_instr->rotate;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::EOR_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  result = rn ^ operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::EOR_r::EOR_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // EOR_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::EOR_r::get_id() const throw() {

  return 38;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::EOR_r::get_name() const throw() {

  return "EOR_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::EOR_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "EOR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::EOR_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::EOR_r::replicate(Instruction* instr) const
throw() {

  EOR_r* new_instr = new EOR_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    EOR_r* old_instr = dynamic_cast<EOR_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::EOR_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  result = rn ^ operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::EOR_sr::EOR_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // EOR_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::EOR_sr::get_id() const throw() {

  return 39;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::EOR_sr::get_name() const throw() {

  return "EOR_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::EOR_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "EOR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::EOR_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::EOR_sr::replicate(Instruction* instr)
const throw() {

  EOR_sr* new_instr = new EOR_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    EOR_sr* old_instr = dynamic_cast<EOR_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::EOR_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid EOR (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  result = rn ^ operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::MVN_i::MVN_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ARMExpandImmOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // MVN_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::MVN_i::get_id() const throw() {

  return 40;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::MVN_i::get_name() const throw() {

  return "MVN_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::MVN_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "MVN";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::MVN_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::MVN_i::replicate(Instruction* instr) const
throw() {

  MVN_i* new_instr = new MVN_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    MVN_i* old_instr = dynamic_cast<MVN_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->rotate = old_instr->rotate;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::MVN_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if (rn_bit && !(s && rd_bit == 15))
  THROW_WARNING("Invalid MVN (immediate) encoding: rn != 0x0.");

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  result = ~operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::MVN_r::MVN_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // MVN_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::MVN_r::get_id() const throw() {

  return 41;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::MVN_r::get_name() const throw() {

  return "MVN_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::MVN_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "MVN";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::MVN_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::MVN_r::replicate(Instruction* instr) const
throw() {

  MVN_r* new_instr = new MVN_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    MVN_r* old_instr = dynamic_cast<MVN_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::MVN_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if (rn_bit && !(s && rd_bit == 15))
  THROW_WARNING("Invalid MVN (register) encoding: rn != 0x0.");

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  result = ~operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::MVN_sr::MVN_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // MVN_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::MVN_sr::get_id() const throw() {

  return 42;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::MVN_sr::get_name() const throw() {

  return "MVN_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::MVN_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "MVN";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::MVN_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::MVN_sr::replicate(Instruction* instr)
const throw() {

  MVN_sr* new_instr = new MVN_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    MVN_sr* old_instr = dynamic_cast<MVN_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::MVN_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid MVN (shifted-register) encoding: rd|rs|rm = 0xF.");

  if (rn_bit)
  THROW_WARNING("Invalid MVN (shifted-register) encoding: rn != 0x0.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  result = ~operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::ORR_i::ORR_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ARMExpandImmOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // ORR_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ORR_i::get_id() const throw() {

  return 43;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ORR_i::get_name() const throw() {

  return "ORR_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ORR_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "ORR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::ORR_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::ORR_i::replicate(Instruction* instr) const
throw() {

  ORR_i* new_instr = new ORR_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    ORR_i* old_instr = dynamic_cast<ORR_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->rotate = old_instr->rotate;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ORR_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  result = rn | operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::ORR_r::ORR_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // ORR_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ORR_r::get_id() const throw() {

  return 44;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ORR_r::get_name() const throw() {

  return "ORR_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ORR_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "ORR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::ORR_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::ORR_r::replicate(Instruction* instr) const
throw() {

  ORR_r* new_instr = new ORR_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    ORR_r* old_instr = dynamic_cast<ORR_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ORR_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  result = rn | operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::ORR_sr::ORR_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // ORR_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ORR_sr::get_id() const throw() {

  return 45;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ORR_sr::get_name() const throw() {

  return "ORR_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ORR_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "ORR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::ORR_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::ORR_sr::replicate(Instruction* instr)
const throw() {

  ORR_sr* new_instr = new ORR_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    ORR_sr* old_instr = dynamic_cast<ORR_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ORR_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid ORR (shifted-register) encoding: rn|rd|rs|rm = 0xF.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  result = rn | operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::TEQ_i::TEQ_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ARMExpandImmOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // TEQ_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::TEQ_i::get_id() const throw() {

  return 46;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::TEQ_i::get_name() const throw() {

  return "TEQ_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::TEQ_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "TEQ";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::TEQ_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::TEQ_i::replicate(Instruction* instr) const
throw() {

  TEQ_i* new_instr = new TEQ_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    TEQ_i* old_instr = dynamic_cast<TEQ_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->rotate = old_instr->rotate;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::TEQ_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if (rd_bit)
  THROW_WARNING("Invalid TEQ (immediate) encoding: rd != 0x0.");
  this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  unsigned result = rn ^ operand;
  update_psr_bit(result, carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::TEQ_r::TEQ_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // TEQ_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::TEQ_r::get_id() const throw() {

  return 47;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::TEQ_r::get_name() const throw() {

  return "TEQ_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::TEQ_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "TEQ";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::TEQ_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::TEQ_r::replicate(Instruction* instr) const
throw() {

  TEQ_r* new_instr = new TEQ_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    TEQ_r* old_instr = dynamic_cast<TEQ_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::TEQ_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if (rd_bit)
  THROW_WARNING("Invalid TEQ (register) encoding: rd != 0x0.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  unsigned result = rn ^ operand;
  update_psr_bit(result, carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::TEQ_sr::TEQ_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // TEQ_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::TEQ_sr::get_id() const throw() {

  return 48;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::TEQ_sr::get_name() const throw() {

  return "TEQ_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::TEQ_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "TEQ";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::TEQ_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::TEQ_sr::replicate(Instruction* instr)
const throw() {

  TEQ_sr* new_instr = new TEQ_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    TEQ_sr* old_instr = dynamic_cast<TEQ_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::TEQ_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid TEQ (shifted-register) encoding: rn|rs|rm = 0xF.");

  if (rd_bit)
  THROW_WARNING("Invalid TEQ (shifted-register) encoding: rd != 0x0.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  unsigned result = rn ^ operand;
  update_psr_bit(result, carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::TST_i::TST_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ARMExpandImmOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // TST_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::TST_i::get_id() const throw() {

  return 49;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::TST_i::get_name() const throw() {

  return "TST_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::TST_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "TST";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::TST_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::TST_i::replicate(Instruction* instr) const
throw() {

  TST_i* new_instr = new TST_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    TST_i* old_instr = dynamic_cast<TST_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->rotate = old_instr->rotate;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::TST_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if (rd_bit)
  THROW_WARNING("Invalid TST (immediate) encoding: rd != 0x0.");
  this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  unsigned result = rn & operand;
  update_psr_bit(result, carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::TST_r::TST_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // TST_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::TST_r::get_id() const throw() {

  return 50;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::TST_r::get_name() const throw() {

  return "TST_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::TST_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "TST";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::TST_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::TST_r::replicate(Instruction* instr) const
throw() {

  TST_r* new_instr = new TST_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    TST_r* old_instr = dynamic_cast<TST_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::TST_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if (rd_bit)
  THROW_WARNING("Invalid TST (register) encoding: rd != 0x0.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  unsigned result = rn & operand;
  update_psr_bit(result, carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::TST_sr::TST_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // TST_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::TST_sr::get_id() const throw() {

  return 51;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::TST_sr::get_name() const throw() {

  return "TST_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::TST_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "TST";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::TST_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::TST_sr::replicate(Instruction* instr)
const throw() {

  TST_sr* new_instr = new TST_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    TST_sr* old_instr = dynamic_cast<TST_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::TST_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid TST (shifted-register) encoding: rn|rs|rm = 0xF.");

  if (rd_bit)
  THROW_WARNING("Invalid TST (shifted-register) encoding: rd != 0x0.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  unsigned result = rn & operand;
  update_psr_bit(result, carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::ASR_r::ASR_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // ASR_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ASR_r::get_id() const throw() {

  return 52;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ASR_r::get_name() const throw() {

  return "ASR_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ASR_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "ASR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::ASR_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::ASR_r::replicate(Instruction* instr) const
throw() {

  ASR_r* new_instr = new ASR_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    ASR_r* old_instr = dynamic_cast<ASR_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ASR_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if (rn_bit && !(s && rd_bit == 15))
  THROW_WARNING("Invalid ASR (register) encoding: rn != 0x0.");

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  result = operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::ASR_sr::ASR_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // ASR_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ASR_sr::get_id() const throw() {

  return 53;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ASR_sr::get_name() const throw() {

  return "ASR_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ASR_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "ASR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::ASR_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::ASR_sr::replicate(Instruction* instr)
const throw() {

  ASR_sr* new_instr = new ASR_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    ASR_sr* old_instr = dynamic_cast<ASR_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ASR_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid ASR (shifted-register) encoding: rn|rd|rm = 0xF.");

  if (rn_bit)
  THROW_WARNING("Invalid ASR (shifted-register) encoding: rn != 0x0.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  result = operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LSR_r::LSR_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // LSR_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LSR_r::get_id() const throw() {

  return 54;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LSR_r::get_name() const throw() {

  return "LSR_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LSR_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LSR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LSR_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LSR_r::replicate(Instruction* instr) const
throw() {

  LSR_r* new_instr = new LSR_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LSR_r* old_instr = dynamic_cast<LSR_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LSR_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if (rn_bit && !(s && rd_bit == 15))
  THROW_WARNING("Invalid LSR (register) encoding: rn != 0x0.");

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  result = operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LSR_sr::LSR_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // LSR_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LSR_sr::get_id() const throw() {

  return 55;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LSR_sr::get_name() const throw() {

  return "LSR_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LSR_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LSR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LSR_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LSR_sr::replicate(Instruction* instr)
const throw() {

  LSR_sr* new_instr = new LSR_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LSR_sr* old_instr = dynamic_cast<LSR_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LSR_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid LSR (shifted-register) encoding: rn|rd|rm = 0xF.");

  if (rn_bit)
  THROW_WARNING("Invalid LSR (shifted-register) encoding: rn != 0x0.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  result = operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LSL_r::LSL_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // LSL_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LSL_r::get_id() const throw() {

  return 56;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LSL_r::get_name() const throw() {

  return "LSL_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LSL_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LSL";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LSL_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LSL_r::replicate(Instruction* instr) const
throw() {

  LSL_r* new_instr = new LSL_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LSL_r* old_instr = dynamic_cast<LSL_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LSL_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if (rn_bit && !(s && rd_bit == 15))
  THROW_WARNING("Invalid LSL (register) encoding: rn != 0x0.");

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  result = operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LSL_sr::LSL_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // LSL_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LSL_sr::get_id() const throw() {

  return 57;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LSL_sr::get_name() const throw() {

  return "LSL_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LSL_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LSL";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LSL_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LSL_sr::replicate(Instruction* instr)
const throw() {

  LSL_sr* new_instr = new LSL_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LSL_sr* old_instr = dynamic_cast<LSL_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LSL_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid LSL (shifted-register) encoding: rn|rd|rm = 0xF.");

  if (rn_bit)
  THROW_WARNING("Invalid LSL (shifted-register) encoding: rn != 0x0.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  result = operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::ROR_r::ROR_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // ROR_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ROR_r::get_id() const throw() {

  return 58;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ROR_r::get_name() const throw() {

  return "ROR_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ROR_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->shift_amm) {
    case 0: {
      oss << "RRX";
    break;}
    default: {
      oss << "ROR";
    break;}
  }
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::ROR_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::ROR_r::replicate(Instruction* instr) const
throw() {

  ROR_r* new_instr = new ROR_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    ROR_r* old_instr = dynamic_cast<ROR_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ROR_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if (rn_bit && !(s && rd_bit == 15))
  THROW_WARNING("Invalid ROR/RRX (register) encoding: rn != 0x0.");

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  result = operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::ROR_sr::ROR_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // ROR_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ROR_sr::get_id() const throw() {

  return 59;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ROR_sr::get_name() const throw() {

  return "ROR_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::ROR_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "ROR";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::ROR_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::ROR_sr::replicate(Instruction* instr)
const throw() {

  ROR_sr* new_instr = new ROR_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    ROR_sr* old_instr = dynamic_cast<ROR_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::ROR_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid ROR (shifted-register) encoding: rn|rd|rm = 0xF.");

  if (rn_bit)
  THROW_WARNING("Invalid ROR (shifted-register) encoding: rn != 0x0.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  result = operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::BFCI::BFCI(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // BFCI()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::BFCI::get_id() const throw() {

  return 60;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::BFCI::get_name() const throw() {

  return "BFCI";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::BFCI::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "BF";
  switch(this->rm_bit) {
    default: {
      oss << "I";
    break;}
    case 15: {
      oss << "C";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->imm1;
  oss << ", ";
  oss << std::showbase << std::hex << this->imm0;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::BFCI::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->imm0 = (bitstring & 0x1f0000) >> 16;
  this->imm1 = (bitstring & 0xf80) >> 7;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::BFCI::replicate(Instruction* instr) const
throw() {

  BFCI* new_instr = new BFCI(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    BFCI* old_instr = dynamic_cast<BFCI*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->imm0 = old_instr->imm0;
      new_instr->imm1 = old_instr->imm1;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::BFCI::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if (rd_bit == 15)
  THROW_EXCEPTION("Invalid BFC/BFI encoding: rd = 0xF.");

  if ((imm0 <= 31) && (imm0 >= imm1)) {
    unsigned long mask;
    unsigned result;
    mask = ((((unsigned long)0xFFFFFFFF << (32-imm0-1)) & 0xFFFFFFFF) >> (32-imm0+imm1-1)
    << imm1);
    result = rd;
    // BFC
    if (rm == 0xF) {
      // Clear bitfield.
      result &= ~mask;
      // BFI
    } else {
      // Set bitfield.
      result = (result & ~mask) | (rm & mask);
    }
    rd = result;
  }
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::BIC_i::BIC_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ARMExpandImmOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // BIC_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::BIC_i::get_id() const throw() {

  return 61;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::BIC_i::get_name() const throw() {

  return "BIC_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::BIC_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "BIC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::BIC_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::BIC_i::replicate(Instruction* instr) const
throw() {

  BIC_i* new_instr = new BIC_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    BIC_i* old_instr = dynamic_cast<BIC_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->rotate = old_instr->rotate;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::BIC_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  result = rn & ~operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::BIC_r::BIC_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // BIC_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::BIC_r::get_id() const throw() {

  return 62;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::BIC_r::get_name() const throw() {

  return "BIC_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::BIC_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "BIC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::BIC_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::BIC_r::replicate(Instruction* instr) const
throw() {

  BIC_r* new_instr = new BIC_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    BIC_r* old_instr = dynamic_cast<BIC_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::BIC_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  unsigned cur_mode = CPSR[CPSR_M];
  if (s && rd_bit == 15 &&
  ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
  || (cur_mode == (unsigned)EXECMODE::HYP)))
  THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  result = rn & ~operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::BIC_sr::BIC_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  UpdatePSRBitOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // BIC_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::BIC_sr::get_id() const throw() {

  return 63;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::BIC_sr::get_name() const throw() {

  return "BIC_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::BIC_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "BIC";
  switch(this->s) {
    case 1: {
      oss << "S";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::BIC_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->s = (bitstring & 0x100000) >> 20;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::BIC_sr::replicate(Instruction* instr)
const throw() {

  BIC_sr* new_instr = new BIC_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    BIC_sr* old_instr = dynamic_cast<BIC_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->s = old_instr->s;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::BIC_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid BIC encoding: rn|rd|rs|rm = 0xF.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  result = rn & ~operand;
  this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
  this->result, this->carry);
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::CLZ::CLZ(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // CLZ()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::CLZ::get_id() const throw() {

  return 64;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::CLZ::get_name() const throw() {

  return "CLZ";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::CLZ::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "CLZ";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::CLZ::set_params(const unsigned& bitstring) throw()
{

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::CLZ::replicate(Instruction* instr) const
throw() {

  CLZ* new_instr = new CLZ(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    CLZ* old_instr = dynamic_cast<CLZ*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::CLZ::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid CLZ encoding: rd|rm = 0xF.");

  if ((rn_bit != 15) || (rs_bit != 15))
  THROW_WARNING("Invalid CLZ encoding: rn|rs != 0xF.");

  // NOTE: Binary search algorithm for counting leading zeros taken from Henry
  // S. Warren, "Hacker's Delight, " 2003.
  unsigned input = rm,
  result = 32;
  if (input) {
    result = 0;
    if (!(input & 0xFFFF0000)) {
      result += 16;
      input <<= 16;
    }
    if (!(input & 0xFF000000)) {
      result += 8;
      input <<= 8;
    }
    if (!(input & 0xF0000000)) {
      result += 4;
      input <<= 4;
    }
    if (!(input & 0xC0000000)) {
      result += 2;
      input <<= 2;
    }
    if (!(input & 0x80000000)) {
      result += 1;
      input <<= 1;
    }
  }
  rd = result;
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::PKH::PKH(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // PKH()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::PKH::get_id() const throw() {

  return 65;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::PKH::get_name() const throw() {

  return "PKH";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::PKH::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "PKH";
  switch(this->tb) {
    case 0: {
      oss << "BT";
    break;}
    case 1: {
      oss << "TB";
    break;}
  }
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->tb) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "ASR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->imm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::PKH::set_params(const unsigned& bitstring) throw()
{

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->imm = (bitstring & 0xf80) >> 7;
  this->tb = (bitstring & 0x40) >> 6;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::PKH::replicate(Instruction* instr) const
throw() {

  PKH* new_instr = new PKH(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    PKH* old_instr = dynamic_cast<PKH*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->imm = old_instr->imm;
      new_instr->tb = old_instr->tb;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::PKH::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid PKH encoding: rn|rd|rm = 0xF.");

  // Needed by DecodeImmShift().
  shift_op = tb << 1;
  shift_amm = imm;
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  // ASR
  if (shift_op) {
    rd = (rn & 0xFFFF0000) | (operand & 0x0000FFFF);
    // LSL
  } else {
    rd = (operand & 0xFFFF0000) | (rn & 0x0000FFFF);
  }
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::RBIT::RBIT(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // RBIT()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::RBIT::get_id() const throw() {

  return 66;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::RBIT::get_name() const throw() {

  return "RBIT";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::RBIT::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "RBIT";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::RBIT::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::RBIT::replicate(Instruction* instr) const
throw() {

  RBIT* new_instr = new RBIT(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    RBIT* old_instr = dynamic_cast<RBIT*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::RBIT::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid RBIT encoding: rd|rm = 0xF.");

  if ((rn_bit != 15) || (rs_bit != 15))
  THROW_WARNING("Invalid RBIT encoding: rn|rs != 0xF.");

  unsigned result = rm;
  result = (result << 16) | (result >> 16);
  result = ((result & 0x00FF00FF) << 8) | ((result & 0xFF00FF00) >> 8);
  result = ((result & 0x0F0F0F0F) << 4) | ((result & 0xF0F0F0F0) >> 4);
  result = ((result & 0x33333333) << 2) | ((result & 0xCCCCCCCC) >> 2);
  result = ((result & 0x55555555) << 1) | ((result & 0xAAAAAAAA) >> 1);
  rd = result & 0xFFFFFFFF;
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::REV::REV(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // REV()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::REV::get_id() const throw() {

  return 67;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::REV::get_name() const throw() {

  return "REV";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::REV::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "REV";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::REV::set_params(const unsigned& bitstring) throw()
{

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::REV::replicate(Instruction* instr) const
throw() {

  REV* new_instr = new REV(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    REV* old_instr = dynamic_cast<REV*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::REV::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid REV encoding: rd|rm = 0xF.");

  if ((rn_bit != 15) || (rs_bit != 15))
  THROW_WARNING("Invalid REV encoding: rn|rs != 0xF.");

  unsigned result = rm;
  result = (result << 16) | (result >> 16);
  result = ((result & 0x00FF00FF) << 8) | ((result & 0xFF00FF00) >> 8);
  rd = result & 0xFFFFFFFF;
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::REV16::REV16(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // REV16()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::REV16::get_id() const throw() {

  return 68;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::REV16::get_name() const throw() {

  return "REV16";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::REV16::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "REV16";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::REV16::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::REV16::replicate(Instruction* instr) const
throw() {

  REV16* new_instr = new REV16(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    REV16* old_instr = dynamic_cast<REV16*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::REV16::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid REV16 encoding: rd|rm = 0xF.");

  if ((rn_bit != 15) || (rs_bit != 15))
  THROW_WARNING("Invalid REV16 encoding: rn|rs != 0xF.");

  unsigned result = rm;
  result = ((result & 0x00FF00FF) << 8) | ((result & 0xFF00FF00) >> 8);
  rd = result & 0xFFFFFFFF;
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::REVSH::REVSH(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // REVSH()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::REVSH::get_id() const throw() {

  return 69;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::REVSH::get_name() const throw() {

  return "REVSH";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::REVSH::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "REVSH";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::REVSH::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::REVSH::replicate(Instruction* instr) const
throw() {

  REVSH* new_instr = new REVSH(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    REVSH* old_instr = dynamic_cast<REVSH*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::REVSH::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid REVSH encoding: rd|rm = 0xF.");

  if ((rn_bit != 15) || (rs_bit != 15))
  THROW_WARNING("Invalid REVSH encoding: rn|rs != 0xF.");

  unsigned result = rm;
  result = ((result & 0x000000FF) << 8) | ((result & 0x0000FF00) >> 8);
  if (result & 0x00008000) {
    result |= 0xFFFF0000;
  }
  rd = result;
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::USBFX::USBFX(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // USBFX()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USBFX::get_id() const throw() {

  return 70;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USBFX::get_name() const throw() {

  return "USBFX";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::USBFX::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  switch(this->u) {
    case 0: {
      oss << "S";
    break;}
    case 1: {
      oss << "U";
    break;}
  }
  oss << "BFX";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->imm1;
  oss << ", ";
  oss << std::showbase << std::hex << this->imm0;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::USBFX::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->u = (bitstring & 0x400000) >> 22;
  this->imm0 = (bitstring & 0x1f0000) >> 16;
  this->imm1 = (bitstring & 0xf80) >> 7;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::USBFX::replicate(Instruction* instr) const
throw() {

  USBFX* new_instr = new USBFX(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    USBFX* old_instr = dynamic_cast<USBFX*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->u = old_instr->u;
      new_instr->imm0 = old_instr->imm0;
      new_instr->imm1 = old_instr->imm1;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::USBFX::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid UBFX/SBFX encoding: rd|rm = 0xF.");

  unsigned msb = imm0 + imm1;
  if (msb <= 31) {
    unsigned long mask;
    mask = ((((unsigned long)0xFFFFFFFF << (32-msb-1)) & 0xFFFFFFFF) >> (32-imm0-1)
    << imm1);
    unsigned result = (unsigned)(rm & mask) >> imm1;
    // Unsigned vs. signed
    if (u) rd = result & 0xFFFFFFFF;
    else rd = sign_extend(result, imm0+1) & 0xFFFFFFFF;
  }
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::SEL::SEL(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // SEL()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SEL::get_id() const throw() {

  return 71;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SEL::get_name() const throw() {

  return "SEL";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::SEL::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "SEL";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::SEL::set_params(const unsigned& bitstring) throw()
{

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::SEL::replicate(Instruction* instr) const
throw() {

  SEL* new_instr = new SEL(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    SEL* old_instr = dynamic_cast<SEL*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::SEL::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid SEL encoding: rn|rd|rm = 0xF.");

  if (rs_bit != 15)
  THROW_WARNING("Invalid SEL encoding: rs != 0xF.");

  unsigned result = 0;
  for (unsigned i = 0; i < 4; ++i) {
    if (CPSR[CPSR_GE] & (0x1 << i)) {
      result |= rn & (0x000000FF << (i << 3));
    } else {
      result |= rm & (0x000000FF << (i << 3));
    }
  }
  rd = result;
  {
    unsigned num_cycles = 0;


    /// In case the program counter is the updated register the latency of the
    /// operation is incremented by two clock cycles.
    if (rd_bit == 15) {
      num_cycles += 2;
      flush();
    }
    this->num_instr_cycles += num_cycles;
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::CMN_i::CMN_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ARMExpandImmOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // CMN_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::CMN_i::get_id() const throw() {

  return 72;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::CMN_i::get_name() const throw() {

  return "CMN_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::CMN_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "CMN";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::CMN_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::CMN_i::replicate(Instruction* instr) const
throw() {

  CMN_i* new_instr = new CMN_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    CMN_i* old_instr = dynamic_cast<CMN_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->rotate = old_instr->rotate;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::CMN_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if (rd_bit)
  THROW_WARNING("Invalid CMN encoding: rd != 0x0.");
  this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  AddWithCarry(rn, operand, 0);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::CMN_r::CMN_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // CMN_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::CMN_r::get_id() const throw() {

  return 73;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::CMN_r::get_name() const throw() {

  return "CMN_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::CMN_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "CMN";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::CMN_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::CMN_r::replicate(Instruction* instr) const
throw() {

  CMN_r* new_instr = new CMN_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    CMN_r* old_instr = dynamic_cast<CMN_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::CMN_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if (rd_bit)
  THROW_WARNING("Invalid CMN encoding: rd != 0x0.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  AddWithCarry(rn, operand, 0);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::CMN_sr::CMN_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // CMN_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::CMN_sr::get_id() const throw() {

  return 74;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::CMN_sr::get_name() const throw() {

  return "CMN_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::CMN_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "CMN";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::CMN_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::CMN_sr::replicate(Instruction* instr)
const throw() {

  CMN_sr* new_instr = new CMN_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    CMN_sr* old_instr = dynamic_cast<CMN_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::CMN_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid CMN encoding: rn|rs|rm = 0xF.");

  if (rd_bit)
  THROW_WARNING("Invalid CMN encoding: rd != 0x0.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  AddWithCarry(rn, operand, 0);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::CMP_i::CMP_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ARMExpandImmOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // CMP_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::CMP_i::get_id() const throw() {

  return 75;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::CMP_i::get_name() const throw() {

  return "CMP_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::CMP_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "CMP";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  oss << ", ";
  oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate)) &
  (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32 - 2 *
  this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::CMP_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->rotate = (bitstring & 0xf00) >> 8;
  this->imm = (bitstring & 0xff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::CMP_i::replicate(Instruction* instr) const
throw() {

  CMP_i* new_instr = new CMP_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    CMP_i* old_instr = dynamic_cast<CMP_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->rotate = old_instr->rotate;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::CMP_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if (rd_bit)
  THROW_WARNING("Invalid CMP encoding: rd != 0x0.");
  this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm, this->operand,
  this->carry);

  AddWithCarry(rn, ~operand & 0xFFFFFFFF, 1);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::CMP_r::CMP_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // CMP_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::CMP_r::get_id() const throw() {

  return 76;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::CMP_r::get_name() const throw() {

  return "CMP_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::CMP_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "CMP";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " ";
  oss << std::showbase << std::hex << this->shift_amm;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::CMP_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::CMP_r::replicate(Instruction* instr) const
throw() {

  CMP_r* new_instr = new CMP_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    CMP_r* old_instr = dynamic_cast<CMP_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::CMP_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if (rd_bit)
  THROW_WARNING("Invalid CMP encoding: rd != 0x0.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);

  AddWithCarry(rn, ~operand & 0xFFFFFFFF, 1);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::CMP_sr::CMP_sr(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeRegShiftOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // CMP_sr()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::CMP_sr::get_id() const throw() {

  return 77;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::CMP_sr::get_name() const throw() {

  return "CMP_sr";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::CMP_sr::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "CMP";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rn_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", ";
  switch(this->shift_op) {
    case 0: {
      oss << "LSL";
    break;}
    case 1: {
      oss << "LSR";
    break;}
    case 2: {
      oss << "ASR";
    break;}
    case 3: {
      oss << "ROR";
    break;}
  }
  oss << " R";
  oss << std::dec << this->rs_bit;
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::CMP_sr::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::CMP_sr::replicate(Instruction* instr)
const throw() {

  CMP_sr* new_instr = new CMP_sr(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    CMP_sr* old_instr = dynamic_cast<CMP_sr*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::CMP_sr::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rs_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid CMP encoding: rn|rs|rm = 0xF.");

  if (rd_bit)
  THROW_WARNING("Invalid CMP encoding: rd != 0x0.");
  this->num_instr_cycles += DecodeRegShift(this->rm, this->rm_bit, this->rs,
  this->rs_bit, this->shift_op, this->operand, this->carry);

  AddWithCarry(rn, ~operand & 0xFFFFFFFF, 1);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LDR_i::LDR_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory),
  LSOffsetOp(R, instr_memory, data_memory) {


} // LDR_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDR_i::get_id() const throw() {

  return 78;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDR_i::get_name() const throw() {

  return "LDR_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDR_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LDR";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LDR_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xfff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LDR_i::replicate(Instruction* instr) const
throw() {

  LDR_i* new_instr = new LDR_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LDR_i* old_instr = dynamic_cast<LDR_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->p = old_instr->p;
      new_instr->u = old_instr->u;
      new_instr->w = old_instr->w;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDR_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  //if ((rn_bit != 15) && !p && u && !w && (rn_bit == 13) && (imm == 0x004))
  // POP is caught by the decoder as a subinstruction and never redirects here.

  if ((rn_bit != 15) && (!p || w) && (rn_bit == rd_bit))
  THROW_EXCEPTION("Invalid LDR/LDRT (immediate) encoding: rn = rd and writeback.");

  if ((rn_bit != 15) && (!p && w) && ((rn_bit == 15) || (rd_bit == 15)))
  THROW_EXCEPTION("Invalid LDRT (immediate) encoding: rn|rd = 0xF.");

  if ((rn_bit == 15) && (!p || w))
  THROW_WARNING("Invalid LDR (literal) encoding: p != 1 or w != 0.");

  operand = imm;
  this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15)
  address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);

  if (rd_bit == 15) {
    // Load word-aligned memory in PC.
    PC = data_memory.read_word(address) & 0xFFFFFFFC;
    stall(2);
    flush();
  } else {
    rd = data_memory.read_word(address);
    stall(2);
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LDR_r::LDR_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory),
  LSOffsetOp(R, instr_memory, data_memory) {


} // LDR_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDR_r::get_id() const throw() {

  return 79;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDR_r::get_name() const throw() {

  return "LDR_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDR_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LDR";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->shift_amm;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LDR_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LDR_r::replicate(Instruction* instr) const
throw() {

  LDR_r* new_instr = new LDR_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LDR_r* old_instr = dynamic_cast<LDR_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->p = old_instr->p;
      new_instr->u = old_instr->u;
      new_instr->w = old_instr->w;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDR_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid LDR/LDRT (register) encoding: (rn = 0xF or rn = rd) and writeback.");

  if ((!p && w) && (rd_bit == 15))
  THROW_EXCEPTION("Invalid LDRT (register) encoding: rd = 0xF.");

  if (rm_bit == 15)
  THROW_EXCEPTION("Invalid LDR/LDRT (register) encoding: rm = 0xF.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);
  this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15)
  address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);

  if (rd_bit == 15) {
    // Load word-aligned memory in PC.
    PC = data_memory.read_word(address) & 0xFFFFFFFC;
    stall(2);
    flush();
  } else {
    rd = data_memory.read_word(address);
    stall(2);
  }
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LDREX::LDREX(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // LDREX()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDREX::get_id() const throw() {

  return 80;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDREX::get_name() const throw() {

  return "LDREX";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDREX::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LDREX";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LDREX::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LDREX::replicate(Instruction* instr) const
throw() {

  LDREX* new_instr = new LDREX(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LDREX* old_instr = dynamic_cast<LDREX*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDREX::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15))
  THROW_EXCEPTION("Invalid LDREX encoding: rn|rd = 0xF.");

  if ((rs_bit != 15) || (rm_bit != 15))
  THROW_WARNING("Invalid LDREX encoding: rs|rm != 0xF.");

  rd = data_memory.read_word(rn);
  stall(2);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LDRB_i::LDRB_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory),
  LSOffsetOp(R, instr_memory, data_memory) {


} // LDRB_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRB_i::get_id() const throw() {

  return 81;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRB_i::get_name() const throw() {

  return "LDRB_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRB_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LDRB_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xfff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LDRB_i::replicate(Instruction* instr)
const throw() {

  LDRB_i* new_instr = new LDRB_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LDRB_i* old_instr = dynamic_cast<LDRB_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->p = old_instr->p;
      new_instr->u = old_instr->u;
      new_instr->w = old_instr->w;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRB_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit != 15) && (!p || w) && (rn_bit == rd_bit))
  THROW_EXCEPTION("Invalid LDRB/LDRBT (immediate) encoding: rn = rd and writeback.");

  if ((rn_bit != 15) && (!p && w) && (rn_bit == 15))
  THROW_EXCEPTION("Invalid LDRBT (immediate) encoding: rn = 0xF.");

  if (rd_bit == 15)
  THROW_EXCEPTION("Invalid LDRB/LDRBT (immediate/literal) encoding: rd = 0xF.");

  if ((rn_bit == 15) && (!p || w))
  THROW_WARNING("Invalid LDRB (literal) encoding: p != 1 or w != 0.");

  operand = imm;
  this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15)
  address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);

  rd = data_memory.read_byte(address);
  stall(2);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LDRB_r::LDRB_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory),
  LSOffsetOp(R, instr_memory, data_memory) {


} // LDRB_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRB_r::get_id() const throw() {

  return 82;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRB_r::get_name() const throw() {

  return "LDRB_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRB_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->shift_amm;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LDRB_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LDRB_r::replicate(Instruction* instr)
const throw() {

  LDRB_r* new_instr = new LDRB_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LDRB_r* old_instr = dynamic_cast<LDRB_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->p = old_instr->p;
      new_instr->u = old_instr->u;
      new_instr->w = old_instr->w;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRB_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid LDRB/LDRBT (register) encoding: (rn = 0xF or rn = rd) and writeback.");

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid LDRB/LDRBT (register) encoding: rd|rm = 0xF.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);
  this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15)
  address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);

  rd = data_memory.read_byte(address);
  stall(2);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LDREXB::LDREXB(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // LDREXB()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDREXB::get_id() const throw() {

  return 83;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDREXB::get_name() const throw() {

  return "LDREXB";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDREXB::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LDREXB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LDREXB::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LDREXB::replicate(Instruction* instr)
const throw() {

  LDREXB* new_instr = new LDREXB(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LDREXB* old_instr = dynamic_cast<LDREXB*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDREXB::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15))
  THROW_EXCEPTION("Invalid LDREXB encoding: rn|rd = 0xF.");

  if ((rs_bit != 15) || (rm_bit != 15))
  THROW_WARNING("Invalid LDREXB encoding: rs|rm != 0xF.");

  rd = data_memory.read_byte(rn);
  stall(2);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LDRSB_i::LDRSB_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory),
  LSOffsetOp(R, instr_memory, data_memory) {


} // LDRSB_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRSB_i::get_id() const throw() {

  return 84;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRSB_i::get_name() const throw() {

  return "LDRSB_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRSB_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRSB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LDRSB_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LDRSB_i::replicate(Instruction* instr)
const throw() {

  LDRSB_i* new_instr = new LDRSB_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LDRSB_i* old_instr = dynamic_cast<LDRSB_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->p = old_instr->p;
      new_instr->u = old_instr->u;
      new_instr->w = old_instr->w;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRSB_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit != 15) && (!p || w) && (rn_bit == rd_bit))
  THROW_EXCEPTION("Invalid LDRSB/LDRSBT (immediate) encoding: rn = rd and writeback.");

  if ((rn_bit != 15) && (!p && w) && (rn_bit == 15))
  THROW_EXCEPTION("Invalid LDRSBT (immediate) encoding: rn = 0xF.");

  if (rd_bit == 15)
  THROW_EXCEPTION("Invalid LDRSB/LDRSBT (immediate/literal) encoding: rd = 0xF.");

  if ((rn_bit == 15) && (!p || w))
  THROW_WARNING("Invalid LDRSB (literal) encoding: p != 1 or w != 0.");

  operand = (imm << 4) | rm_bit;
  this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15) {
    operand = (imm << 4) | rm_bit;
    address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);
  }

  rd = (int)sign_extend(data_memory.read_byte(address), 8);
  stall(2);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LDRSB_r::LDRSB_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory),
  LSOffsetOp(R, instr_memory, data_memory) {


} // LDRSB_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRSB_r::get_id() const throw() {

  return 85;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRSB_r::get_name() const throw() {

  return "LDRSB_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRSB_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRSB";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LDRSB_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LDRSB_r::replicate(Instruction* instr)
const throw() {

  LDRSB_r* new_instr = new LDRSB_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LDRSB_r* old_instr = dynamic_cast<LDRSB_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->p = old_instr->p;
      new_instr->u = old_instr->u;
      new_instr->w = old_instr->w;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRSB_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid LDRSB/LDRSBT (register) encoding: (rn = 0xF or rn = rd) and writeback.");

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid LDRSB/LDRSBT (register) encoding: rd|rm = 0xF.");

  if (imm)
  THROW_WARNING("Invalid LDRSH/LDRSHT (register) encoding: rs != 0x0.");

  operand = rm;
  this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15) {
    operand = (imm << 4) | rm_bit;
    address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);
  }

  rd = (int)sign_extend(data_memory.read_byte(address), 8);
  stall(2);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LDRH_i::LDRH_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory),
  LSOffsetOp(R, instr_memory, data_memory) {


} // LDRH_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRH_i::get_id() const throw() {

  return 86;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRH_i::get_name() const throw() {

  return "LDRH_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRH_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRH";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LDRH_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LDRH_i::replicate(Instruction* instr)
const throw() {

  LDRH_i* new_instr = new LDRH_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LDRH_i* old_instr = dynamic_cast<LDRH_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->p = old_instr->p;
      new_instr->u = old_instr->u;
      new_instr->w = old_instr->w;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRH_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit != 15) && (!p || w) && (rn_bit == rd_bit))
  THROW_EXCEPTION("Invalid LDRH/LDRHT (immediate) encoding: rn = rd and writeback.");

  if ((rn_bit != 15) && (!p && w) && (rn_bit == 15))
  THROW_EXCEPTION("Invalid LDRHT (immediate) encoding: rn = 0xF.");

  if (rd_bit == 15)
  THROW_EXCEPTION("Invalid LDRH/LDRHT (immediate/literal) encoding: rd = 0xF.");

  if ((rn_bit == 15) && (p == w))
  THROW_EXCEPTION("Invalid LDRH (literal) encoding: p = w.");

  operand = (imm << 4) | rm_bit;
  this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15) {
    operand = (imm << 4) | rm_bit;
    address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);
  }

  rd = data_memory.read_half(address);
  stall(2);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LDRH_r::LDRH_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory),
  LSOffsetOp(R, instr_memory, data_memory) {


} // LDRH_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRH_r::get_id() const throw() {

  return 87;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRH_r::get_name() const throw() {

  return "LDRH_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRH_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRH";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LDRH_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LDRH_r::replicate(Instruction* instr)
const throw() {

  LDRH_r* new_instr = new LDRH_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LDRH_r* old_instr = dynamic_cast<LDRH_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->p = old_instr->p;
      new_instr->u = old_instr->u;
      new_instr->w = old_instr->w;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRH_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid LDRH/LDRHT (register) encoding: (rn = 0xF or rn = rd) and writeback.");

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid LDRH/LDRHT (register) encoding: rd|rm = 0xF.");

  if (imm)
  THROW_WARNING("Invalid LDRSH/LDRSHT (register) encoding: rs != 0x0.");

  operand = rm;
  this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15) {
    operand = (imm << 4) | rm_bit;
    address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);
  }

  rd = data_memory.read_half(address);
  stall(2);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LDREXH::LDREXH(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // LDREXH()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDREXH::get_id() const throw() {

  return 88;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDREXH::get_name() const throw() {

  return "LDREXH";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDREXH::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LDREXH";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LDREXH::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LDREXH::replicate(Instruction* instr)
const throw() {

  LDREXH* new_instr = new LDREXH(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LDREXH* old_instr = dynamic_cast<LDREXH*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDREXH::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15))
  THROW_EXCEPTION("Invalid LDREXH encoding: rn|rd = 0xF.");

  if ((rs_bit != 15) || (rm_bit != 15))
  THROW_WARNING("Invalid LDREXH encoding: rs|rm != 0xF.");

  rd = data_memory.read_half(rn);
  stall(2);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LDRSH_i::LDRSH_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory),
  LSOffsetOp(R, instr_memory, data_memory) {


} // LDRSH_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRSH_i::get_id() const throw() {

  return 89;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRSH_i::get_name() const throw() {

  return "LDRSH_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRSH_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRSH";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LDRSH_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LDRSH_i::replicate(Instruction* instr)
const throw() {

  LDRSH_i* new_instr = new LDRSH_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LDRSH_i* old_instr = dynamic_cast<LDRSH_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->p = old_instr->p;
      new_instr->u = old_instr->u;
      new_instr->w = old_instr->w;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRSH_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit != 15) && (!p || w) && (rn_bit == rd_bit))
  THROW_EXCEPTION("Invalid LDRSH/LDRSHT (immediate) encoding: rn = rd and writeback.");

  if ((rn_bit != 15) && (!p && w) && (rn_bit == 15))
  THROW_EXCEPTION("Invalid LDRSHT (immediate) encoding: rn = 0xF.");

  if (rd_bit == 15)
  THROW_EXCEPTION("Invalid LDRSH/LDRSHT (immediate/literal) encoding: rd = 0xF.");

  if ((rn_bit == 15) && (!p || w))
  THROW_WARNING("Invalid LDRSH (literal) encoding: p != 1 or w != 0.");

  operand = (imm << 4) | rm_bit;
  this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15) {
    operand = (imm << 4) | rm_bit;
    address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);
  }

  rd = (int)sign_extend(data_memory.read_half(address), 16);
  stall(2);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LDRSH_r::LDRSH_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory),
  LSOffsetOp(R, instr_memory, data_memory) {


} // LDRSH_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRSH_r::get_id() const throw() {

  return 90;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRSH_r::get_name() const throw() {

  return "LDRSH_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRSH_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRSH";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LDRSH_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LDRSH_r::replicate(Instruction* instr)
const throw() {

  LDRSH_r* new_instr = new LDRSH_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LDRSH_r* old_instr = dynamic_cast<LDRSH_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->p = old_instr->p;
      new_instr->u = old_instr->u;
      new_instr->w = old_instr->w;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRSH_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid LDRSH/LDRSHT (register) encoding: (rn = 0xF or rn = rd) and writeback.");

  if ((rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid LDRSH/LDRSHT (register) encoding: rd|rm = 0xF.");

  if (imm)
  THROW_WARNING("Invalid LDRSH/LDRSHT (register) encoding: rs != 0x0.");

  operand = rm;
  this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15) {
    operand = (imm << 4) | rm_bit;
    address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);
  }

  rd = (int)sign_extend(data_memory.read_half(address), 16);
  stall(2);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LDRD_i::LDRD_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory),
  LSOffsetOp(R, instr_memory, data_memory) {


} // LDRD_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRD_i::get_id() const throw() {

  return 91;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRD_i::get_name() const throw() {

  return "LDRD_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRD_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRD";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LDRD_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LDRD_i::replicate(Instruction* instr)
const throw() {

  LDRD_i* new_instr = new LDRD_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LDRD_i* old_instr = dynamic_cast<LDRD_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->p = old_instr->p;
      new_instr->u = old_instr->u;
      new_instr->w = old_instr->w;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRD_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit != 15) && (!p || w) && ((rn_bit == rd_bit) || (rn_bit == rd_bit+1)))
  THROW_EXCEPTION("Invalid LDRD (immediate) encoding: rn = rd|rd+1 and writeback.");

  if ((rn_bit != 15) && !p && w)
  THROW_EXCEPTION("Invalid LDRD (immediate) encoding: p = 0 and w = 1. There is no LDRDT instruction.");

  if (rd_bit == 14)
  THROW_EXCEPTION("Invalid LDRD (immediate/literal) encoding: rd = 0xE.");

  if (rd_bit & 0x1)
  THROW_EXCEPTION("Invalid LDRD (immediate/literal) encoding: rd[0] = 1.");

  if ((rn_bit == 15) && (!p || w))
  THROW_WARNING("Invalid LDRD (literal) encoding: p != 1 or w != 0.");

  operand = (imm << 4) | rm_bit;

#ifdef ACC_MODEL
  REGS[rd_bit+1].lock(this, 3 /* in decode */, 3 /* write in execute, 3 cycles
  ahead */);
#endif
  this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15) {
    operand = (imm << 4) | rm_bit;
    address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);
  }

  rd = data_memory.read_word(address);
  REGS[rd_bit+1] = data_memory.read_word(address+4);
  stall(2);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LDRD_r::LDRD_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory),
  LSOffsetOp(R, instr_memory, data_memory) {


} // LDRD_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRD_r::get_id() const throw() {

  return 92;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRD_r::get_name() const throw() {

  return "LDRD_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDRD_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LDRD";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LDRD_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xf00) >> 8;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LDRD_r::replicate(Instruction* instr)
const throw() {

  LDRD_r* new_instr = new LDRD_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LDRD_r* old_instr = dynamic_cast<LDRD_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->p = old_instr->p;
      new_instr->u = old_instr->u;
      new_instr->w = old_instr->w;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDRD_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit) || (rn_bit == rd_bit+1)))
  THROW_EXCEPTION("Invalid LDRD (register) encoding: (rn = 0xF or rn = rd|rd+1) and writeback.");

  if (!p && w)
  THROW_EXCEPTION("Invalid LDRD (register) encoding: p = 0 and w = 1. There is no LDRDT instruction.");

  if ((rd_bit == 14) || (rm_bit == 15) || (rm_bit == rd_bit) || (rm_bit ==
  rd_bit+1))
  THROW_EXCEPTION("Invalid LDRD (register) encoding: rd = 0xE or rm = 0xF or rm = rd|rd+1.");

  if (rd_bit & 0x1)
  THROW_EXCEPTION("Invalid LDRD (register) encoding: rd[0] = 1.");

  if (imm)
  THROW_WARNING("Invalid LDRD (register) encoding: rs != 0x0.");

#ifdef ACC_MODEL
  REGS[rd_bit+1].lock(this, 3 /* in decode */, 3 /* write in execute, 3 cycles
  ahead */);
#endif

  operand = rm;
  this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  if (rn_bit == 15) {
    operand = (imm << 4) | rm_bit;
    address = (u? (PC & 0xFFFFFFFC) + operand : (PC & 0xFFFFFFFC) - operand);
  }

  rd = data_memory.read_word(address);
  REGS[rd_bit+1] = data_memory.read_word(address+4);
  stall(2);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LDREXD::LDREXD(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // LDREXD()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDREXD::get_id() const throw() {

  return 93;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDREXD::get_name() const throw() {

  return "LDREXD";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::LDREXD::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "LDREXD";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LDREXD::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::LDREXD::replicate(Instruction* instr)
const throw() {

  LDREXD* new_instr = new LDREXD(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    LDREXD* old_instr = dynamic_cast<LDREXD*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LDREXD::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 14) || (rd_bit & 0x1))
  THROW_EXCEPTION("Invalid LDREXD encoding: rn = 0xF or rd = 0xE or rd[0] = 1.");

  if ((rs_bit != 15) || (rm_bit != 15))
  THROW_WARNING("Invalid LDREXD encoding: rs|rm != 0xF.");

#ifdef ACC_MODEL
  REGS[rd_bit+1].lock(this, 3 /* in decode */, 3 /* write in execute, 3 cycles
  ahead */);
#endif

  if (CPSR[CPSR_E] /* TODO: BigEndian() */) {
    REGS[rd_bit+1] = data_memory.read_word(rn);
    rd = data_memory.read_word(rn+4);
  } else {
    rd = data_memory.read_word(rn);
    REGS[rd_bit+1] = data_memory.read_word(rn+4);
  }
  stall(2);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::STR_i::STR_i(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory),
  LSOffsetOp(R, instr_memory, data_memory) {


} // STR_i()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::STR_i::get_id() const throw() {

  return 94;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::STR_i::get_name() const throw() {

  return "STR_i";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::STR_i::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "STR";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::showbase << std::hex << this->imm;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::STR_i::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->imm = (bitstring & 0xfff);
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::STR_i::replicate(Instruction* instr) const
throw() {

  STR_i* new_instr = new STR_i(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    STR_i* old_instr = dynamic_cast<STR_i*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->p = old_instr->p;
      new_instr->u = old_instr->u;
      new_instr->w = old_instr->w;
      new_instr->imm = old_instr->imm;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::STR_i::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  //if (p && !u && w && (rn_bit == 13) && (imm == 0x004))
  // PUSH is caught by the decoder as a subinstruction and never redirects here.

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid STR/STRT (immediate) encoding: (rn = 0xF or rn = rd) and writeback.");

  operand = imm;
  this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  data_memory.write_word(address, rd);
  stall(1);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::STR_r::STR_r(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  DecodeImmShiftOp(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory),
  LSOffsetOp(R, instr_memory, data_memory) {


} // STR_r()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::STR_r::get_id() const throw() {

  return 95;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::STR_r::get_name() const throw() {

  return "STR_r";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::STR_r::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "STR";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  switch(this->p) {
    case 0: {
      oss << "]";
    break;}
  }
  oss << ", ";
  switch(this->u) {
    case 0: {
      oss << "-";
    break;}
    case 1: {
      oss << "+";
    break;}
  }
  oss << std::dec << this->rm_bit;
  oss << ", ";
  oss << std::showbase << std::hex << this->shift_amm;
  switch(this->p) {
    case 1: {
      oss << "]";
    break;}
  }
  switch(this->w) {
    case 1: {
      oss << "!";
    break;}
  }
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::STR_r::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
  this->p = (bitstring & 0x1000000) >> 24;
  this->u = (bitstring & 0x800000) >> 23;
  this->w = (bitstring & 0x200000) >> 21;
  this->shift_amm = (bitstring & 0xf80) >> 7;
  this->shift_op = (bitstring & 0x60) >> 5;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::STR_r::replicate(Instruction* instr) const
throw() {

  STR_r* new_instr = new STR_r(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    STR_r* old_instr = dynamic_cast<STR_r*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->cond = old_instr->cond;
      new_instr->p = old_instr->p;
      new_instr->u = old_instr->u;
      new_instr->w = old_instr->w;
      new_instr->shift_amm = old_instr->shift_amm;
      new_instr->shift_op = old_instr->shift_op;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::STR_r::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
  THROW_EXCEPTION("Invalid STR/STRT (register) encoding: (rn = 0xF or rn = rd) and writeback.");

  if (rm_bit == 15)
  THROW_EXCEPTION("Invalid STR/STRT (register) encoding: rm = 0xF.");
  this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
  this->shift_op, this->operand, this->carry);
  this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
  this->w, this->operand, this->address);

  data_memory.write_word(address, rd);
  stall(1);
  return this->num_instr_cycles;
} // behavior()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::STREX::STREX(
    Registers& R,
    MemoryInterface& instr_memory,
    MemoryInterface& data_memory) :
  Instruction(R, instr_memory, data_memory),
  ConditionPassedOp(R, instr_memory, data_memory) {


} // STREX()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::STREX::get_id() const throw() {

  return 96;
} // get_id()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::STREX::get_name() const throw() {

  return "STREX";
} // get_name()

// -----------------------------------------------------------------------------

std::string core_armcortexa9_funclt::STREX::get_mnemonic() const throw() {

  std::ostringstream oss (std::ostringstream::out);
  oss << "STREX";
  oss << std::showbase << std::hex << this->cond;
  oss << " R";
  oss << std::dec << this->rd_bit;
  oss << ", R";
  oss << std::dec << this->rm_bit;
  oss << ", [R";
  oss << std::dec << this->rn_bit;
  oss << "]";
  return oss.str();
} // get_mnemonic()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::STREX::set_params(const unsigned& bitstring)
throw() {

  this->rd_bit = (bitstring & 0xf000) >> 12;
  this->rd.set_alias(REGS[this->rd_bit]);
  this->rm_bit = (bitstring & 0xf);
  this->rm.set_alias(REGS[this->rm_bit]);
  this->rn_bit = (bitstring & 0xf0000) >> 16;
  this->rn.set_alias(REGS[this->rn_bit]);
  this->rs_bit = (bitstring & 0xf00) >> 8;
  this->rs.set_alias(REGS[this->rs_bit]);
  this->cond = (bitstring & 0xf0000000) >> 28;
} // set_params()

// -----------------------------------------------------------------------------

Instruction* core_armcortexa9_funclt::STREX::replicate(Instruction* instr) const
throw() {

  STREX* new_instr = new STREX(R, instr_memory, data_memory);

  // Set instruction fields.
  if (instr) {
    STREX* old_instr = dynamic_cast<STREX*>(instr);
    if (old_instr) {
      new_instr->rd_bit = old_instr->rd_bit;
      new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
      new_instr->rm_bit = old_instr->rm_bit;
      new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
      new_instr->rn_bit = old_instr->rn_bit;
      new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
      new_instr->rs_bit = old_instr->rs_bit;
      new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
      new_instr->cond = old_instr->cond;
    }
  }
  return new_instr;
} // replicate()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::STREX::behavior() {

  this->num_instr_cycles = 0;
  this->num_instr_cycles += ConditionPassed(this->cond);

  if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
  THROW_EXCEPTION("Invalid STREX encoding: rn|rd|rm = 0xF.");

  if ((rn_bit == rd_bit) || (rd_bit == rm_bit))
  THROW_EXCEPTION("Invalid STREX encoding: rn|rm = rd.");

  if (rs_bit != 15)
  THROW_WARNING("Invalid STREX encoding: rs != 0xF.");

  // TODO: if (ExclusiveMonitorsPass(rn, 4)) {
    data_memory.write_word(rn, rm);
    rd = 0;
    //} else rd = 1;
    stall(1);
    return this->num_instr_cycles;
  } // behavior()

  // ---------------------------------------------------------------------------


  // ***************************************************************************

  core_armcortexa9_funclt::STRB_i::STRB_i(
      Registers& R,
      MemoryInterface& instr_memory,
      MemoryInterface& data_memory) :
    Instruction(R, instr_memory, data_memory),
    ConditionPassedOp(R, instr_memory, data_memory),
    LSOffsetOp(R, instr_memory, data_memory) {


  } // STRB_i()

  // ---------------------------------------------------------------------------

  unsigned core_armcortexa9_funclt::STRB_i::get_id() const throw() {

    return 97;
  } // get_id()

  // ---------------------------------------------------------------------------

  std::string core_armcortexa9_funclt::STRB_i::get_name() const throw() {

    return "STRB_i";
  } // get_name()

  // ---------------------------------------------------------------------------

  std::string core_armcortexa9_funclt::STRB_i::get_mnemonic() const throw() {

    std::ostringstream oss (std::ostringstream::out);
    oss << "STRB";
    oss << std::showbase << std::hex << this->cond;
    oss << " R";
    oss << std::dec << this->rd_bit;
    oss << ", [R";
    oss << std::dec << this->rn_bit;
    switch(this->p) {
      case 0: {
        oss << "]";
      break;}
    }
    oss << ", ";
    switch(this->u) {
      case 0: {
        oss << "-";
      break;}
      case 1: {
        oss << "+";
      break;}
    }
    oss << std::showbase << std::hex << this->imm;
    switch(this->p) {
      case 1: {
        oss << "]";
      break;}
    }
    switch(this->w) {
      case 1: {
        oss << "!";
      break;}
    }
    return oss.str();
  } // get_mnemonic()

  // ---------------------------------------------------------------------------

  void core_armcortexa9_funclt::STRB_i::set_params(const unsigned& bitstring)
  throw() {

    this->rd_bit = (bitstring & 0xf000) >> 12;
    this->rd.set_alias(REGS[this->rd_bit]);
    this->rn_bit = (bitstring & 0xf0000) >> 16;
    this->rn.set_alias(REGS[this->rn_bit]);
    this->cond = (bitstring & 0xf0000000) >> 28;
    this->p = (bitstring & 0x1000000) >> 24;
    this->u = (bitstring & 0x800000) >> 23;
    this->w = (bitstring & 0x200000) >> 21;
    this->imm = (bitstring & 0xfff);
  } // set_params()

  // ---------------------------------------------------------------------------

  Instruction* core_armcortexa9_funclt::STRB_i::replicate(Instruction* instr)
  const throw() {

    STRB_i* new_instr = new STRB_i(R, instr_memory, data_memory);

    // Set instruction fields.
    if (instr) {
      STRB_i* old_instr = dynamic_cast<STRB_i*>(instr);
      if (old_instr) {
        new_instr->rd_bit = old_instr->rd_bit;
        new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
        new_instr->rn_bit = old_instr->rn_bit;
        new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
        new_instr->cond = old_instr->cond;
        new_instr->p = old_instr->p;
        new_instr->u = old_instr->u;
        new_instr->w = old_instr->w;
        new_instr->imm = old_instr->imm;
      }
    }
    return new_instr;
  } // replicate()

  // ---------------------------------------------------------------------------

  unsigned core_armcortexa9_funclt::STRB_i::behavior() {

    this->num_instr_cycles = 0;
    this->num_instr_cycles += ConditionPassed(this->cond);

    if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
    THROW_EXCEPTION("Invalid STRB/STRBT (immediate) encoding: (rn = 0xF or rn = rd) and writeback.");

    if (rd_bit == 15)
    THROW_EXCEPTION("Invalid STRB/STRBT (immediate) encoding: rd = 0xF.");

    operand = imm;
    this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
    this->w, this->operand, this->address);

    data_memory.write_byte(address, (unsigned char)(rd & 0x000000FF));
    stall(1);
    return this->num_instr_cycles;
  } // behavior()

  // ---------------------------------------------------------------------------


  // ***************************************************************************

  core_armcortexa9_funclt::STRB_r::STRB_r(
      Registers& R,
      MemoryInterface& instr_memory,
      MemoryInterface& data_memory) :
    Instruction(R, instr_memory, data_memory),
    DecodeImmShiftOp(R, instr_memory, data_memory),
    ConditionPassedOp(R, instr_memory, data_memory),
    LSOffsetOp(R, instr_memory, data_memory) {


  } // STRB_r()

  // ---------------------------------------------------------------------------

  unsigned core_armcortexa9_funclt::STRB_r::get_id() const throw() {

    return 98;
  } // get_id()

  // ---------------------------------------------------------------------------

  std::string core_armcortexa9_funclt::STRB_r::get_name() const throw() {

    return "STRB_r";
  } // get_name()

  // ---------------------------------------------------------------------------

  std::string core_armcortexa9_funclt::STRB_r::get_mnemonic() const throw() {

    std::ostringstream oss (std::ostringstream::out);
    oss << "STRB";
    oss << std::showbase << std::hex << this->cond;
    oss << " R";
    oss << std::dec << this->rd_bit;
    oss << ", [R";
    oss << std::dec << this->rn_bit;
    switch(this->p) {
      case 0: {
        oss << "]";
      break;}
    }
    oss << ", ";
    switch(this->u) {
      case 0: {
        oss << "-";
      break;}
      case 1: {
        oss << "+";
      break;}
    }
    oss << std::dec << this->rm_bit;
    oss << ", ";
    oss << std::showbase << std::hex << this->shift_amm;
    switch(this->p) {
      case 1: {
        oss << "]";
      break;}
    }
    switch(this->w) {
      case 1: {
        oss << "!";
      break;}
    }
    return oss.str();
  } // get_mnemonic()

  // ---------------------------------------------------------------------------

  void core_armcortexa9_funclt::STRB_r::set_params(const unsigned& bitstring)
  throw() {

    this->rd_bit = (bitstring & 0xf000) >> 12;
    this->rd.set_alias(REGS[this->rd_bit]);
    this->rm_bit = (bitstring & 0xf);
    this->rm.set_alias(REGS[this->rm_bit]);
    this->rn_bit = (bitstring & 0xf0000) >> 16;
    this->rn.set_alias(REGS[this->rn_bit]);
    this->cond = (bitstring & 0xf0000000) >> 28;
    this->p = (bitstring & 0x1000000) >> 24;
    this->u = (bitstring & 0x800000) >> 23;
    this->w = (bitstring & 0x200000) >> 21;
    this->shift_amm = (bitstring & 0xf80) >> 7;
    this->shift_op = (bitstring & 0x60) >> 5;
  } // set_params()

  // ---------------------------------------------------------------------------

  Instruction* core_armcortexa9_funclt::STRB_r::replicate(Instruction* instr)
  const throw() {

    STRB_r* new_instr = new STRB_r(R, instr_memory, data_memory);

    // Set instruction fields.
    if (instr) {
      STRB_r* old_instr = dynamic_cast<STRB_r*>(instr);
      if (old_instr) {
        new_instr->rd_bit = old_instr->rd_bit;
        new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
        new_instr->rm_bit = old_instr->rm_bit;
        new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
        new_instr->rn_bit = old_instr->rn_bit;
        new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
        new_instr->cond = old_instr->cond;
        new_instr->p = old_instr->p;
        new_instr->u = old_instr->u;
        new_instr->w = old_instr->w;
        new_instr->shift_amm = old_instr->shift_amm;
        new_instr->shift_op = old_instr->shift_op;
      }
    }
    return new_instr;
  } // replicate()

  // ---------------------------------------------------------------------------

  unsigned core_armcortexa9_funclt::STRB_r::behavior() {

    this->num_instr_cycles = 0;
    this->num_instr_cycles += ConditionPassed(this->cond);

    if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
    THROW_EXCEPTION("Invalid STRB/STRBT (register) encoding: (rn = 0xF or rn = rd) and writeback.");

    if ((rd_bit == 15) || (rm_bit == 15))
    THROW_EXCEPTION("Invalid STRB/STRBT (register) encoding: rd|rm = 0xF.");
    this->num_instr_cycles += DecodeImmShift(this->rm, this->rm_bit, this->shift_amm,
    this->shift_op, this->operand, this->carry);
    this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p, this->u,
    this->w, this->operand, this->address);

    data_memory.write_byte(address, (unsigned char)(rd & 0x000000FF));
    stall(1);
    return this->num_instr_cycles;
  } // behavior()

  // ---------------------------------------------------------------------------


  // ***************************************************************************

  core_armcortexa9_funclt::STREXB::STREXB(
      Registers& R,
      MemoryInterface& instr_memory,
      MemoryInterface& data_memory) :
    Instruction(R, instr_memory, data_memory),
    ConditionPassedOp(R, instr_memory, data_memory) {


  } // STREXB()

  // ---------------------------------------------------------------------------

  unsigned core_armcortexa9_funclt::STREXB::get_id() const throw() {

    return 99;
  } // get_id()

  // ---------------------------------------------------------------------------

  std::string core_armcortexa9_funclt::STREXB::get_name() const throw() {

    return "STREXB";
  } // get_name()

  // ---------------------------------------------------------------------------

  std::string core_armcortexa9_funclt::STREXB::get_mnemonic() const throw() {

    std::ostringstream oss (std::ostringstream::out);
    oss << "STREXB";
    oss << std::showbase << std::hex << this->cond;
    oss << " R";
    oss << std::dec << this->rd_bit;
    oss << ", R";
    oss << std::dec << this->rm_bit;
    oss << ", [R";
    oss << std::dec << this->rn_bit;
    oss << "]";
    return oss.str();
  } // get_mnemonic()

  // ---------------------------------------------------------------------------

  void core_armcortexa9_funclt::STREXB::set_params(const unsigned& bitstring)
  throw() {

    this->rd_bit = (bitstring & 0xf000) >> 12;
    this->rd.set_alias(REGS[this->rd_bit]);
    this->rm_bit = (bitstring & 0xf);
    this->rm.set_alias(REGS[this->rm_bit]);
    this->rn_bit = (bitstring & 0xf0000) >> 16;
    this->rn.set_alias(REGS[this->rn_bit]);
    this->rs_bit = (bitstring & 0xf00) >> 8;
    this->rs.set_alias(REGS[this->rs_bit]);
    this->cond = (bitstring & 0xf0000000) >> 28;
  } // set_params()

  // ---------------------------------------------------------------------------

  Instruction* core_armcortexa9_funclt::STREXB::replicate(Instruction* instr)
  const throw() {

    STREXB* new_instr = new STREXB(R, instr_memory, data_memory);

    // Set instruction fields.
    if (instr) {
      STREXB* old_instr = dynamic_cast<STREXB*>(instr);
      if (old_instr) {
        new_instr->rd_bit = old_instr->rd_bit;
        new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
        new_instr->rm_bit = old_instr->rm_bit;
        new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
        new_instr->rn_bit = old_instr->rn_bit;
        new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
        new_instr->rs_bit = old_instr->rs_bit;
        new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
        new_instr->cond = old_instr->cond;
      }
    }
    return new_instr;
  } // replicate()

  // ---------------------------------------------------------------------------

  unsigned core_armcortexa9_funclt::STREXB::behavior() {

    this->num_instr_cycles = 0;
    this->num_instr_cycles += ConditionPassed(this->cond);

    if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
    THROW_EXCEPTION("Invalid STREXB encoding: rn|rd|rm = 0xF.");

    if ((rn_bit == rd_bit) || (rd_bit == rm_bit))
    THROW_EXCEPTION("Invalid STREXB encoding: rn|rm = rd.");

    if (rs_bit != 15)
    THROW_WARNING("Invalid STREXB encoding: rs != 0xF.");

    // TODO: if (ExclusiveMonitorsPass(rn, 1)) {
      data_memory.write_byte(rn, (unsigned char)(rd & 0x000000FF));
      rd = 0;
      //} else rd = 1;
      stall(1);
      return this->num_instr_cycles;
    } // behavior()

    // -------------------------------------------------------------------------


    // *************************************************************************

    core_armcortexa9_funclt::STRH_i::STRH_i(
        Registers& R,
        MemoryInterface& instr_memory,
        MemoryInterface& data_memory) :
      Instruction(R, instr_memory, data_memory),
      ConditionPassedOp(R, instr_memory, data_memory),
      LSOffsetOp(R, instr_memory, data_memory) {


    } // STRH_i()

    // -------------------------------------------------------------------------

    unsigned core_armcortexa9_funclt::STRH_i::get_id() const throw() {

      return 100;
    } // get_id()

    // -------------------------------------------------------------------------

    std::string core_armcortexa9_funclt::STRH_i::get_name() const throw() {

      return "STRH_i";
    } // get_name()

    // -------------------------------------------------------------------------

    std::string core_armcortexa9_funclt::STRH_i::get_mnemonic() const throw() {

      std::ostringstream oss (std::ostringstream::out);
      oss << "STRH";
      oss << std::showbase << std::hex << this->cond;
      oss << " R";
      oss << std::dec << this->rd_bit;
      oss << ", [R";
      oss << std::dec << this->rn_bit;
      switch(this->p) {
        case 0: {
          oss << "]";
        break;}
      }
      oss << ", ";
      switch(this->u) {
        case 0: {
          oss << "-";
        break;}
        case 1: {
          oss << "+";
        break;}
      }
      oss << std::showbase << std::hex << this->imm;
      oss << std::dec << this->rm_bit;
      switch(this->p) {
        case 1: {
          oss << "]";
        break;}
      }
      switch(this->w) {
        case 1: {
          oss << "!";
        break;}
      }
      return oss.str();
    } // get_mnemonic()

    // -------------------------------------------------------------------------

    void core_armcortexa9_funclt::STRH_i::set_params(const unsigned& bitstring)
    throw() {

      this->rd_bit = (bitstring & 0xf000) >> 12;
      this->rd.set_alias(REGS[this->rd_bit]);
      this->rm_bit = (bitstring & 0xf);
      this->rm.set_alias(REGS[this->rm_bit]);
      this->rn_bit = (bitstring & 0xf0000) >> 16;
      this->rn.set_alias(REGS[this->rn_bit]);
      this->cond = (bitstring & 0xf0000000) >> 28;
      this->p = (bitstring & 0x1000000) >> 24;
      this->u = (bitstring & 0x800000) >> 23;
      this->w = (bitstring & 0x200000) >> 21;
      this->imm = (bitstring & 0xf00) >> 8;
    } // set_params()

    // -------------------------------------------------------------------------

    Instruction* core_armcortexa9_funclt::STRH_i::replicate(Instruction* instr)
    const throw() {

      STRH_i* new_instr = new STRH_i(R, instr_memory, data_memory);

      // Set instruction fields.
      if (instr) {
        STRH_i* old_instr = dynamic_cast<STRH_i*>(instr);
        if (old_instr) {
          new_instr->rd_bit = old_instr->rd_bit;
          new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
          new_instr->rm_bit = old_instr->rm_bit;
          new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
          new_instr->rn_bit = old_instr->rn_bit;
          new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
          new_instr->cond = old_instr->cond;
          new_instr->p = old_instr->p;
          new_instr->u = old_instr->u;
          new_instr->w = old_instr->w;
          new_instr->imm = old_instr->imm;
        }
      }
      return new_instr;
    } // replicate()

    // -------------------------------------------------------------------------

    unsigned core_armcortexa9_funclt::STRH_i::behavior() {

      this->num_instr_cycles = 0;
      this->num_instr_cycles += ConditionPassed(this->cond);

      if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
      THROW_EXCEPTION("Invalid STRH/STRHT (immediate) encoding: (rn = 15 or rn = rd) and writeback.");

      if (rd_bit == 15)
      THROW_EXCEPTION("Invalid STRH/STRHT (immediate) encoding: rd = 0xF.");

      operand = (imm << 4) | rm_bit;
      this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p,
      this->u, this->w, this->operand, this->address);

      data_memory.write_half(address, (unsigned short)(rd & 0x0000FFFF));
      stall(1);
      return this->num_instr_cycles;
    } // behavior()

    // -------------------------------------------------------------------------


    // *************************************************************************

    core_armcortexa9_funclt::STRH_r::STRH_r(
        Registers& R,
        MemoryInterface& instr_memory,
        MemoryInterface& data_memory) :
      Instruction(R, instr_memory, data_memory),
      ConditionPassedOp(R, instr_memory, data_memory),
      LSOffsetOp(R, instr_memory, data_memory) {


    } // STRH_r()

    // -------------------------------------------------------------------------

    unsigned core_armcortexa9_funclt::STRH_r::get_id() const throw() {

      return 101;
    } // get_id()

    // -------------------------------------------------------------------------

    std::string core_armcortexa9_funclt::STRH_r::get_name() const throw() {

      return "STRH_r";
    } // get_name()

    // -------------------------------------------------------------------------

    std::string core_armcortexa9_funclt::STRH_r::get_mnemonic() const throw() {

      std::ostringstream oss (std::ostringstream::out);
      oss << "STRH";
      oss << std::showbase << std::hex << this->cond;
      oss << " R";
      oss << std::dec << this->rd_bit;
      oss << ", [R";
      oss << std::dec << this->rn_bit;
      switch(this->p) {
        case 0: {
          oss << "]";
        break;}
      }
      oss << ", ";
      switch(this->u) {
        case 0: {
          oss << "-";
        break;}
        case 1: {
          oss << "+";
        break;}
      }
      oss << std::dec << this->rm_bit;
      switch(this->p) {
        case 1: {
          oss << "]";
        break;}
      }
      switch(this->w) {
        case 1: {
          oss << "!";
        break;}
      }
      return oss.str();
    } // get_mnemonic()

    // -------------------------------------------------------------------------

    void core_armcortexa9_funclt::STRH_r::set_params(const unsigned& bitstring)
    throw() {

      this->rd_bit = (bitstring & 0xf000) >> 12;
      this->rd.set_alias(REGS[this->rd_bit]);
      this->rm_bit = (bitstring & 0xf);
      this->rm.set_alias(REGS[this->rm_bit]);
      this->rn_bit = (bitstring & 0xf0000) >> 16;
      this->rn.set_alias(REGS[this->rn_bit]);
      this->cond = (bitstring & 0xf0000000) >> 28;
      this->p = (bitstring & 0x1000000) >> 24;
      this->u = (bitstring & 0x800000) >> 23;
      this->w = (bitstring & 0x200000) >> 21;
      this->imm = (bitstring & 0xf00) >> 8;
    } // set_params()

    // -------------------------------------------------------------------------

    Instruction* core_armcortexa9_funclt::STRH_r::replicate(Instruction* instr)
    const throw() {

      STRH_r* new_instr = new STRH_r(R, instr_memory, data_memory);

      // Set instruction fields.
      if (instr) {
        STRH_r* old_instr = dynamic_cast<STRH_r*>(instr);
        if (old_instr) {
          new_instr->rd_bit = old_instr->rd_bit;
          new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
          new_instr->rm_bit = old_instr->rm_bit;
          new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
          new_instr->rn_bit = old_instr->rn_bit;
          new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
          new_instr->cond = old_instr->cond;
          new_instr->p = old_instr->p;
          new_instr->u = old_instr->u;
          new_instr->w = old_instr->w;
          new_instr->imm = old_instr->imm;
        }
      }
      return new_instr;
    } // replicate()

    // -------------------------------------------------------------------------

    unsigned core_armcortexa9_funclt::STRH_r::behavior() {

      this->num_instr_cycles = 0;
      this->num_instr_cycles += ConditionPassed(this->cond);

      if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit)))
      THROW_EXCEPTION("Invalid STRH/STRHT (register) encoding: (rn = 0xF or rn = rd) and writeback.");

      if ((rd_bit == 15) || (rm_bit == 15))
      THROW_EXCEPTION("Invalid STRH/STRHT (register) encoding: rd|rm = 0xF.");

      if (imm)
      THROW_WARNING("Invalid STRH/STRHT (register) encoding: rs != 0x0.");

      operand = rm;
      this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p,
      this->u, this->w, this->operand, this->address);

      data_memory.write_half(address, (unsigned short)(rd & 0x0000FFFF));
      stall(1);
      return this->num_instr_cycles;
    } // behavior()

    // -------------------------------------------------------------------------


    // *************************************************************************

    core_armcortexa9_funclt::STREXH::STREXH(
        Registers& R,
        MemoryInterface& instr_memory,
        MemoryInterface& data_memory) :
      Instruction(R, instr_memory, data_memory),
      ConditionPassedOp(R, instr_memory, data_memory) {


    } // STREXH()

    // -------------------------------------------------------------------------

    unsigned core_armcortexa9_funclt::STREXH::get_id() const throw() {

      return 102;
    } // get_id()

    // -------------------------------------------------------------------------

    std::string core_armcortexa9_funclt::STREXH::get_name() const throw() {

      return "STREXH";
    } // get_name()

    // -------------------------------------------------------------------------

    std::string core_armcortexa9_funclt::STREXH::get_mnemonic() const throw() {

      std::ostringstream oss (std::ostringstream::out);
      oss << "STREXH";
      oss << std::showbase << std::hex << this->cond;
      oss << " R";
      oss << std::dec << this->rd_bit;
      oss << ", R";
      oss << std::dec << this->rm_bit;
      oss << ", [R";
      oss << std::dec << this->rn_bit;
      oss << "]";
      return oss.str();
    } // get_mnemonic()

    // -------------------------------------------------------------------------

    void core_armcortexa9_funclt::STREXH::set_params(const unsigned& bitstring)
    throw() {

      this->rd_bit = (bitstring & 0xf000) >> 12;
      this->rd.set_alias(REGS[this->rd_bit]);
      this->rm_bit = (bitstring & 0xf);
      this->rm.set_alias(REGS[this->rm_bit]);
      this->rn_bit = (bitstring & 0xf0000) >> 16;
      this->rn.set_alias(REGS[this->rn_bit]);
      this->rs_bit = (bitstring & 0xf00) >> 8;
      this->rs.set_alias(REGS[this->rs_bit]);
      this->cond = (bitstring & 0xf0000000) >> 28;
    } // set_params()

    // -------------------------------------------------------------------------

    Instruction* core_armcortexa9_funclt::STREXH::replicate(Instruction* instr)
    const throw() {

      STREXH* new_instr = new STREXH(R, instr_memory, data_memory);

      // Set instruction fields.
      if (instr) {
        STREXH* old_instr = dynamic_cast<STREXH*>(instr);
        if (old_instr) {
          new_instr->rd_bit = old_instr->rd_bit;
          new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
          new_instr->rm_bit = old_instr->rm_bit;
          new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
          new_instr->rn_bit = old_instr->rn_bit;
          new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
          new_instr->rs_bit = old_instr->rs_bit;
          new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
          new_instr->cond = old_instr->cond;
        }
      }
      return new_instr;
    } // replicate()

    // -------------------------------------------------------------------------

    unsigned core_armcortexa9_funclt::STREXH::behavior() {

      this->num_instr_cycles = 0;
      this->num_instr_cycles += ConditionPassed(this->cond);

      if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
      THROW_EXCEPTION("Invalid STREXH encoding: rn|rd|rm = 0xF.");

      if ((rn_bit == rd_bit) || (rd_bit == rm_bit))
      THROW_EXCEPTION("Invalid STREXH encoding: rn|rm = rd.");

      if (rs_bit != 15)
      THROW_WARNING("Invalid STREXH encoding: rs != 0xF.");

      // TODO: if (ExclusiveMonitorsPass(rn, 2)) {
        data_memory.write_half(rn, (unsigned char)(rd & 0x0000FFFF));
        rd = 0;
        //} else rd = 1;
        stall(1);
        return this->num_instr_cycles;
      } // behavior()

      // -----------------------------------------------------------------------


      // ***********************************************************************

      core_armcortexa9_funclt::STRD_i::STRD_i(
          Registers& R,
          MemoryInterface& instr_memory,
          MemoryInterface& data_memory) :
        Instruction(R, instr_memory, data_memory),
        ConditionPassedOp(R, instr_memory, data_memory),
        LSOffsetOp(R, instr_memory, data_memory) {


      } // STRD_i()

      // -----------------------------------------------------------------------

      unsigned core_armcortexa9_funclt::STRD_i::get_id() const throw() {

        return 103;
      } // get_id()

      // -----------------------------------------------------------------------

      std::string core_armcortexa9_funclt::STRD_i::get_name() const throw() {

        return "STRD_i";
      } // get_name()

      // -----------------------------------------------------------------------

      std::string core_armcortexa9_funclt::STRD_i::get_mnemonic() const throw()
      {

        std::ostringstream oss (std::ostringstream::out);
        oss << "STRD";
        oss << std::showbase << std::hex << this->cond;
        oss << " R";
        oss << std::dec << this->rd_bit;
        oss << ", [R";
        oss << std::dec << this->rn_bit;
        switch(this->p) {
          case 0: {
            oss << "]";
          break;}
        }
        oss << ", ";
        switch(this->u) {
          case 0: {
            oss << "-";
          break;}
          case 1: {
            oss << "+";
          break;}
        }
        oss << std::showbase << std::hex << this->imm;
        oss << std::dec << this->rm_bit;
        switch(this->p) {
          case 1: {
            oss << "]";
          break;}
        }
        switch(this->w) {
          case 1: {
            oss << "!";
          break;}
        }
        return oss.str();
      } // get_mnemonic()

      // -----------------------------------------------------------------------

      void core_armcortexa9_funclt::STRD_i::set_params(const unsigned& bitstring)
      throw() {

        this->rd_bit = (bitstring & 0xf000) >> 12;
        this->rd.set_alias(REGS[this->rd_bit]);
        this->rm_bit = (bitstring & 0xf);
        this->rm.set_alias(REGS[this->rm_bit]);
        this->rn_bit = (bitstring & 0xf0000) >> 16;
        this->rn.set_alias(REGS[this->rn_bit]);
        this->cond = (bitstring & 0xf0000000) >> 28;
        this->p = (bitstring & 0x1000000) >> 24;
        this->u = (bitstring & 0x800000) >> 23;
        this->w = (bitstring & 0x200000) >> 21;
        this->imm = (bitstring & 0xf00) >> 8;
      } // set_params()

      // -----------------------------------------------------------------------

      Instruction* core_armcortexa9_funclt::STRD_i::replicate(Instruction*
      instr) const throw() {

        STRD_i* new_instr = new STRD_i(R, instr_memory, data_memory);

        // Set instruction fields.
        if (instr) {
          STRD_i* old_instr = dynamic_cast<STRD_i*>(instr);
          if (old_instr) {
            new_instr->rd_bit = old_instr->rd_bit;
            new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
            new_instr->rm_bit = old_instr->rm_bit;
            new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
            new_instr->rn_bit = old_instr->rn_bit;
            new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
            new_instr->cond = old_instr->cond;
            new_instr->p = old_instr->p;
            new_instr->u = old_instr->u;
            new_instr->w = old_instr->w;
            new_instr->imm = old_instr->imm;
          }
        }
        return new_instr;
      } // replicate()

      // -----------------------------------------------------------------------

      unsigned core_armcortexa9_funclt::STRD_i::behavior() {

        this->num_instr_cycles = 0;
        this->num_instr_cycles += ConditionPassed(this->cond);

        if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit) || (rn_bit ==
        rd_bit+1)))
        THROW_EXCEPTION("Invalid LDRD (immediate) encoding: rn = rd|rd+1 and writeback.");

        if (!p && w)
        THROW_EXCEPTION("Invalid STRD (immediate) encoding: p = 0 and w = 1. There is no STRDT instruction.");

        if (rd_bit == 14)
        THROW_EXCEPTION("Invalid STRD (immediate) encoding: rd = 0xE.");

        if (rd_bit & 0x1)
        THROW_EXCEPTION("Invalid STRD (immediate) encoding: rd[0] = 1.");

        operand = (imm << 4) | rm_bit;

#ifdef ACC_MODEL
        REGS[rd_bit+1].is_locked(this, 3 /* in decode */, 3 /* read in execute,
        3 cycles ahead */);
#endif
        this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p,
        this->u, this->w, this->operand, this->address);

        data_memory.write_word(address, rd);
        data_memory.write_word(address+4, REGS[rd_bit+1]);
        stall(1);
        return this->num_instr_cycles;
      } // behavior()

      // -----------------------------------------------------------------------


      // ***********************************************************************

      core_armcortexa9_funclt::STRD_r::STRD_r(
          Registers& R,
          MemoryInterface& instr_memory,
          MemoryInterface& data_memory) :
        Instruction(R, instr_memory, data_memory),
        ConditionPassedOp(R, instr_memory, data_memory),
        LSOffsetOp(R, instr_memory, data_memory) {


      } // STRD_r()

      // -----------------------------------------------------------------------

      unsigned core_armcortexa9_funclt::STRD_r::get_id() const throw() {

        return 104;
      } // get_id()

      // -----------------------------------------------------------------------

      std::string core_armcortexa9_funclt::STRD_r::get_name() const throw() {

        return "STRD_r";
      } // get_name()

      // -----------------------------------------------------------------------

      std::string core_armcortexa9_funclt::STRD_r::get_mnemonic() const throw()
      {

        std::ostringstream oss (std::ostringstream::out);
        oss << "STRD";
        oss << std::showbase << std::hex << this->cond;
        oss << " R";
        oss << std::dec << this->rd_bit;
        oss << ", [R";
        oss << std::dec << this->rn_bit;
        switch(this->p) {
          case 0: {
            oss << "]";
          break;}
        }
        oss << ", ";
        switch(this->u) {
          case 0: {
            oss << "-";
          break;}
          case 1: {
            oss << "+";
          break;}
        }
        oss << std::dec << this->rm_bit;
        switch(this->p) {
          case 1: {
            oss << "]";
          break;}
        }
        switch(this->w) {
          case 1: {
            oss << "!";
          break;}
        }
        return oss.str();
      } // get_mnemonic()

      // -----------------------------------------------------------------------

      void core_armcortexa9_funclt::STRD_r::set_params(const unsigned& bitstring)
      throw() {

        this->rd_bit = (bitstring & 0xf000) >> 12;
        this->rd.set_alias(REGS[this->rd_bit]);
        this->rm_bit = (bitstring & 0xf);
        this->rm.set_alias(REGS[this->rm_bit]);
        this->rn_bit = (bitstring & 0xf0000) >> 16;
        this->rn.set_alias(REGS[this->rn_bit]);
        this->cond = (bitstring & 0xf0000000) >> 28;
        this->p = (bitstring & 0x1000000) >> 24;
        this->u = (bitstring & 0x800000) >> 23;
        this->w = (bitstring & 0x200000) >> 21;
        this->imm = (bitstring & 0xf00) >> 8;
      } // set_params()

      // -----------------------------------------------------------------------

      Instruction* core_armcortexa9_funclt::STRD_r::replicate(Instruction*
      instr) const throw() {

        STRD_r* new_instr = new STRD_r(R, instr_memory, data_memory);

        // Set instruction fields.
        if (instr) {
          STRD_r* old_instr = dynamic_cast<STRD_r*>(instr);
          if (old_instr) {
            new_instr->rd_bit = old_instr->rd_bit;
            new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
            new_instr->rm_bit = old_instr->rm_bit;
            new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
            new_instr->rn_bit = old_instr->rn_bit;
            new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
            new_instr->cond = old_instr->cond;
            new_instr->p = old_instr->p;
            new_instr->u = old_instr->u;
            new_instr->w = old_instr->w;
            new_instr->imm = old_instr->imm;
          }
        }
        return new_instr;
      } // replicate()

      // -----------------------------------------------------------------------

      unsigned core_armcortexa9_funclt::STRD_r::behavior() {

        this->num_instr_cycles = 0;
        this->num_instr_cycles += ConditionPassed(this->cond);

        if ((!p || w) && ((rn_bit == 15) || (rn_bit == rd_bit) || (rn_bit ==
        rd_bit+1)))
        THROW_EXCEPTION("Invalid STRD (register) encoding: (rn = 0xF or rn = rd|rd+1) and writeback.");

        if (!p && w)
        THROW_EXCEPTION("Invalid STRD (register) encoding: p = 0 and w = 1. There is no STRDT instruction.");

        if ((rd_bit == 14) || (rm_bit == 15))
        THROW_EXCEPTION("Invalid STRD (register) encoding: rd = 0xE or rm = 0xF or rm = rd|rd+1.");

        if (rd_bit & 0x1)
        THROW_EXCEPTION("Invalid STRD (register) encoding: rd[0] = 1.");

        if (imm)
        THROW_WARNING("Invalid STRD (register) encoding: rs != 0x0.");

#ifdef ACC_MODEL
        REGS[rd_bit+1].is_locked(this, 3 /* in decode */, 3 /* read in execute,
        3 cycles ahead */);
#endif

        operand = rm;
        this->num_instr_cycles += LSOffset(this->rn, this->rn_bit, this->p,
        this->u, this->w, this->operand, this->address);

        data_memory.write_word(address, rd);
        data_memory.write_word(address+4, REGS[rd_bit+1]);
        stall(1);
        return this->num_instr_cycles;
      } // behavior()

      // -----------------------------------------------------------------------


      // ***********************************************************************

      core_armcortexa9_funclt::STREXD::STREXD(
          Registers& R,
          MemoryInterface& instr_memory,
          MemoryInterface& data_memory) :
        Instruction(R, instr_memory, data_memory),
        ConditionPassedOp(R, instr_memory, data_memory) {


      } // STREXD()

      // -----------------------------------------------------------------------

      unsigned core_armcortexa9_funclt::STREXD::get_id() const throw() {

        return 105;
      } // get_id()

      // -----------------------------------------------------------------------

      std::string core_armcortexa9_funclt::STREXD::get_name() const throw() {

        return "STREXD";
      } // get_name()

      // -----------------------------------------------------------------------

      std::string core_armcortexa9_funclt::STREXD::get_mnemonic() const throw()
      {

        std::ostringstream oss (std::ostringstream::out);
        oss << "STREXD";
        oss << std::showbase << std::hex << this->cond;
        oss << " R";
        oss << std::dec << this->rd_bit;
        oss << ", R";
        oss << std::dec << this->rm_bit;
        oss << ", [R";
        oss << std::dec << this->rn_bit;
        oss << "]";
        return oss.str();
      } // get_mnemonic()

      // -----------------------------------------------------------------------

      void core_armcortexa9_funclt::STREXD::set_params(const unsigned& bitstring)
      throw() {

        this->rd_bit = (bitstring & 0xf000) >> 12;
        this->rd.set_alias(REGS[this->rd_bit]);
        this->rm_bit = (bitstring & 0xf);
        this->rm.set_alias(REGS[this->rm_bit]);
        this->rn_bit = (bitstring & 0xf0000) >> 16;
        this->rn.set_alias(REGS[this->rn_bit]);
        this->rs_bit = (bitstring & 0xf00) >> 8;
        this->rs.set_alias(REGS[this->rs_bit]);
        this->cond = (bitstring & 0xf0000000) >> 28;
      } // set_params()

      // -----------------------------------------------------------------------

      Instruction* core_armcortexa9_funclt::STREXD::replicate(Instruction*
      instr) const throw() {

        STREXD* new_instr = new STREXD(R, instr_memory, data_memory);

        // Set instruction fields.
        if (instr) {
          STREXD* old_instr = dynamic_cast<STREXD*>(instr);
          if (old_instr) {
            new_instr->rd_bit = old_instr->rd_bit;
            new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
            new_instr->rm_bit = old_instr->rm_bit;
            new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
            new_instr->rn_bit = old_instr->rn_bit;
            new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
            new_instr->rs_bit = old_instr->rs_bit;
            new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
            new_instr->cond = old_instr->cond;
          }
        }
        return new_instr;
      } // replicate()

      // -----------------------------------------------------------------------

      unsigned core_armcortexa9_funclt::STREXD::behavior() {

        this->num_instr_cycles = 0;
        this->num_instr_cycles += ConditionPassed(this->cond);

        if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 14))
        THROW_EXCEPTION("Invalid STREXD encoding: rn|rd = 0xF or rm = 0xE.");

        if (rm_bit & 0x1)
        THROW_EXCEPTION("Invalid STREXD encoding: rm[0] = 1.");

        if ((rn_bit == rd_bit) || (rd_bit == rm_bit) || (rd_bit == rm_bit+1))
        THROW_EXCEPTION("Invalid STREXD encoding: rn|rm|rm+1 = rd.");

        if (rs_bit != 15)
        THROW_WARNING("Invalid STREXD encoding: rs != 0xF.");

#ifdef ACC_MODEL
        REGS[rd_bit+1].is_locked(this, 3 /* in decode */, 3 /* read in execute,
        3 cycles ahead */);
#endif

        // TODO: if (ExclusiveMonitorsPass(rn, 8)) {
          if (CPSR[CPSR_E] /* TODO: BigEndian() */) {
            data_memory.write_word(rn, REGS[rd_bit+1]);
            data_memory.write_word(rn+4, rd);
          } else {
            data_memory.write_word(rn, rd);
            data_memory.write_word(rn+4, REGS[rd_bit+1]);
          }
          //} else rd = 1;
          stall(1);
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::LDM::LDM(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory),
          LSMReglistOp(R, instr_memory, data_memory) {


        } // LDM()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::LDM::get_id() const throw() {

          return 106;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::LDM::get_name() const throw() {

          return "LDM";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::LDM::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "LDM";
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rn_bit;
          switch(this->w) {
            case 1: {
              oss << "!";
            break;}
          }
          oss << ", {";
          oss << std::showbase << std::hex << this->reg_list;
          oss << "}";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::LDM::set_params(const unsigned& bitstring)
        throw() {

          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->p = (bitstring & 0x1000000) >> 24;
          this->u = (bitstring & 0x800000) >> 23;
          this->s = (bitstring & 0x400000) >> 22;
          this->w = (bitstring & 0x200000) >> 21;
          this->reg_list = (bitstring & 0xffff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::LDM::replicate(Instruction* instr)
        const throw() {

          LDM* new_instr = new LDM(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            LDM* old_instr = dynamic_cast<LDM*>(instr);
            if (old_instr) {
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->p = old_instr->p;
              new_instr->u = old_instr->u;
              new_instr->s = old_instr->s;
              new_instr->w = old_instr->w;
              new_instr->reg_list = old_instr->reg_list;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::LDM::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          unsigned mode = (s? ((reg_list & 0x8000)? 2 /* exception return */
          : 1 /* user registers */)
          : 0 /* user mode */);

          //if (!mode && w && (rn_bit == 13) && (BitCount(reg_list) > 1))
          // POP is caught by the decoder as a subinstruction and never redirects
          // here.

          if (rn_bit == 15)
          THROW_EXCEPTION("Invalid LDM encoding: rn = 0xF.");

          if ((!mode || (mode == 1)) && !reg_list)
          THROW_EXCEPTION("Invalid LDM encoding: reg_list = 0x0.");

          if (w && (reg_list & (0x1 << rn_bit)))
          THROW_EXCEPTION("Invalid LDM encoding: w = 1 and reg_list[rn] = 1.");

          if ((mode == 1) && w)
          THROW_WARNING("Invalid LDM (user registers) encoding: w != 0.");

#ifdef ACC_MODEL
          for (int i = 0; i < 16; i++) {
            if ((reg_list & (0x00000001 << i)) != 0) {
              REGS[i].lock(this, 3 /* in decode */, 3 /* write in execute, 3
              cycles ahead */);
            }
          }
#endif
          this->num_instr_cycles += LSMReglist(this->rn, this->rn_bit, this->p,
          this->u, this->reg_list, this->start_address, this->wb_address);

          unsigned num_regs_to_load = 0;
          unsigned load_latency = 0;

          if (!s || (reg_list & 0x00008000)) {
            // LDMxx or LDMxx (exception return)
            // Load memory in register i.
            for (int i = 0; i < 15; i++) {
              if ((reg_list & (0x00000001 << i)) != 0) {
                REGS[i] = data_memory.read_word(start_address);
                start_address += 4;
                num_regs_to_load++;
              }
            }
            load_latency = num_regs_to_load + 1;

            // Load memory in PC.
            // If the PC is among reg_list, this is like performing a branch.
            if (reg_list & 0x00008000) {
              if (s) {
                // LDMxx (exception return)
                unsigned value = 0, mode = CPSR[CPSR_M], mask = 0;
                int spsr_idx = get_spsr_idx(mode);
                if (spsr_idx >= 0) {
                  value = SPSR[spsr_idx];
                  mask = psr_mask(value, 0xF, mode, false, true);
                  // If the mode is going to change, update the aliases.
                  if ((mask & 0x1F) && (mode != (value & 0x1F))) {
                    update_alias(mode, value & 0x1F);
                  }
                  if (mask) {
                    CPSR = (CPSR & ~mask) | (value & mask);
                  }
                }
              }
              if (!(s && (CPSR[CPSR_M] == 0x1A) && CPSR[CPSR_J] && CPSR[CPSR_T]))
              BranchWritePC(data_memory.read_word(start_address));
              num_regs_to_load++;
              load_latency += 2;
              flush();
            }

            // Optionally write back to base register.
            if (w && !(reg_list & (0x00000001 << rn_bit))) {
              // The writeback address is written back to the base register.
              rn = wb_address;
            }
          } else {
            // LDMxx (user registers)
            for (int i = 0; i < 15; i++) {
              if ((reg_list & (0x00000001 << i)) != 0) {
                // Load user mode registers.
                REGS[i] = data_memory.read_word(start_address);
                start_address += 4;
                num_regs_to_load++;
              }
            }
            load_latency = num_regs_to_load + 1;
          }
          stall(load_latency);
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::LDMIB::LDMIB(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory),
          LSMReglistOp(R, instr_memory, data_memory) {


        } // LDMIB()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::LDMIB::get_id() const throw() {

          return 107;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::LDMIB::get_name() const throw() {

          return "LDMIB";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::LDMIB::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "LDMIB";
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rn_bit;
          switch(this->w) {
            case 1: {
              oss << "!";
            break;}
          }
          oss << ", {";
          oss << std::showbase << std::hex << this->reg_list;
          oss << "}";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::LDMIB::set_params(const unsigned& bitstring)
        throw() {

          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->p = (bitstring & 0x1000000) >> 24;
          this->u = (bitstring & 0x800000) >> 23;
          this->s = (bitstring & 0x400000) >> 22;
          this->w = (bitstring & 0x200000) >> 21;
          this->reg_list = (bitstring & 0xffff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::LDMIB::replicate(Instruction*
        instr) const throw() {

          LDMIB* new_instr = new LDMIB(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            LDMIB* old_instr = dynamic_cast<LDMIB*>(instr);
            if (old_instr) {
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->p = old_instr->p;
              new_instr->u = old_instr->u;
              new_instr->s = old_instr->s;
              new_instr->w = old_instr->w;
              new_instr->reg_list = old_instr->reg_list;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::LDMIB::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          unsigned mode = (s? ((reg_list & 0x8000)? 2 /* exception return */
          : 1 /* user registers */)
          : 0 /* user mode */);

          //if (!mode && w && (rn_bit == 13) && (BitCount(reg_list) > 1))
          // POP is caught by the decoder as a subinstruction and never redirects
          // here.

          if (rn_bit == 15)
          THROW_EXCEPTION("Invalid LDM encoding: rn = 0xF.");

          if ((!mode || (mode == 1)) && !reg_list)
          THROW_EXCEPTION("Invalid LDM encoding: reg_list = 0x0.");

          if (w && (reg_list & (0x1 << rn_bit)))
          THROW_EXCEPTION("Invalid LDM encoding: w = 1 and reg_list[rn] = 1.");

          if ((mode == 1) && w)
          THROW_WARNING("Invalid LDM (user registers) encoding: w != 0.");

#ifdef ACC_MODEL
          for (int i = 0; i < 16; i++) {
            if ((reg_list & (0x00000001 << i)) != 0) {
              REGS[i].lock(this, 3 /* in decode */, 3 /* write in execute, 3
              cycles ahead */);
            }
          }
#endif
          this->num_instr_cycles += LSMReglist(this->rn, this->rn_bit, this->p,
          this->u, this->reg_list, this->start_address, this->wb_address);

          unsigned num_regs_to_load = 0;
          unsigned load_latency = 0;

          if (!s || (reg_list & 0x00008000)) {
            // LDMxx or LDMxx (exception return)
            // Load memory in register i.
            for (int i = 0; i < 15; i++) {
              if ((reg_list & (0x00000001 << i)) != 0) {
                REGS[i] = data_memory.read_word(start_address);
                start_address += 4;
                num_regs_to_load++;
              }
            }
            load_latency = num_regs_to_load + 1;

            // Load memory in PC.
            // If the PC is among reg_list, this is like performing a branch.
            if (reg_list & 0x00008000) {
              if (s) {
                // LDMxx (exception return)
                unsigned value = 0, mode = CPSR[CPSR_M], mask = 0;
                int spsr_idx = get_spsr_idx(mode);
                if (spsr_idx >= 0) {
                  value = SPSR[spsr_idx];
                  mask = psr_mask(value, 0xF, mode, false, true);
                  // If the mode is going to change, update the aliases.
                  if ((mask & 0x1F) && (mode != (value & 0x1F))) {
                    update_alias(mode, value & 0x1F);
                  }
                  if (mask) {
                    CPSR = (CPSR & ~mask) | (value & mask);
                  }
                }
              }
              if (!(s && (CPSR[CPSR_M] == 0x1A) && CPSR[CPSR_J] && CPSR[CPSR_T]))
              BranchWritePC(data_memory.read_word(start_address));
              num_regs_to_load++;
              load_latency += 2;
              flush();
            }

            // Optionally write back to base register.
            if (w && !(reg_list & (0x00000001 << rn_bit))) {
              // The writeback address is written back to the base register.
              rn = wb_address;
            }
          } else {
            // LDMxx (user registers)
            for (int i = 0; i < 15; i++) {
              if ((reg_list & (0x00000001 << i)) != 0) {
                // Load user mode registers.
                REGS[i] = data_memory.read_word(start_address);
                start_address += 4;
                num_regs_to_load++;
              }
            }
            load_latency = num_regs_to_load + 1;
          }
          stall(load_latency);
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::LDMDA::LDMDA(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory),
          LSMReglistOp(R, instr_memory, data_memory) {


        } // LDMDA()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::LDMDA::get_id() const throw() {

          return 108;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::LDMDA::get_name() const throw() {

          return "LDMDA";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::LDMDA::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "LDMDA";
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rn_bit;
          switch(this->w) {
            case 1: {
              oss << "!";
            break;}
          }
          oss << ", {";
          oss << std::showbase << std::hex << this->reg_list;
          oss << "}";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::LDMDA::set_params(const unsigned& bitstring)
        throw() {

          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->p = (bitstring & 0x1000000) >> 24;
          this->u = (bitstring & 0x800000) >> 23;
          this->s = (bitstring & 0x400000) >> 22;
          this->w = (bitstring & 0x200000) >> 21;
          this->reg_list = (bitstring & 0xffff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::LDMDA::replicate(Instruction*
        instr) const throw() {

          LDMDA* new_instr = new LDMDA(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            LDMDA* old_instr = dynamic_cast<LDMDA*>(instr);
            if (old_instr) {
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->p = old_instr->p;
              new_instr->u = old_instr->u;
              new_instr->s = old_instr->s;
              new_instr->w = old_instr->w;
              new_instr->reg_list = old_instr->reg_list;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::LDMDA::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          unsigned mode = (s? ((reg_list & 0x8000)? 2 /* exception return */
          : 1 /* user registers */)
          : 0 /* user mode */);

          //if (!mode && w && (rn_bit == 13) && (BitCount(reg_list) > 1))
          // POP is caught by the decoder as a subinstruction and never redirects
          // here.

          if (rn_bit == 15)
          THROW_EXCEPTION("Invalid LDM encoding: rn = 0xF.");

          if ((!mode || (mode == 1)) && !reg_list)
          THROW_EXCEPTION("Invalid LDM encoding: reg_list = 0x0.");

          if (w && (reg_list & (0x1 << rn_bit)))
          THROW_EXCEPTION("Invalid LDM encoding: w = 1 and reg_list[rn] = 1.");

          if ((mode == 1) && w)
          THROW_WARNING("Invalid LDM (user registers) encoding: w != 0.");

#ifdef ACC_MODEL
          for (int i = 0; i < 16; i++) {
            if ((reg_list & (0x00000001 << i)) != 0) {
              REGS[i].lock(this, 3 /* in decode */, 3 /* write in execute, 3
              cycles ahead */);
            }
          }
#endif
          this->num_instr_cycles += LSMReglist(this->rn, this->rn_bit, this->p,
          this->u, this->reg_list, this->start_address, this->wb_address);

          unsigned num_regs_to_load = 0;
          unsigned load_latency = 0;

          if (!s || (reg_list & 0x00008000)) {
            // LDMxx or LDMxx (exception return)
            // Load memory in register i.
            for (int i = 0; i < 15; i++) {
              if ((reg_list & (0x00000001 << i)) != 0) {
                REGS[i] = data_memory.read_word(start_address);
                start_address += 4;
                num_regs_to_load++;
              }
            }
            load_latency = num_regs_to_load + 1;

            // Load memory in PC.
            // If the PC is among reg_list, this is like performing a branch.
            if (reg_list & 0x00008000) {
              if (s) {
                // LDMxx (exception return)
                unsigned value = 0, mode = CPSR[CPSR_M], mask = 0;
                int spsr_idx = get_spsr_idx(mode);
                if (spsr_idx >= 0) {
                  value = SPSR[spsr_idx];
                  mask = psr_mask(value, 0xF, mode, false, true);
                  // If the mode is going to change, update the aliases.
                  if ((mask & 0x1F) && (mode != (value & 0x1F))) {
                    update_alias(mode, value & 0x1F);
                  }
                  if (mask) {
                    CPSR = (CPSR & ~mask) | (value & mask);
                  }
                }
              }
              if (!(s && (CPSR[CPSR_M] == 0x1A) && CPSR[CPSR_J] && CPSR[CPSR_T]))
              BranchWritePC(data_memory.read_word(start_address));
              num_regs_to_load++;
              load_latency += 2;
              flush();
            }

            // Optionally write back to base register.
            if (w && !(reg_list & (0x00000001 << rn_bit))) {
              // The writeback address is written back to the base register.
              rn = wb_address;
            }
          } else {
            // LDMxx (user registers)
            for (int i = 0; i < 15; i++) {
              if ((reg_list & (0x00000001 << i)) != 0) {
                // Load user mode registers.
                REGS[i] = data_memory.read_word(start_address);
                start_address += 4;
                num_regs_to_load++;
              }
            }
            load_latency = num_regs_to_load + 1;
          }
          stall(load_latency);
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::LDMDB::LDMDB(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory),
          LSMReglistOp(R, instr_memory, data_memory) {


        } // LDMDB()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::LDMDB::get_id() const throw() {

          return 109;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::LDMDB::get_name() const throw() {

          return "LDMDB";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::LDMDB::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "LDMDB";
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rn_bit;
          switch(this->w) {
            case 1: {
              oss << "!";
            break;}
          }
          oss << ", {";
          oss << std::showbase << std::hex << this->reg_list;
          oss << "}";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::LDMDB::set_params(const unsigned& bitstring)
        throw() {

          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->p = (bitstring & 0x1000000) >> 24;
          this->u = (bitstring & 0x800000) >> 23;
          this->s = (bitstring & 0x400000) >> 22;
          this->w = (bitstring & 0x200000) >> 21;
          this->reg_list = (bitstring & 0xffff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::LDMDB::replicate(Instruction*
        instr) const throw() {

          LDMDB* new_instr = new LDMDB(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            LDMDB* old_instr = dynamic_cast<LDMDB*>(instr);
            if (old_instr) {
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->p = old_instr->p;
              new_instr->u = old_instr->u;
              new_instr->s = old_instr->s;
              new_instr->w = old_instr->w;
              new_instr->reg_list = old_instr->reg_list;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::LDMDB::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          unsigned mode = (s? ((reg_list & 0x8000)? 2 /* exception return */
          : 1 /* user registers */)
          : 0 /* user mode */);

          //if (!mode && w && (rn_bit == 13) && (BitCount(reg_list) > 1))
          // POP is caught by the decoder as a subinstruction and never redirects
          // here.

          if (rn_bit == 15)
          THROW_EXCEPTION("Invalid LDM encoding: rn = 0xF.");

          if ((!mode || (mode == 1)) && !reg_list)
          THROW_EXCEPTION("Invalid LDM encoding: reg_list = 0x0.");

          if (w && (reg_list & (0x1 << rn_bit)))
          THROW_EXCEPTION("Invalid LDM encoding: w = 1 and reg_list[rn] = 1.");

          if ((mode == 1) && w)
          THROW_WARNING("Invalid LDM (user registers) encoding: w != 0.");

#ifdef ACC_MODEL
          for (int i = 0; i < 16; i++) {
            if ((reg_list & (0x00000001 << i)) != 0) {
              REGS[i].lock(this, 3 /* in decode */, 3 /* write in execute, 3
              cycles ahead */);
            }
          }
#endif
          this->num_instr_cycles += LSMReglist(this->rn, this->rn_bit, this->p,
          this->u, this->reg_list, this->start_address, this->wb_address);

          unsigned num_regs_to_load = 0;
          unsigned load_latency = 0;

          if (!s || (reg_list & 0x00008000)) {
            // LDMxx or LDMxx (exception return)
            // Load memory in register i.
            for (int i = 0; i < 15; i++) {
              if ((reg_list & (0x00000001 << i)) != 0) {
                REGS[i] = data_memory.read_word(start_address);
                start_address += 4;
                num_regs_to_load++;
              }
            }
            load_latency = num_regs_to_load + 1;

            // Load memory in PC.
            // If the PC is among reg_list, this is like performing a branch.
            if (reg_list & 0x00008000) {
              if (s) {
                // LDMxx (exception return)
                unsigned value = 0, mode = CPSR[CPSR_M], mask = 0;
                int spsr_idx = get_spsr_idx(mode);
                if (spsr_idx >= 0) {
                  value = SPSR[spsr_idx];
                  mask = psr_mask(value, 0xF, mode, false, true);
                  // If the mode is going to change, update the aliases.
                  if ((mask & 0x1F) && (mode != (value & 0x1F))) {
                    update_alias(mode, value & 0x1F);
                  }
                  if (mask) {
                    CPSR = (CPSR & ~mask) | (value & mask);
                  }
                }
              }
              if (!(s && (CPSR[CPSR_M] == 0x1A) && CPSR[CPSR_J] && CPSR[CPSR_T]))
              BranchWritePC(data_memory.read_word(start_address));
              num_regs_to_load++;
              load_latency += 2;
              flush();
            }

            // Optionally write back to base register.
            if (w && !(reg_list & (0x00000001 << rn_bit))) {
              // The writeback address is written back to the base register.
              rn = wb_address;
            }
          } else {
            // LDMxx (user registers)
            for (int i = 0; i < 15; i++) {
              if ((reg_list & (0x00000001 << i)) != 0) {
                // Load user mode registers.
                REGS[i] = data_memory.read_word(start_address);
                start_address += 4;
                num_regs_to_load++;
              }
            }
            load_latency = num_regs_to_load + 1;
          }
          stall(load_latency);
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::POP_single::POP_single(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // POP_single()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::POP_single::get_id() const throw() {

          return 110;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::POP_single::get_name() const
        throw() {

          return "POP_single";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::POP_single::get_mnemonic() const
        throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "POP";
          oss << std::showbase << std::hex << this->cond;
          oss << " {";
          oss << std::showbase << std::hex << this->imm0;
          oss << "}";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::POP_single::set_params(const unsigned&
        bitstring) throw() {

          this->cond = (bitstring & 0xf0000000) >> 28;
          this->imm0 = (bitstring & 0xf000) >> 12;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::POP_single::replicate(Instruction*
        instr) const throw() {

          POP_single* new_instr = new POP_single(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            POP_single* old_instr = dynamic_cast<POP_single*>(instr);
            if (old_instr) {
              new_instr->cond = old_instr->cond;
              new_instr->imm0 = old_instr->imm0;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::POP_single::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if (imm0 == 13)
          THROW_EXCEPTION("Invalid POP (single) encoding: rd = 0xD.");

#ifdef ACC_MODEL
          REGS[imm0].lock(this, 3 /* in decode */, 3 /* write in execute, 3
          cycles ahead */);
#endif
          reg_list = (0x1 << imm0);

          unsigned start_address = SP;
          unsigned num_regs_to_load = 0;
          unsigned load_latency = 0;

          for (int i = 0; i < 15; i++) {
            if ((reg_list & (0x00000001 << i)) != 0) {
              // Load user mode registers.
              REGS[i] = data_memory.read_word(start_address);
              start_address += 4;
              num_regs_to_load++;
            }
          }

          // Load memory in PC.
          // If the PC is among reg_list, this is like performing a branch.
          if (reg_list & 0x00008000) {
            BranchWritePC(data_memory.read_word(start_address));
            num_regs_to_load++;
            load_latency += 2;
            flush();
          }

          // Update SP.
          SP += 4 * num_regs_to_load;

          load_latency = num_regs_to_load + 1;
          stall(load_latency);
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::POP_block::POP_block(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // POP_block()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::POP_block::get_id() const throw() {

          return 111;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::POP_block::get_name() const throw()
        {

          return "POP_block";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::POP_block::get_mnemonic() const
        throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "POP";
          oss << std::showbase << std::hex << this->cond;
          oss << " {";
          oss << std::showbase << std::hex << (((this->imm0 << 12) & (unsigned)0xF000)
          | (this->imm1 & ((unsigned)0xFFF)));
          oss << "}";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::POP_block::set_params(const unsigned&
        bitstring) throw() {

          this->cond = (bitstring & 0xf0000000) >> 28;
          this->imm0 = (bitstring & 0xf000) >> 12;
          this->imm1 = (bitstring & 0xfff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::POP_block::replicate(Instruction*
        instr) const throw() {

          POP_block* new_instr = new POP_block(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            POP_block* old_instr = dynamic_cast<POP_block*>(instr);
            if (old_instr) {
              new_instr->cond = old_instr->cond;
              new_instr->imm0 = old_instr->imm0;
              new_instr->imm1 = old_instr->imm1;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::POP_block::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          reg_list = (imm0 << 12) | imm1;

          if (reg_list & (0x1 << 13))
          THROW_EXCEPTION("Invalid POP (block) encoding: reg_list[13] = 1.");

#ifdef ACC_MODEL
          for (int i = 0; i < 16; i++) {
            if ((reg_list & (0x00000001 << i)) != 0) {
              REGS[i].lock(this, 3 /* in decode */, 3 /* write in execute, 3
              cycles ahead */);
            }
          }
#endif

          unsigned start_address = SP;
          unsigned num_regs_to_load = 0;
          unsigned load_latency = 0;

          for (int i = 0; i < 15; i++) {
            if ((reg_list & (0x00000001 << i)) != 0) {
              // Load user mode registers.
              REGS[i] = data_memory.read_word(start_address);
              start_address += 4;
              num_regs_to_load++;
            }
          }

          // Load memory in PC.
          // If the PC is among reg_list, this is like performing a branch.
          if (reg_list & 0x00008000) {
            BranchWritePC(data_memory.read_word(start_address));
            num_regs_to_load++;
            load_latency += 2;
            flush();
          }

          // Update SP.
          SP += 4 * num_regs_to_load;

          load_latency = num_regs_to_load + 1;
          stall(load_latency);
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::STM::STM(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory),
          LSMReglistOp(R, instr_memory, data_memory) {


        } // STM()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::STM::get_id() const throw() {

          return 112;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::STM::get_name() const throw() {

          return "STM";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::STM::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "STM";
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rn_bit;
          switch(this->w) {
            case 1: {
              oss << "!";
            break;}
          }
          oss << ", {";
          oss << std::showbase << std::hex << this->reg_list;
          oss << "}";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::STM::set_params(const unsigned& bitstring)
        throw() {

          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->p = (bitstring & 0x1000000) >> 24;
          this->u = (bitstring & 0x800000) >> 23;
          this->s = (bitstring & 0x400000) >> 22;
          this->w = (bitstring & 0x200000) >> 21;
          this->reg_list = (bitstring & 0xffff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::STM::replicate(Instruction* instr)
        const throw() {

          STM* new_instr = new STM(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            STM* old_instr = dynamic_cast<STM*>(instr);
            if (old_instr) {
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->p = old_instr->p;
              new_instr->u = old_instr->u;
              new_instr->s = old_instr->s;
              new_instr->w = old_instr->w;
              new_instr->reg_list = old_instr->reg_list;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::STM::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          //if (!s && w && (rn_bit == 13) && (BitCount(reg_list) > 1))
          // PUSH is caught by the decoder as a subinstruction and never redirects
          // here.

          if (rn_bit == 15)
          THROW_EXCEPTION("Invalid STM encoding: rn = 0xF.");

          if (!reg_list)
          THROW_EXCEPTION("Invalid STM encoding: reg_list = 0x0.");

          if (s && w)
          THROW_WARNING("Invalid STM (user registers) encoding: w != 0.");

#ifdef ACC_MODEL
          for (int i = 0; i < 16; i++) {
            if ((reg_list & (0x00000001 << i)) != 0) {
              REGS[i].is_locked(3 /* in decode */, 3 /* read in execute, 3
              cycles ahead */);
            }
          }
#endif
          this->num_instr_cycles += LSMReglist(this->rn, this->rn_bit, this->p,
          this->u, this->reg_list, this->start_address, this->wb_address);

          unsigned num_regs_to_store = 0;
          start_address &= 0xFFFFFFFC;

          if (!s) {
            // STMxx common registers
            for (int i = 0; i < 16; i++) {
              if ((reg_list & (0x00000001 << i)) != 0) {
                data_memory.write_word(start_address, REGS[i]);
                start_address += 4;
                num_regs_to_store++;
              }
            }
            // Update base register if necessary.
            // NOTE: Using the writeback strategy and putting the base register
            // in the list of registers to be saved is defined by the ARM as an
            // undefined operation, unless it is first in the register list.
            // This implies that the write back happens in parallel to the
            // storing of the first register.
            if (w)
            rn = wb_address;
          } else {
            // STMxx (user registers)
            for (int i = 0; i < 16; i++) {
              if ((reg_list & (0x00000001 << i)) != 0) {
                // Store user mode registers.
                data_memory.write_word(start_address, REGS[i]);
                start_address += 4;
                num_regs_to_store++;
              }
            }
          }
          stall(num_regs_to_store);
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::STMIB::STMIB(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory),
          LSMReglistOp(R, instr_memory, data_memory) {


        } // STMIB()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::STMIB::get_id() const throw() {

          return 113;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::STMIB::get_name() const throw() {

          return "STMIB";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::STMIB::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "STMIB";
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rn_bit;
          switch(this->w) {
            case 1: {
              oss << "!";
            break;}
          }
          oss << ", {";
          oss << std::showbase << std::hex << this->reg_list;
          oss << "}";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::STMIB::set_params(const unsigned& bitstring)
        throw() {

          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->p = (bitstring & 0x1000000) >> 24;
          this->u = (bitstring & 0x800000) >> 23;
          this->s = (bitstring & 0x400000) >> 22;
          this->w = (bitstring & 0x200000) >> 21;
          this->reg_list = (bitstring & 0xffff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::STMIB::replicate(Instruction*
        instr) const throw() {

          STMIB* new_instr = new STMIB(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            STMIB* old_instr = dynamic_cast<STMIB*>(instr);
            if (old_instr) {
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->p = old_instr->p;
              new_instr->u = old_instr->u;
              new_instr->s = old_instr->s;
              new_instr->w = old_instr->w;
              new_instr->reg_list = old_instr->reg_list;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::STMIB::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          //if (!s && w && (rn_bit == 13) && (BitCount(reg_list) > 1))
          // PUSH is caught by the decoder as a subinstruction and never redirects
          // here.

          if (rn_bit == 15)
          THROW_EXCEPTION("Invalid STM encoding: rn = 0xF.");

          if (!reg_list)
          THROW_EXCEPTION("Invalid STM encoding: reg_list = 0x0.");

          if (s && w)
          THROW_WARNING("Invalid STM (user registers) encoding: w != 0.");

#ifdef ACC_MODEL
          for (int i = 0; i < 16; i++) {
            if ((reg_list & (0x00000001 << i)) != 0) {
              REGS[i].is_locked(3 /* in decode */, 3 /* read in execute, 3
              cycles ahead */);
            }
          }
#endif
          this->num_instr_cycles += LSMReglist(this->rn, this->rn_bit, this->p,
          this->u, this->reg_list, this->start_address, this->wb_address);

          unsigned num_regs_to_store = 0;
          start_address &= 0xFFFFFFFC;

          if (!s) {
            // STMxx common registers
            for (int i = 0; i < 16; i++) {
              if ((reg_list & (0x00000001 << i)) != 0) {
                data_memory.write_word(start_address, REGS[i]);
                start_address += 4;
                num_regs_to_store++;
              }
            }
            // Update base register if necessary.
            // NOTE: Using the writeback strategy and putting the base register
            // in the list of registers to be saved is defined by the ARM as an
            // undefined operation, unless it is first in the register list.
            // This implies that the write back happens in parallel to the
            // storing of the first register.
            if (w)
            rn = wb_address;
          } else {
            // STMxx (user registers)
            for (int i = 0; i < 16; i++) {
              if ((reg_list & (0x00000001 << i)) != 0) {
                // Store user mode registers.
                data_memory.write_word(start_address, REGS[i]);
                start_address += 4;
                num_regs_to_store++;
              }
            }
          }
          stall(num_regs_to_store);
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::STMDA::STMDA(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory),
          LSMReglistOp(R, instr_memory, data_memory) {


        } // STMDA()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::STMDA::get_id() const throw() {

          return 114;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::STMDA::get_name() const throw() {

          return "STMDA";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::STMDA::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "STMDA";
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rn_bit;
          switch(this->w) {
            case 1: {
              oss << "!";
            break;}
          }
          oss << ", {";
          oss << std::showbase << std::hex << this->reg_list;
          oss << "}";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::STMDA::set_params(const unsigned& bitstring)
        throw() {

          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->p = (bitstring & 0x1000000) >> 24;
          this->u = (bitstring & 0x800000) >> 23;
          this->s = (bitstring & 0x400000) >> 22;
          this->w = (bitstring & 0x200000) >> 21;
          this->reg_list = (bitstring & 0xffff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::STMDA::replicate(Instruction*
        instr) const throw() {

          STMDA* new_instr = new STMDA(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            STMDA* old_instr = dynamic_cast<STMDA*>(instr);
            if (old_instr) {
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->p = old_instr->p;
              new_instr->u = old_instr->u;
              new_instr->s = old_instr->s;
              new_instr->w = old_instr->w;
              new_instr->reg_list = old_instr->reg_list;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::STMDA::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          //if (!s && w && (rn_bit == 13) && (BitCount(reg_list) > 1))
          // PUSH is caught by the decoder as a subinstruction and never redirects
          // here.

          if (rn_bit == 15)
          THROW_EXCEPTION("Invalid STM encoding: rn = 0xF.");

          if (!reg_list)
          THROW_EXCEPTION("Invalid STM encoding: reg_list = 0x0.");

          if (s && w)
          THROW_WARNING("Invalid STM (user registers) encoding: w != 0.");

#ifdef ACC_MODEL
          for (int i = 0; i < 16; i++) {
            if ((reg_list & (0x00000001 << i)) != 0) {
              REGS[i].is_locked(3 /* in decode */, 3 /* read in execute, 3
              cycles ahead */);
            }
          }
#endif
          this->num_instr_cycles += LSMReglist(this->rn, this->rn_bit, this->p,
          this->u, this->reg_list, this->start_address, this->wb_address);

          unsigned num_regs_to_store = 0;
          start_address &= 0xFFFFFFFC;

          if (!s) {
            // STMxx common registers
            for (int i = 0; i < 16; i++) {
              if ((reg_list & (0x00000001 << i)) != 0) {
                data_memory.write_word(start_address, REGS[i]);
                start_address += 4;
                num_regs_to_store++;
              }
            }
            // Update base register if necessary.
            // NOTE: Using the writeback strategy and putting the base register
            // in the list of registers to be saved is defined by the ARM as an
            // undefined operation, unless it is first in the register list.
            // This implies that the write back happens in parallel to the
            // storing of the first register.
            if (w)
            rn = wb_address;
          } else {
            // STMxx (user registers)
            for (int i = 0; i < 16; i++) {
              if ((reg_list & (0x00000001 << i)) != 0) {
                // Store user mode registers.
                data_memory.write_word(start_address, REGS[i]);
                start_address += 4;
                num_regs_to_store++;
              }
            }
          }
          stall(num_regs_to_store);
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::STMDB::STMDB(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory),
          LSMReglistOp(R, instr_memory, data_memory) {


        } // STMDB()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::STMDB::get_id() const throw() {

          return 115;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::STMDB::get_name() const throw() {

          return "STMDB";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::STMDB::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "STMDB";
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rn_bit;
          switch(this->w) {
            case 1: {
              oss << "!";
            break;}
          }
          oss << ", {";
          oss << std::showbase << std::hex << this->reg_list;
          oss << "}";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::STMDB::set_params(const unsigned& bitstring)
        throw() {

          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->p = (bitstring & 0x1000000) >> 24;
          this->u = (bitstring & 0x800000) >> 23;
          this->s = (bitstring & 0x400000) >> 22;
          this->w = (bitstring & 0x200000) >> 21;
          this->reg_list = (bitstring & 0xffff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::STMDB::replicate(Instruction*
        instr) const throw() {

          STMDB* new_instr = new STMDB(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            STMDB* old_instr = dynamic_cast<STMDB*>(instr);
            if (old_instr) {
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->p = old_instr->p;
              new_instr->u = old_instr->u;
              new_instr->s = old_instr->s;
              new_instr->w = old_instr->w;
              new_instr->reg_list = old_instr->reg_list;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::STMDB::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          //if (!s && w && (rn_bit == 13) && (BitCount(reg_list) > 1))
          // PUSH is caught by the decoder as a subinstruction and never redirects
          // here.

          if (rn_bit == 15)
          THROW_EXCEPTION("Invalid STM encoding: rn = 0xF.");

          if (!reg_list)
          THROW_EXCEPTION("Invalid STM encoding: reg_list = 0x0.");

          if (s && w)
          THROW_WARNING("Invalid STM (user registers) encoding: w != 0.");

#ifdef ACC_MODEL
          for (int i = 0; i < 16; i++) {
            if ((reg_list & (0x00000001 << i)) != 0) {
              REGS[i].is_locked(3 /* in decode */, 3 /* read in execute, 3
              cycles ahead */);
            }
          }
#endif
          this->num_instr_cycles += LSMReglist(this->rn, this->rn_bit, this->p,
          this->u, this->reg_list, this->start_address, this->wb_address);

          unsigned num_regs_to_store = 0;
          start_address &= 0xFFFFFFFC;

          if (!s) {
            // STMxx common registers
            for (int i = 0; i < 16; i++) {
              if ((reg_list & (0x00000001 << i)) != 0) {
                data_memory.write_word(start_address, REGS[i]);
                start_address += 4;
                num_regs_to_store++;
              }
            }
            // Update base register if necessary.
            // NOTE: Using the writeback strategy and putting the base register
            // in the list of registers to be saved is defined by the ARM as an
            // undefined operation, unless it is first in the register list.
            // This implies that the write back happens in parallel to the
            // storing of the first register.
            if (w)
            rn = wb_address;
          } else {
            // STMxx (user registers)
            for (int i = 0; i < 16; i++) {
              if ((reg_list & (0x00000001 << i)) != 0) {
                // Store user mode registers.
                data_memory.write_word(start_address, REGS[i]);
                start_address += 4;
                num_regs_to_store++;
              }
            }
          }
          stall(num_regs_to_store);
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::PUSH_single::PUSH_single(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // PUSH_single()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::PUSH_single::get_id() const throw() {

          return 116;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::PUSH_single::get_name() const
        throw() {

          return "PUSH_single";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::PUSH_single::get_mnemonic() const
        throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "PUSH";
          oss << std::showbase << std::hex << this->cond;
          oss << " {";
          oss << std::showbase << std::hex << this->imm0;
          oss << "}";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::PUSH_single::set_params(const unsigned&
        bitstring) throw() {

          this->cond = (bitstring & 0xf0000000) >> 28;
          this->imm0 = (bitstring & 0xf000) >> 12;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::PUSH_single::replicate(Instruction*
        instr) const throw() {

          PUSH_single* new_instr = new PUSH_single(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            PUSH_single* old_instr = dynamic_cast<PUSH_single*>(instr);
            if (old_instr) {
              new_instr->cond = old_instr->cond;
              new_instr->imm0 = old_instr->imm0;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::PUSH_single::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if (imm0 == 13)
          THROW_EXCEPTION("Invalid PUSH (single) encoding: rd = 0xD.");

#ifdef ACC_MODEL
          REGS[imm0].is_locked(3 /* in decode */, 3 /* read in execute, 3 cycles
          ahead */);
#endif
          reg_list = (0x1 << imm0);

          unsigned input = reg_list;
          unsigned num_regs_to_store = 0;
          for (; input; num_regs_to_store++) {
            // Clear least significant bit set.
            input &= input - 1;
          }
          unsigned start_address = SP - 4 * num_regs_to_store;

          for (int i = 0; i < 16; i++) {
            if ((reg_list & (0x00000001 << i)) != 0) {
              // Store user mode registers.
              data_memory.write_word(start_address, REGS[i]);
              start_address += 4;
            }
          }

          // Update SP.
          SP -= 4 * num_regs_to_store;

          stall(num_regs_to_store);
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::PUSH_block::PUSH_block(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // PUSH_block()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::PUSH_block::get_id() const throw() {

          return 117;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::PUSH_block::get_name() const
        throw() {

          return "PUSH_block";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::PUSH_block::get_mnemonic() const
        throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "PUSH";
          oss << std::showbase << std::hex << this->cond;
          oss << " {";
          oss << std::showbase << std::hex << (((this->imm0 << 12) & (unsigned)0xF000)
          | (this->imm1 & ((unsigned)0xFFF)));
          oss << "}";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::PUSH_block::set_params(const unsigned&
        bitstring) throw() {

          this->cond = (bitstring & 0xf0000000) >> 28;
          this->imm0 = (bitstring & 0xf000) >> 12;
          this->imm1 = (bitstring & 0xfff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::PUSH_block::replicate(Instruction*
        instr) const throw() {

          PUSH_block* new_instr = new PUSH_block(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            PUSH_block* old_instr = dynamic_cast<PUSH_block*>(instr);
            if (old_instr) {
              new_instr->cond = old_instr->cond;
              new_instr->imm0 = old_instr->imm0;
              new_instr->imm1 = old_instr->imm1;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::PUSH_block::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          reg_list = (imm0 << 12) | imm1;

#ifdef ACC_MODEL
          for (int i = 0; i < 16; i++) {
            if ((reg_list & (0x00000001 << i)) != 0) {
              REGS[i].is_locked(3 /* in decode */, 3 /* read in execute, 3
              cycles ahead */);
            }
          }
#endif

          unsigned input = reg_list;
          unsigned num_regs_to_store = 0;
          for (; input; num_regs_to_store++) {
            // Clear least significant bit set.
            input &= input - 1;
          }
          unsigned start_address = SP - 4 * num_regs_to_store;

          for (int i = 0; i < 16; i++) {
            if ((reg_list & (0x00000001 << i)) != 0) {
              // Store user mode registers.
              data_memory.write_word(start_address, REGS[i]);
              start_address += 4;
            }
          }

          // Update SP.
          SP -= 4 * num_regs_to_store;

          stall(num_regs_to_store);
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::MOV_i::MOV_i(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ARMExpandImmOp(R, instr_memory, data_memory),
          UpdatePSRBitOp(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // MOV_i()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MOV_i::get_id() const throw() {

          return 118;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MOV_i::get_name() const throw() {

          return "MOV_i";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MOV_i::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "MOV";
          switch(this->s) {
            case 1: {
              oss << "S";
            break;}
          }
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rd_bit;
          oss << ", ";
          oss << std::showbase << std::hex << (((this->imm >> (2 * this->rotate))
          & (((unsigned)0xFFFFFFFF) >> (2 * this->rotate))) | ((this->imm << (32
          - 2 * this->rotate)) & (((unsigned)0xFFFFFFFF) << (32 - 2 * this->rotate))));
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::MOV_i::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->s = (bitstring & 0x100000) >> 20;
          this->rotate = (bitstring & 0xf00) >> 8;
          this->imm = (bitstring & 0xff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::MOV_i::replicate(Instruction*
        instr) const throw() {

          MOV_i* new_instr = new MOV_i(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            MOV_i* old_instr = dynamic_cast<MOV_i*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->s = old_instr->s;
              new_instr->rotate = old_instr->rotate;
              new_instr->imm = old_instr->imm;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MOV_i::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if (rn_bit && !(s && rd_bit == 15))
          THROW_WARNING("Invalid MOV (immediate) encoding: rn != 0x0.");

          unsigned cur_mode = CPSR[CPSR_M];
          if (s && rd_bit == 15 &&
          ((cur_mode == (unsigned)EXECMODE::USR) || (cur_mode == (unsigned)EXECMODE::SYS)
          || (cur_mode == (unsigned)EXECMODE::HYP)))
          THROW_EXCEPTION("SUBS is not allowed in USR, SYS or HYP modes.");
          this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm,
          this->operand, this->carry);

          result = operand;
          this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
          this->result, this->carry);
          {
            unsigned num_cycles = 0;


            /// In case the program counter is the updated register the latency
            /// of the operation is incremented by two clock cycles.
            if (rd_bit == 15) {
              num_cycles += 2;
              flush();
            }
            this->num_instr_cycles += num_cycles;
          }
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::MOV_r::MOV_r(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          UpdatePSRBitOp(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // MOV_r()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MOV_r::get_id() const throw() {

          return 119;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MOV_r::get_name() const throw() {

          return "MOV_r";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MOV_r::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "MOV";
          switch(this->s) {
            case 1: {
              oss << "S";
            break;}
          }
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rd_bit;
          oss << ", R";
          oss << std::dec << this->rm_bit;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::MOV_r::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rm_bit = (bitstring & 0xf);
          this->rm.set_alias(REGS[this->rm_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->s = (bitstring & 0x100000) >> 20;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::MOV_r::replicate(Instruction*
        instr) const throw() {

          MOV_r* new_instr = new MOV_r(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            MOV_r* old_instr = dynamic_cast<MOV_r*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rm_bit = old_instr->rm_bit;
              new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->s = old_instr->s;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MOV_r::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if (rn_bit)
          THROW_WARNING("Invalid MOV (register) encoding: rn != 0x0.");

          result = rm;
          carry = CPSR[CPSR_C];
          this->num_instr_cycles += UpdatePSRBit(this->rd, this->rd_bit, this->s,
          this->result, this->carry);
          {
            unsigned num_cycles = 0;


            /// In case the program counter is the updated register the latency
            /// of the operation is incremented by two clock cycles.
            if (rd_bit == 15) {
              num_cycles += 2;
              flush();
            }
            this->num_instr_cycles += num_cycles;
          }
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::MOVW::MOVW(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // MOVW()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MOVW::get_id() const throw() {

          return 120;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MOVW::get_name() const throw() {

          return "MOVW";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MOVW::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "MOVW";
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rd_bit;
          oss << ", ";
          oss << std::showbase << std::hex << this->imm0a;
          oss << std::showbase << std::hex << this->imm0b;
          oss << std::showbase << std::hex << this->imm1a;
          oss << std::showbase << std::hex << this->b;
          oss << std::showbase << std::hex << this->imm1b;
          oss << std::showbase << std::hex << this->op1;
          oss << std::showbase << std::hex << this->imm2;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::MOVW::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->imm0a = (bitstring & 0xc0000) >> 18;
          this->imm0b = (bitstring & 0x30000) >> 16;
          this->imm1a = (bitstring & 0xc00) >> 10;
          this->b = (bitstring & 0x200) >> 9;
          this->imm1b = (bitstring & 0x100) >> 8;
          this->op1 = (bitstring & 0xf0) >> 4;
          this->imm2 = (bitstring & 0xf);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::MOVW::replicate(Instruction*
        instr) const throw() {

          MOVW* new_instr = new MOVW(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            MOVW* old_instr = dynamic_cast<MOVW*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->imm0a = old_instr->imm0a;
              new_instr->imm0b = old_instr->imm0b;
              new_instr->imm1a = old_instr->imm1a;
              new_instr->b = old_instr->b;
              new_instr->imm1b = old_instr->imm1b;
              new_instr->op1 = old_instr->op1;
              new_instr->imm2 = old_instr->imm2;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MOVW::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if (rd_bit == 15)
          THROW_EXCEPTION("Invalid MOVW encoding: rd = 0xF.");

          unsigned imm0 = (imm0a << 2) | imm0b;
          unsigned imm1 = (imm1a << 2) | (b << 1) | imm1b;
          rd = (imm0 << 12) | (imm1 << 8) | (op1 << 4) | imm2;
          {
            unsigned num_cycles = 0;


            /// In case the program counter is the updated register the latency
            /// of the operation is incremented by two clock cycles.
            if (rd_bit == 15) {
              num_cycles += 2;
              flush();
            }
            this->num_instr_cycles += num_cycles;
          }
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::MOVT::MOVT(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // MOVT()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MOVT::get_id() const throw() {

          return 121;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MOVT::get_name() const throw() {

          return "MOVT";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MOVT::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "MOVT";
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rd_bit;
          oss << ", ";
          oss << std::showbase << std::hex << this->imm0a;
          oss << std::showbase << std::hex << this->imm0b;
          oss << std::showbase << std::hex << this->imm1a;
          oss << std::showbase << std::hex << this->b;
          oss << std::showbase << std::hex << this->imm1b;
          oss << std::showbase << std::hex << this->op1;
          oss << std::showbase << std::hex << this->imm2;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::MOVT::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->imm0a = (bitstring & 0xc0000) >> 18;
          this->imm0b = (bitstring & 0x30000) >> 16;
          this->imm1a = (bitstring & 0xc00) >> 10;
          this->b = (bitstring & 0x200) >> 9;
          this->imm1b = (bitstring & 0x100) >> 8;
          this->op1 = (bitstring & 0xf0) >> 4;
          this->imm2 = (bitstring & 0xf);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::MOVT::replicate(Instruction*
        instr) const throw() {

          MOVT* new_instr = new MOVT(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            MOVT* old_instr = dynamic_cast<MOVT*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->imm0a = old_instr->imm0a;
              new_instr->imm0b = old_instr->imm0b;
              new_instr->imm1a = old_instr->imm1a;
              new_instr->b = old_instr->b;
              new_instr->imm1b = old_instr->imm1b;
              new_instr->op1 = old_instr->op1;
              new_instr->imm2 = old_instr->imm2;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MOVT::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if (rd_bit == 15)
          THROW_EXCEPTION("Invalid MOVT encoding: rd = 0xF.");

          unsigned imm0 = (imm0a << 2) | imm0b;
          unsigned imm1 = (imm1a << 2) | (b << 1) | imm1b;
          rd = (rd & 0x0000FFFF) | (imm0 << 28) | (imm1 << 24) | (op1 << 20) |
          (imm2 << 16);
          {
            unsigned num_cycles = 0;


            /// In case the program counter is the updated register the latency
            /// of the operation is incremented by two clock cycles.
            if (rd_bit == 15) {
              num_cycles += 2;
              flush();
            }
            this->num_instr_cycles += num_cycles;
          }
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::SWP::SWP(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // SWP()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::SWP::get_id() const throw() {

          return 122;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::SWP::get_name() const throw() {

          return "SWP";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::SWP::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "SWP";
          switch(this->b) {
            case 1: {
              oss << "B";
            break;}
          }
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rd_bit;
          oss << ", R";
          oss << std::dec << this->rm_bit;
          oss << ", [R";
          oss << std::dec << this->rn_bit;
          oss << "]";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::SWP::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rm_bit = (bitstring & 0xf);
          this->rm.set_alias(REGS[this->rm_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->b = (bitstring & 0x400000) >> 22;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::SWP::replicate(Instruction* instr)
        const throw() {

          SWP* new_instr = new SWP(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            SWP* old_instr = dynamic_cast<SWP*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rm_bit = old_instr->rm_bit;
              new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->b = old_instr->b;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::SWP::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if ((rn_bit == 15) || (rd_bit == 15) || (rm_bit == 15))
          THROW_EXCEPTION("Invalid SWP/SWPB encoding: rn|rd|rm = 0xF.");

          if ((rn_bit == rd_bit) || (rn_bit == rm_bit))
          THROW_EXCEPTION("Invalid SWP/SWPB encoding: rn = rd|rm.");

          if (rs_bit)
          THROW_WARNING("Invalid SWP/SWPB encoding: rs != 0x0.");

          // Needed in case rd == rm.
          unsigned temp;
          if (b) {
            temp = data_memory.read_byte(rn);
            data_memory.write_byte(rn, rm & 0x000000FF);
            rd = temp & 0x000000FF;
          }
          else {
            temp = data_memory.read_word(rn);
            if ((rn & 0x00000003) != 0x0) {
              bool carry_dummy;
              temp = ROR(temp, (rn & 0x00000003) << 3, carry_dummy);
            }
            data_memory.write_word(rn, rm);
            rd = temp;
          }
          stall(3);
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::MRS::MRS(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // MRS()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MRS::get_id() const throw() {

          return 123;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MRS::get_name() const throw() {

          return "MRS";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MRS::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "MRS";
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rd_bit;
          oss << ", ";
          switch(this->r) {
            case 0: {
              oss << "CPSR";
            break;}
            case 1: {
              oss << "SPSR";
            break;}
          }
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::MRS::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->r = (bitstring & 0x400000) >> 22;
          this->imm0a = (bitstring & 0xc0000) >> 18;
          this->imm0b = (bitstring & 0x30000) >> 16;
          this->imm1a = (bitstring & 0xc00) >> 10;
          this->b = (bitstring & 0x200) >> 9;
          this->imm1b = (bitstring & 0x100) >> 8;
          this->imm2 = (bitstring & 0xf);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::MRS::replicate(Instruction* instr)
        const throw() {

          MRS* new_instr = new MRS(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            MRS* old_instr = dynamic_cast<MRS*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->r = old_instr->r;
              new_instr->imm0a = old_instr->imm0a;
              new_instr->imm0b = old_instr->imm0b;
              new_instr->imm1a = old_instr->imm1a;
              new_instr->b = old_instr->b;
              new_instr->imm1b = old_instr->imm1b;
              new_instr->imm2 = old_instr->imm2;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MRS::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          imm0 = (imm0a << 2) | imm0b;

          if (rd_bit == 15)
          THROW_EXCEPTION("Invalid MRS (reg/banked) encoding: rd = 0xF.");

          if (!b && (imm0 != 0xF))
          THROW_WARNING("Invalid MRS (reg) encoding: imm0 != 0xF.");

          if (imm1a)
          THROW_WARNING("Invalid MRS (reg/banked) encoding: imm1[3:2] != 0x0.");

          if (!b && imm1b)
          THROW_WARNING("Invalid MRS (reg) encoding: imm1[0] != 0x0.");

          if (imm2)
          THROW_WARNING("Invalid MRS (reg/banked) encoding: imm2 != 0x0.");

          // Move from Special Register
          if (!b) {
            // Read CPSR
            if (!r) {
              if (CPSR[CPSR_M] & 0xF) {
                // Read CPSR for execution mode != USR
                rd = CPSR & 0xF8FF03DF;
              } else {
                // Read CPSR for execution mode = USR
                rd = CPSR & 0xF8FF0000;
              }
              // Read SPSR for execution modes != USR || SYS
            } else {
              int spsr_idx = get_spsr_idx(CPSR[CPSR_M]);
              if (spsr_idx >= 0) {
                rd = SPSR[spsr_idx];
              } else {
                THROW_EXCEPTION("MRS cannot read the SPSR in USR or SYS mode.");
              }
            }
            // Move from Banked Register
          } else {
            unsigned sys_mode = (imm1b << 4) | imm0;
            // Read banked registers for execution modes != USR
            if (!r) {
              if ((CPSR[CPSR_M] & 0xF) && valid_banked_reg_access(sys_mode)) {
                switch((sys_mode >> 3) & 0x3) {
                  case 0x0:
                  // Banked USR registers
                  //rd = RB[8 + (sys_mode & 0x7)];
                  rd = Rmode(8 + (sys_mode & 0x7), (unsigned)(EXECMODE::USR));
                  break;
                  case 0x1:
                  // Banked FIQ registers
                  //rd = RB[18 + (sys_mode & 0x7)];
                  rd = Rmode(8 + (sys_mode & 0x7), (unsigned)(EXECMODE::FIQ));
                  break;
                  case 0x2:
                  // Banked IRQ/SVC/ABT/UND registers
                  switch (sys_mode & 0x7) {
                    case 0x0:
                    case 0x1:
                    // Banked IRQ registers
                    //rd = RB[17 - (sys_mode & 0x1)];
                    rd = Rmode(14 - (sys_mode & 0x1), (unsigned)(EXECMODE::IRQ));
                    break;
                    case 0x2:
                    case 0x3:
                    // Banked SVC registers
                    //rd = RB[30 - (sys_mode & 0x1)];
                    rd = Rmode(14 - (sys_mode & 0x1), (unsigned)(EXECMODE::SVC));
                    break;
                    case 0x4:
                    case 0x5:
                    // Banked ABT registers
                    //rd = RB[28 - (sys_mode & 0x1)];
                    rd = Rmode(14 - (sys_mode & 0x1), (unsigned)(EXECMODE::ABT));
                    break;
                    case 0x6:
                    case 0x7:
                    // Banked UND registers
                    //rd = RB[26 - (sys_mode & 0x1)];
                    rd = Rmode(14 - (sys_mode & 0x1), (unsigned)(EXECMODE::UND));
                    break;
                  } break;
                  case 0x3:
                  // Banked MON/HYP registers
                  if (sys_mode & 0x2) {
                    // Banked HYP registers + ELR_hyp
                    //rd = RB[32 - (sys_mode & 0x1)];
                    if (sys_mode & 0x1) {
                      // SP_hyp
                      rd = Rmode(13, (unsigned)(EXECMODE::HYP));
                    } else {
                      // ELR_hyp
                      rd = RB[32];
                    }
                  } else {
                    // Banked MON registers
                    //rd = RB[34 - (sys_mode & 0x1)];
                    rd = Rmode(14 - (sys_mode & 0x1), (unsigned)(EXECMODE::MON));
                  }
                }
              } else {
                THROW_EXCEPTION("MRS cannot read banked registers in USR mode.");
              }
              // Read SPSR for execution modes != USR
            } else {
              unsigned cur_mode = CPSR[CPSR_M];
              if (cur_mode & 0xF) {
                switch(sys_mode) {
                  case 0x0E:
                  // Banked LR_IRQ / SP_IRQ registers: Inaccessible from IRQ
                  // mode
                  if (cur_mode != (unsigned)EXECMODE::FIQ /* TODO: && (IsSecure()
                  || NSACR[NSACR_RFR] != 1) */) rd = SPSR_FIQ;
                  break;
                  case 0x10:
                  if (cur_mode != (unsigned)EXECMODE::IRQ) rd = SPSR_IRQ;
                  break;
                  case 0x12:
                  if (cur_mode != (unsigned)EXECMODE::SVC) rd = SPSR_SVC;
                  break;
                  case 0x14:
                  if (cur_mode != (unsigned)EXECMODE::ABT) rd = SPSR_ABT;
                  break;
                  case 0x16:
                  if (cur_mode != (unsigned)EXECMODE::UND) rd = SPSR_UND;
                  break;
                  case 0x1C:
                  if (cur_mode != (unsigned)EXECMODE::MON /* TODO: && IsSecure()
                  */) rd = SPSR_MON;
                  break;
                  case 0x1E:
                  if (cur_mode == (unsigned)EXECMODE::MON) rd = SPSR_HYP;
                  break;
                }
              } else {
                THROW_EXCEPTION("MRS cannot read the SPSR in USR mode.");
              }
            }
          }
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::MSR_i::MSR_i(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ARMExpandImmOp(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // MSR_i()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MSR_i::get_id() const throw() {

          return 124;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MSR_i::get_name() const throw() {

          return "MSR_i";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MSR_i::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "MSR";
          oss << std::showbase << std::hex << this->cond;
          oss << " ";
          switch(this->r) {
            case 0: {
              oss << "CPSR";
            break;}
            case 1: {
              oss << "SPSR";
            break;}
          }
          oss << ", ";
          oss << std::showbase << std::hex << this->imm1a;
          oss << std::showbase << std::hex << this->b;
          oss << std::showbase << std::hex << this->imm1b;
          oss << std::showbase << std::hex << this->op1;
          oss << std::showbase << std::hex << this->imm2;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::MSR_i::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->r = (bitstring & 0x400000) >> 22;
          this->imm0a = (bitstring & 0xc0000) >> 18;
          this->imm0b = (bitstring & 0x30000) >> 16;
          this->imm1a = (bitstring & 0xc00) >> 10;
          this->b = (bitstring & 0x200) >> 9;
          this->imm1b = (bitstring & 0x100) >> 8;
          this->op1 = (bitstring & 0xf0) >> 4;
          this->imm2 = (bitstring & 0xf);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::MSR_i::replicate(Instruction*
        instr) const throw() {

          MSR_i* new_instr = new MSR_i(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            MSR_i* old_instr = dynamic_cast<MSR_i*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->r = old_instr->r;
              new_instr->imm0a = old_instr->imm0a;
              new_instr->imm0b = old_instr->imm0b;
              new_instr->imm1a = old_instr->imm1a;
              new_instr->b = old_instr->b;
              new_instr->imm1b = old_instr->imm1b;
              new_instr->op1 = old_instr->op1;
              new_instr->imm2 = old_instr->imm2;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MSR_i::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          imm0 = (imm0a << 2) | imm0b;

          if (r && !imm0)
          THROW_EXCEPTION("Invalid MSR (imm, sys) encoding: imm0 = 0x0.");

          if (rd_bit != 15)
          THROW_WARNING("Invalid MSR (imm) encoding: rd != 0xF.");

          // Needed by ARMExpandImm().
          rotate = (imm1a << 2) | (b << 1) | imm1b;
          imm = (op1 << 4) | imm2;

          // Needed by opCode shared with msr_reg_instr.
          id = 1;
          this->num_instr_cycles += ARMExpandImm(this->rotate, this->imm,
          this->operand, this->carry);

          // Move to Special Register (immediate or register)
          if (id || (!id && !b)) {
            // Write CPSR
            if (!r) {
              unsigned mode = CPSR[CPSR_M];
              unsigned mask = psr_mask(operand, imm0, mode, false, false);
              // If the mode is going to change, update the aliases.
              if ((mask & 0x1F) && (mode != (operand & 0x1F))) {
                update_alias(mode, operand & 0x1F);
              }
              if (mask) CPSR = (CPSR & ~mask) | (operand & mask);
              if ((CPSR[CPSR_M] == (unsigned)EXECMODE::HYP) && CPSR[CPSR_J] &&
              CPSR[CPSR_T]) {
                THROW_EXCEPTION("MSR cannot set CPSR Jazelle and Thumb flags in HYP mode.");
              }
              // Write SPSR for execution modes != USR || SYS
            } else {
              unsigned mask;
              int spsr_idx = get_spsr_idx(CPSR[CPSR_M]);
              if (spsr_idx >= 0) {
                mask = psr_mask(operand, imm0, CPSR[CPSR_M], true, false);
                if (mask) SPSR[spsr_idx] = (SPSR[spsr_idx] & ~mask) | (operand &
                mask);
              } else {
                THROW_EXCEPTION("MSR cannot write the SPSR in USR or SYS mode.");
              }
            }
            // Move to Banked Register
          } else {
            unsigned sys_mode = (imm1b << 4) | imm0;
            // Write banked registers for execution modes != USR
            if (!r) {
              if ((CPSR[CPSR_M] & 0xF) && valid_banked_reg_access(sys_mode)) {
                switch((sys_mode >> 3) & 0x3) {
                  case 0x0:
                  // Banked USR registers
                  //RB[8 + (sys_mode & 0x7)] = operand;
                  Rmode(8 + (sys_mode & 0x7), (unsigned)(EXECMODE::USR), true,
                  operand);
                  break;
                  case 0x1:
                  // Banked FIQ registers
                  //RB[18 + (sys_mode & 0x7)] = operand;
                  Rmode(8 + (sys_mode & 0x7), (unsigned)(EXECMODE::FIQ), true,
                  operand);
                  break;
                  case 0x2:
                  // Banked IRQ/SVC/ABT/UND registers
                  switch (sys_mode & 0x7) {
                    case 0x0:
                    case 0x1:
                    // Banked IRQ registers
                    //RB[17 - (sys_mode & 0x1)] = operand;
                    Rmode(14 - (sys_mode & 0x1), (unsigned)(EXECMODE::IRQ),
                    true, operand);
                    break;
                    case 0x2:
                    case 0x3:
                    // Banked SVC registers
                    //RB[30 - (sys_mode & 0x1)] = operand;
                    Rmode(14 - (sys_mode & 0x1), (unsigned)(EXECMODE::SVC),
                    true, operand);
                    break;
                    case 0x4:
                    case 0x5:
                    // Banked ABT registers
                    //RB[28 - (sys_mode & 0x1)] = operand;
                    Rmode(14 - (sys_mode & 0x1), (unsigned)(EXECMODE::ABT),
                    true, operand);
                    break;
                    case 0x6:
                    case 0x7:
                    // Banked UND registers
                    //RB[26 - (sys_mode & 0x1)] = operand;
                    Rmode(14 - (sys_mode & 0x1), (unsigned)(EXECMODE::UND),
                    true, operand);
                    break;
                  } break;
                  case 0x3:
                  // Banked MON/HYP registers
                  if (sys_mode & 0x2) {
                    // Banked HYP registers + ELR_hyp
                    //RB[32 - (sys_mode & 0x1)] = operand;
                    if (sys_mode & 0x1) {
                      // SP_hyp
                      Rmode(13, (unsigned)(EXECMODE::HYP), true, operand);
                    } else {
                      // ELR_hyp
                      RB[32] = operand;
                    }
                  } else {
                    // Banked MON registers
                    //RB[34 - (sys_mode & 0x1)] = operand;
                    Rmode(14 - (sys_mode & 0x1), (unsigned)(EXECMODE::MON),
                    true, operand);
                  }
                }
              } else {
                THROW_EXCEPTION("MSR cannot write banked registers in USR mode.");
              }
              // Write SPSR for execution modes != USR
            } else {
              unsigned cur_mode = CPSR[CPSR_M];
              if (cur_mode & 0xF) {
                switch(sys_mode) {
                  case 0x0E:
                  if (cur_mode != (unsigned)EXECMODE::FIQ /* TODO: && (IsSecure()
                  || NSACR[NSACR_RFR] != 1) */) SPSR_FIQ = operand;
                  break;
                  case 0x10:
                  if (cur_mode != (unsigned)EXECMODE::IRQ) SPSR_IRQ = operand;
                  break;
                  case 0x12:
                  if (cur_mode != (unsigned)EXECMODE::SVC) SPSR_SVC = operand;
                  break;
                  case 0x14:
                  if (cur_mode != (unsigned)EXECMODE::ABT) SPSR_ABT = operand;
                  break;
                  case 0x16:
                  if (cur_mode != (unsigned)EXECMODE::UND) SPSR_UND = operand;
                  break;
                  case 0x1C:
                  if (cur_mode != (unsigned)EXECMODE::MON /* TODO: && IsSecure()
                  */) SPSR_MON = operand;
                  break;
                  case 0x1E:
                  if (cur_mode == (unsigned)EXECMODE::MON) SPSR_HYP = operand;
                  break;
                }
              } else {
                THROW_EXCEPTION("MSR cannot write the SPSR in USR mode.");
              }
            }
          }
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::MSR_r::MSR_r(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // MSR_r()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MSR_r::get_id() const throw() {

          return 125;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MSR_r::get_name() const throw() {

          return "MSR_r";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MSR_r::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "MSR";
          oss << std::showbase << std::hex << this->cond;
          oss << " ";
          switch(this->r) {
            case 0: {
              oss << "CPSR";
            break;}
            case 1: {
              oss << "SPSR";
            break;}
          }
          oss << ", ";
          oss << std::showbase << std::hex << this->imm2;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::MSR_r::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->r = (bitstring & 0x400000) >> 22;
          this->imm0a = (bitstring & 0xc0000) >> 18;
          this->imm0b = (bitstring & 0x30000) >> 16;
          this->imm1a = (bitstring & 0xc00) >> 10;
          this->b = (bitstring & 0x200) >> 9;
          this->imm1b = (bitstring & 0x100) >> 8;
          this->imm2 = (bitstring & 0xf);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::MSR_r::replicate(Instruction*
        instr) const throw() {

          MSR_r* new_instr = new MSR_r(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            MSR_r* old_instr = dynamic_cast<MSR_r*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->r = old_instr->r;
              new_instr->imm0a = old_instr->imm0a;
              new_instr->imm0b = old_instr->imm0b;
              new_instr->imm1a = old_instr->imm1a;
              new_instr->b = old_instr->b;
              new_instr->imm1b = old_instr->imm1b;
              new_instr->imm2 = old_instr->imm2;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MSR_r::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          unsigned imm0 = (imm0a << 2) | imm0b;

          if (!b && !imm0)
          THROW_EXCEPTION("Invalid MSR (reg) encoding: imm0 = 0x0.");

          if (imm2 == 15)
          THROW_EXCEPTION("Invalid MSR (reg/banked) encoding: rn = 0xF.");

          if (b && rd_bit != 0xF)
          THROW_WARNING("Invalid MSR (reg/banked) encoding: rd != 0xF.");

          if (imm1a)
          THROW_WARNING("Invalid MSR (reg/banked) encoding: b[10:11] != 0x0.");

          if (!b && imm1b)
          THROW_WARNING("Invalid MSR (reg) encoding: b[8] != 0x0.");

          // Needed by opCode shared with msr_imm_instr.
          id = 0;

          // Needed by opCode shared with msr_imm_instr.
          operand = REGS[imm2];

          // Move to Special Register (immediate or register)
          if (id || (!id && !b)) {
            // Write CPSR
            if (!r) {
              unsigned mode = CPSR[CPSR_M];
              unsigned mask = psr_mask(operand, imm0, mode, false, false);
              // If the mode is going to change, update the aliases.
              if ((mask & 0x1F) && (mode != (operand & 0x1F))) {
                update_alias(mode, operand & 0x1F);
              }
              if (mask) CPSR = (CPSR & ~mask) | (operand & mask);
              if ((CPSR[CPSR_M] == (unsigned)EXECMODE::HYP) && CPSR[CPSR_J] &&
              CPSR[CPSR_T]) {
                THROW_EXCEPTION("MSR cannot set CPSR Jazelle and Thumb flags in HYP mode.");
              }
              // Write SPSR for execution modes != USR || SYS
            } else {
              unsigned mask;
              int spsr_idx = get_spsr_idx(CPSR[CPSR_M]);
              if (spsr_idx >= 0) {
                mask = psr_mask(operand, imm0, CPSR[CPSR_M], true, false);
                if (mask) SPSR[spsr_idx] = (SPSR[spsr_idx] & ~mask) | (operand &
                mask);
              } else {
                THROW_EXCEPTION("MSR cannot write the SPSR in USR or SYS mode.");
              }
            }
            // Move to Banked Register
          } else {
            unsigned sys_mode = (imm1b << 4) | imm0;
            // Write banked registers for execution modes != USR
            if (!r) {
              if ((CPSR[CPSR_M] & 0xF) && valid_banked_reg_access(sys_mode)) {
                switch((sys_mode >> 3) & 0x3) {
                  case 0x0:
                  // Banked USR registers
                  //RB[8 + (sys_mode & 0x7)] = operand;
                  Rmode(8 + (sys_mode & 0x7), (unsigned)(EXECMODE::USR), true,
                  operand);
                  break;
                  case 0x1:
                  // Banked FIQ registers
                  //RB[18 + (sys_mode & 0x7)] = operand;
                  Rmode(8 + (sys_mode & 0x7), (unsigned)(EXECMODE::FIQ), true,
                  operand);
                  break;
                  case 0x2:
                  // Banked IRQ/SVC/ABT/UND registers
                  switch (sys_mode & 0x7) {
                    case 0x0:
                    case 0x1:
                    // Banked IRQ registers
                    //RB[17 - (sys_mode & 0x1)] = operand;
                    Rmode(14 - (sys_mode & 0x1), (unsigned)(EXECMODE::IRQ),
                    true, operand);
                    break;
                    case 0x2:
                    case 0x3:
                    // Banked SVC registers
                    //RB[30 - (sys_mode & 0x1)] = operand;
                    Rmode(14 - (sys_mode & 0x1), (unsigned)(EXECMODE::SVC),
                    true, operand);
                    break;
                    case 0x4:
                    case 0x5:
                    // Banked ABT registers
                    //RB[28 - (sys_mode & 0x1)] = operand;
                    Rmode(14 - (sys_mode & 0x1), (unsigned)(EXECMODE::ABT),
                    true, operand);
                    break;
                    case 0x6:
                    case 0x7:
                    // Banked UND registers
                    //RB[26 - (sys_mode & 0x1)] = operand;
                    Rmode(14 - (sys_mode & 0x1), (unsigned)(EXECMODE::UND),
                    true, operand);
                    break;
                  } break;
                  case 0x3:
                  // Banked MON/HYP registers
                  if (sys_mode & 0x2) {
                    // Banked HYP registers + ELR_hyp
                    //RB[32 - (sys_mode & 0x1)] = operand;
                    if (sys_mode & 0x1) {
                      // SP_hyp
                      Rmode(13, (unsigned)(EXECMODE::HYP), true, operand);
                    } else {
                      // ELR_hyp
                      RB[32] = operand;
                    }
                  } else {
                    // Banked MON registers
                    //RB[34 - (sys_mode & 0x1)] = operand;
                    Rmode(14 - (sys_mode & 0x1), (unsigned)(EXECMODE::MON),
                    true, operand);
                  }
                }
              } else {
                THROW_EXCEPTION("MSR cannot write banked registers in USR mode.");
              }
              // Write SPSR for execution modes != USR
            } else {
              unsigned cur_mode = CPSR[CPSR_M];
              if (cur_mode & 0xF) {
                switch(sys_mode) {
                  case 0x0E:
                  if (cur_mode != (unsigned)EXECMODE::FIQ /* TODO: && (IsSecure()
                  || NSACR[NSACR_RFR] != 1) */) SPSR_FIQ = operand;
                  break;
                  case 0x10:
                  if (cur_mode != (unsigned)EXECMODE::IRQ) SPSR_IRQ = operand;
                  break;
                  case 0x12:
                  if (cur_mode != (unsigned)EXECMODE::SVC) SPSR_SVC = operand;
                  break;
                  case 0x14:
                  if (cur_mode != (unsigned)EXECMODE::ABT) SPSR_ABT = operand;
                  break;
                  case 0x16:
                  if (cur_mode != (unsigned)EXECMODE::UND) SPSR_UND = operand;
                  break;
                  case 0x1C:
                  if (cur_mode != (unsigned)EXECMODE::MON /* TODO: && IsSecure()
                  */) SPSR_MON = operand;
                  break;
                  case 0x1E:
                  if (cur_mode == (unsigned)EXECMODE::MON) SPSR_HYP = operand;
                  break;
                }
              } else {
                THROW_EXCEPTION("MSR cannot write the SPSR in USR mode.");
              }
            }
          }
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::B::B(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // B()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::B::get_id() const throw() {

          return 126;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::B::get_name() const throw() {

          return "B";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::B::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "B";
          oss << std::showbase << std::hex << this->cond;
          oss << " PC + ";
          oss << std::showbase << std::hex << ((((int)sign_extend(this->offset,
          24)) << 2));
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::B::set_params(const unsigned& bitstring)
        throw() {

          this->cond = (bitstring & 0xf0000000) >> 28;
          this->offset = (bitstring & 0xffffff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::B::replicate(Instruction* instr)
        const throw() {

          B* new_instr = new B(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            B* old_instr = dynamic_cast<B*>(instr);
            if (old_instr) {
              new_instr->cond = old_instr->cond;
              new_instr->offset = old_instr->offset;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::B::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          RB[15] = sign_extend(PC, 32) + (sign_extend(offset, 24) << 2);
          stall(2);
          flush();
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::BL::BL(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // BL()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::BL::get_id() const throw() {

          return 127;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::BL::get_name() const throw() {

          return "BL";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::BL::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "BL";
          oss << std::showbase << std::hex << this->cond;
          oss << " PC + ";
          oss << std::showbase << std::hex << ((((int)sign_extend(this->offset,
          24)) << 2));
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::BL::set_params(const unsigned& bitstring)
        throw() {

          this->cond = (bitstring & 0xf0000000) >> 28;
          this->offset = (bitstring & 0xffffff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::BL::replicate(Instruction* instr)
        const throw() {

          BL* new_instr = new BL(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            BL* old_instr = dynamic_cast<BL*>(instr);
            if (old_instr) {
              new_instr->cond = old_instr->cond;
              new_instr->offset = old_instr->offset;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::BL::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          // Find out the address of the next instruction.
          unsigned increment = 4;
          // Check instruction set mode.
          // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
          // JT=11: ThumbEE (16-bit)
          if (CPSR[CPSR_T]) {
            increment = 2;
          } else if (CPSR[CPSR_J]) {
            increment = 1;
          }

          LR = sign_extend(RB[15], 32) + increment;
          RB[15] = sign_extend(PC, 32) + (sign_extend(offset, 24) << 2);

          stall(2);
          flush();
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::BX::BX(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // BX()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::BX::get_id() const throw() {

          return 128;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::BX::get_name() const throw() {

          return "BX";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::BX::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "BX";
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rm_bit;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::BX::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rm_bit = (bitstring & 0xf);
          this->rm.set_alias(REGS[this->rm_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::BX::replicate(Instruction* instr)
        const throw() {

          BX* new_instr = new BX(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            BX* old_instr = dynamic_cast<BX*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rm_bit = old_instr->rm_bit;
              new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
              new_instr->cond = old_instr->cond;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::BX::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if ((rn_bit != 15) || (rd_bit != 15) || (rs_bit != 15))
          THROW_WARNING("Invalid BX encoding: rn|rd|rs != 0xF.");

          BXWritePC(rm);

          stall(2);
          flush();
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::BLX_i::BLX_i(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // BLX_i()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::BLX_i::get_id() const throw() {

          return 129;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::BLX_i::get_name() const throw() {

          return "BLX_i";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::BLX_i::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "BLX PC + ";
          oss << std::showbase << std::hex << ((((int)sign_extend(this->offset,
          24)) << 2));
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::BLX_i::set_params(const unsigned& bitstring)
        throw() {

          this->cond = (bitstring & 0xf0000000) >> 28;
          this->l = (bitstring & 0x1000000) >> 24;
          this->offset = (bitstring & 0xffffff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::BLX_i::replicate(Instruction*
        instr) const throw() {

          BLX_i* new_instr = new BLX_i(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            BLX_i* old_instr = dynamic_cast<BLX_i*>(instr);
            if (old_instr) {
              new_instr->cond = old_instr->cond;
              new_instr->l = old_instr->l;
              new_instr->offset = old_instr->offset;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::BLX_i::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          // Find out the address of the next instruction.
          unsigned increment = 4;
          // Check instruction set mode.
          // JT=00: ARM (32-bit); JT=01: Thumb (16-bit); JT=10: Jazelle (8-bit);
          // JT=11: ThumbEE (16-bit)
          if (CPSR[CPSR_T]) {
            increment = 2;
          } else if (CPSR[CPSR_J]) {
            increment = 1;
          }

          LR = sign_extend(RB[15], 32) + increment;
          // TODO: SelectInstructionSet(ISMODE::THUMB);
          RB[15] = sign_extend(PC, 32) + ((sign_extend(offset, 24) << 2) | (l <<
          1));

          // TODO: We need only one stall cycle since the PC value is fed back
          // from
          // execute/wb to prefetch/fetch directly.
          // @see ARMArch.py RB.setWbStageOrder(15, {...})
          stall(1);
          flush();
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::BLX_r::BLX_r(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // BLX_r()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::BLX_r::get_id() const throw() {

          return 130;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::BLX_r::get_name() const throw() {

          return "BLX_r";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::BLX_r::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "BLX";
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rm_bit;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::BLX_r::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rm_bit = (bitstring & 0xf);
          this->rm.set_alias(REGS[this->rm_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::BLX_r::replicate(Instruction*
        instr) const throw() {

          BLX_r* new_instr = new BLX_r(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            BLX_r* old_instr = dynamic_cast<BLX_r*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rm_bit = old_instr->rm_bit;
              new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
              new_instr->cond = old_instr->cond;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::BLX_r::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if (rm_bit == 15)
          THROW_EXCEPTION("Invalid BLX encoding: rm = 0xF.");

          if ((rn_bit != 15) || (rd_bit != 15) || (rs_bit != 15))
          THROW_WARNING("Invalid BLX encoding: rn|rd|rs != 0xF.");

          // RB[15] has been incremented and holds the address of the next
          // instruction.
          LR = RB[15];
          BXWritePC(rm);

          // TODO: We need only one stall cycle since the PC value is fed back
          // from
          // execute/wb to prefetch/fetch directly.
          // @see ARMArch.py RB.setWbStageOrder(15, {...})
          stall(1);
          flush();
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::BXJ::BXJ(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // BXJ()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::BXJ::get_id() const throw() {

          return 131;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::BXJ::get_name() const throw() {

          return "BXJ";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::BXJ::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "BXJ";
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rm_bit;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::BXJ::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rm_bit = (bitstring & 0xf);
          this->rm.set_alias(REGS[this->rm_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::BXJ::replicate(Instruction* instr)
        const throw() {

          BXJ* new_instr = new BXJ(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            BXJ* old_instr = dynamic_cast<BXJ*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rm_bit = old_instr->rm_bit;
              new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
              new_instr->cond = old_instr->cond;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::BXJ::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if (rm_bit == 15)
          THROW_EXCEPTION("Invalid BXJ encoding: rm = 0xF.");

          if ((rn_bit != 15) || (rd_bit != 15) || (rs_bit != 15))
          THROW_WARNING("Invalid BXJ encoding: rn|rd|rs != 0xF.");

          /* TODO:
          if (HaveVirtExt() && !IsSecure() && !CurrentModeIsHyp() && HSTR[HSTR_TJDBX]
          == 1) {
            WriteHSR('001010', m);
            TakeHypTrapException();
          } else if (!JMCR[JMCR_JE] || CurrentInstrSet() == ISMODE::THUMBEE) {
            BXWritePC(rm);
          } else {
            if (JazelleAcceptsExecution()) SwitchToJazelleExecution();
            else THROW_EXCEPTION("Jazelle Instruction Set unimplemented.");
          } */

          BXWritePC(rm);

          stall(2);
          flush();
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::BKPT::BKPT(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // BKPT()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::BKPT::get_id() const throw() {

          return 132;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::BKPT::get_name() const throw() {

          return "BKPT";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::BKPT::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "BKPT R";
          oss << std::dec << this->rn_bit;
          oss << std::dec << this->rd_bit;
          oss << std::dec << this->rs_bit;
          oss << std::dec << this->rm_bit;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::BKPT::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rm_bit = (bitstring & 0xf);
          this->rm.set_alias(REGS[this->rm_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::BKPT::replicate(Instruction*
        instr) const throw() {

          BKPT* new_instr = new BKPT(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            BKPT* old_instr = dynamic_cast<BKPT*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rm_bit = old_instr->rm_bit;
              new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
              new_instr->cond = old_instr->cond;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::BKPT::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if (cond != 0xE)
          THROW_EXCEPTION("Invalid BKPT encoding: cond != 0xE.");

          THROW_WARNING("Unimplemented instruction BKPT.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::CLREX::CLREX(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory) {


        } // CLREX()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::CLREX::get_id() const throw() {

          return 133;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::CLREX::get_name() const throw() {

          return "CLREX";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::CLREX::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "C";
          oss << "L";
          oss << "R";
          oss << "E";
          oss << "X";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::CLREX::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rm_bit = (bitstring & 0xf);
          this->rm.set_alias(REGS[this->rm_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::CLREX::replicate(Instruction*
        instr) const throw() {

          CLREX* new_instr = new CLREX(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            CLREX* old_instr = dynamic_cast<CLREX*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rm_bit = old_instr->rm_bit;
              new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::CLREX::behavior() {

          this->num_instr_cycles = 0;

          if ((rn_bit != 15) || (rd_bit != 15) || (rm_bit != 15))
          THROW_WARNING("Invalid CLREX encoding: rn|rd|rm != 0xF.");

          if (rs_bit != 0)
          THROW_WARNING("Invalid CLREX encoding: rs != 0x0.");

          THROW_WARNING("Unimplemented instruction CLREX.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::CPS::CPS(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory) {


        } // CPS()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::CPS::get_id() const throw() {

          return 134;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::CPS::get_name() const throw() {

          return "CPS";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::CPS::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "CPS ";
          oss << std::showbase << std::hex << this->mode0;
          oss << std::showbase << std::hex << this->mode1;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::CPS::set_params(const unsigned& bitstring)
        throw() {

          this->op2 = (bitstring & 0xc0000) >> 18;
          this->M = (bitstring & 0x20000) >> 17;
          this->b15to10 = (bitstring & 0xfc00) >> 10;
          this->E = (bitstring & 0x200) >> 9;
          this->A = (bitstring & 0x100) >> 8;
          this->I = (bitstring & 0x80) >> 7;
          this->F = (bitstring & 0x40) >> 6;
          this->mode0 = (bitstring & 0x10) >> 4;
          this->mode1 = (bitstring & 0xf);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::CPS::replicate(Instruction* instr)
        const throw() {

          CPS* new_instr = new CPS(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            CPS* old_instr = dynamic_cast<CPS*>(instr);
            if (old_instr) {
              new_instr->op2 = old_instr->op2;
              new_instr->M = old_instr->M;
              new_instr->b15to10 = old_instr->b15to10;
              new_instr->E = old_instr->E;
              new_instr->A = old_instr->A;
              new_instr->I = old_instr->I;
              new_instr->F = old_instr->F;
              new_instr->mode0 = old_instr->mode0;
              new_instr->mode1 = old_instr->mode1;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::CPS::behavior() {

          this->num_instr_cycles = 0;

          mode = (mode0 << 4) | mode1;

          if (mode && !M)
          THROW_EXCEPTION("Invalid CPS encoding: M = 0 and mode != 0x0.");

          if ((op2 & 0x2) && !A && !I && !F)
          THROW_EXCEPTION("Invalid CPS encoding: imod[1] = 1 and A:I:F = 0x0.");

          if (!(op2 & 0x2) && (A || I || F))
          THROW_EXCEPTION("Invalid CPS encoding: imod[1] = 0 and A:I:F != 0x0.");

          if (!op2 && !M)
          THROW_EXCEPTION("Invalid CPS encoding: imod = 0x0 and M = 0.");

          if (op2 == 1)
          THROW_EXCEPTION("Invalid CPS encoding: imod = 0x1.");

          if (b15to10)
          THROW_WARNING("Invalid CPS encoding: bit[15:10] != 0x0.");

          if (E)
          THROW_WARNING("Invalid CPS encoding: bit[9] != 0x0.");

          THROW_WARNING("Unimplemented instruction CPS.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::DBG::DBG(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // DBG()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::DBG::get_id() const throw() {

          return 135;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::DBG::get_name() const throw() {

          return "DBG";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::DBG::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "DBG R";
          oss << std::showbase << std::hex << this->rm;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::DBG::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->rm = (bitstring & 0xf);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::DBG::replicate(Instruction* instr)
        const throw() {

          DBG* new_instr = new DBG(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            DBG* old_instr = dynamic_cast<DBG*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->rm = old_instr->rm;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::DBG::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if (rd_bit != 15)
          THROW_WARNING("Invalid DBG encoding: rd != 0xF.");

          if (rs_bit)
          THROW_WARNING("Invalid DBG encoding: rs != 0x0.");

          THROW_WARNING("Unimplemented instruction DBG.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::DMB::DMB(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory) {


        } // DMB()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::DMB::get_id() const throw() {

          return 136;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::DMB::get_name() const throw() {

          return "DMB";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::DMB::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "DMB ";
          switch(this->rm_bit) {
            case 2: {
              oss << "OSHST";
            break;}
            case 3: {
              oss << "OSH";
            break;}
            case 6: {
              oss << "NSHST";
            break;}
            case 7: {
              oss << "NSH";
            break;}
            case 10: {
              oss << "ISHST";
            break;}
            case 11: {
              oss << "ISH";
            break;}
            case 14: {
              oss << "ST";
            break;}
            case 15: {
              oss << "SY";
            break;}
          }
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::DMB::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rm_bit = (bitstring & 0xf);
          this->rm.set_alias(REGS[this->rm_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::DMB::replicate(Instruction* instr)
        const throw() {

          DMB* new_instr = new DMB(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            DMB* old_instr = dynamic_cast<DMB*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rm_bit = old_instr->rm_bit;
              new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::DMB::behavior() {

          this->num_instr_cycles = 0;

          if ((rn_bit != 15) || (rd_bit != 15))
          THROW_WARNING("Invalid DMB encoding: rn|rd != 0xF.");

          if (rs_bit)
          THROW_WARNING("Invalid DMB encoding: rs != 0x0.");

          THROW_WARNING("Unimplemented instruction DMB.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::DSB::DSB(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory) {


        } // DSB()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::DSB::get_id() const throw() {

          return 137;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::DSB::get_name() const throw() {

          return "DSB";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::DSB::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "DSB ";
          switch(this->rm_bit) {
            case 2: {
              oss << "OSHST";
            break;}
            case 3: {
              oss << "OSH";
            break;}
            case 6: {
              oss << "NSHST";
            break;}
            case 7: {
              oss << "NSH";
            break;}
            case 10: {
              oss << "ISHST";
            break;}
            case 11: {
              oss << "ISH";
            break;}
            case 14: {
              oss << "ST";
            break;}
            case 15: {
              oss << "SY";
            break;}
          }
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::DSB::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rm_bit = (bitstring & 0xf);
          this->rm.set_alias(REGS[this->rm_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::DSB::replicate(Instruction* instr)
        const throw() {

          DSB* new_instr = new DSB(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            DSB* old_instr = dynamic_cast<DSB*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rm_bit = old_instr->rm_bit;
              new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::DSB::behavior() {

          this->num_instr_cycles = 0;

          if ((rn_bit != 15) || (rd_bit != 15))
          THROW_WARNING("Invalid DSB encoding: rn|rd != 0xF.");

          if (rs_bit)
          THROW_WARNING("Invalid DSB encoding: rs != 0x0.");

          THROW_WARNING("Unimplemented instruction DSB.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::ISB::ISB(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory) {


        } // ISB()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::ISB::get_id() const throw() {

          return 138;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::ISB::get_name() const throw() {

          return "ISB";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::ISB::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "ISB ";
          switch(this->rm_bit) {
            case 15: {
              oss << "SY";
            break;}
          }
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::ISB::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rm_bit = (bitstring & 0xf);
          this->rm.set_alias(REGS[this->rm_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::ISB::replicate(Instruction* instr)
        const throw() {

          ISB* new_instr = new ISB(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            ISB* old_instr = dynamic_cast<ISB*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rm_bit = old_instr->rm_bit;
              new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::ISB::behavior() {

          this->num_instr_cycles = 0;

          if ((rn_bit != 15) || (rd_bit != 15))
          THROW_WARNING("Invalid ISB encoding: rn|rd != 0xF.");

          if (rs_bit)
          THROW_WARNING("Invalid ISB encoding: rs != 0x0.");

          THROW_WARNING("Unimplemented instruction ISB.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::NOP::NOP(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // NOP()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::NOP::get_id() const throw() {

          return 139;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::NOP::get_name() const throw() {

          return "NOP";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::NOP::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "NOP";
          oss << std::showbase << std::hex << this->cond;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::NOP::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::NOP::replicate(Instruction* instr)
        const throw() {

          NOP* new_instr = new NOP(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            NOP* old_instr = dynamic_cast<NOP*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
              new_instr->cond = old_instr->cond;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::NOP::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if (rd_bit != 15)
          THROW_WARNING("Invalid NOP encoding: rd != 0xF.");

          if (rs_bit)
          THROW_WARNING("Invalid NOP encoding: rs != 0x0.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::PLI_i::PLI_i(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory) {


        } // PLI_i()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::PLI_i::get_id() const throw() {

          return 140;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::PLI_i::get_name() const throw() {

          return "PLI_i";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::PLI_i::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "PLI [";
          oss << "rn";
          oss << ", ";
          switch(this->u) {
            case 0: {
              oss << "-";
            break;}
            case 1: {
              oss << "+";
            break;}
          }
          oss << std::dec << this->rs_bit;
          oss << std::showbase << std::hex << this->op1a;
          oss << std::showbase << std::hex << this->op1b;
          oss << std::dec << this->rm_bit;
          oss << "]";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::PLI_i::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rm_bit = (bitstring & 0xf);
          this->rm.set_alias(REGS[this->rm_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
          this->u = (bitstring & 0x800000) >> 23;
          this->op1a = (bitstring & 0xe0) >> 5;
          this->op1b = (bitstring & 0x10) >> 4;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::PLI_i::replicate(Instruction*
        instr) const throw() {

          PLI_i* new_instr = new PLI_i(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            PLI_i* old_instr = dynamic_cast<PLI_i*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rm_bit = old_instr->rm_bit;
              new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
              new_instr->u = old_instr->u;
              new_instr->op1a = old_instr->op1a;
              new_instr->op1b = old_instr->op1b;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::PLI_i::behavior() {

          this->num_instr_cycles = 0;

          if (rd_bit != 15)
          THROW_WARNING("Invalid PLI (immediate/literal) encoding: rd != 0xF.");

          THROW_WARNING("Unimplemented instruction PLI.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::PLI_r::PLI_r(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory) {


        } // PLI_r()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::PLI_r::get_id() const throw() {

          return 141;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::PLI_r::get_name() const throw() {

          return "PLI_r";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::PLI_r::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "PLI [";
          oss << "rn";
          oss << ", ";
          switch(this->u) {
            case 0: {
              oss << "-";
            break;}
            case 1: {
              oss << "+";
            break;}
          }
          oss << std::dec << this->rm_bit;
          oss << "]";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::PLI_r::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rm_bit = (bitstring & 0xf);
          this->rm.set_alias(REGS[this->rm_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
          this->u = (bitstring & 0x800000) >> 23;
          this->op1a = (bitstring & 0xe0) >> 5;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::PLI_r::replicate(Instruction*
        instr) const throw() {

          PLI_r* new_instr = new PLI_r(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            PLI_r* old_instr = dynamic_cast<PLI_r*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rm_bit = old_instr->rm_bit;
              new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
              new_instr->u = old_instr->u;
              new_instr->op1a = old_instr->op1a;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::PLI_r::behavior() {

          this->num_instr_cycles = 0;

          if (rm_bit == 15)
          THROW_EXCEPTION("Invalid PLI (register) encoding: rm = 0xF.");

          if (rd_bit != 15)
          THROW_WARNING("Invalid PLI (register) encoding: rd != 0xF.");

          THROW_WARNING("Unimplemented instruction PLI.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::PLD_i::PLD_i(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory) {


        } // PLD_i()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::PLD_i::get_id() const throw() {

          return 142;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::PLD_i::get_name() const throw() {

          return "PLD_i";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::PLD_i::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "PLD";
          switch(this->r) {
            case 0: {
              oss << "W";
            break;}
          }
          oss << " [";
          oss << "rn";
          oss << ", ";
          switch(this->u) {
            case 0: {
              oss << "-";
            break;}
            case 1: {
              oss << "+";
            break;}
          }
          oss << std::dec << this->rs_bit;
          oss << std::showbase << std::hex << this->op1a;
          oss << std::showbase << std::hex << this->op1b;
          oss << std::dec << this->rm_bit;
          oss << "]";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::PLD_i::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rm_bit = (bitstring & 0xf);
          this->rm.set_alias(REGS[this->rm_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
          this->u = (bitstring & 0x800000) >> 23;
          this->r = (bitstring & 0x400000) >> 22;
          this->op1a = (bitstring & 0xe0) >> 5;
          this->op1b = (bitstring & 0x10) >> 4;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::PLD_i::replicate(Instruction*
        instr) const throw() {

          PLD_i* new_instr = new PLD_i(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            PLD_i* old_instr = dynamic_cast<PLD_i*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rm_bit = old_instr->rm_bit;
              new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
              new_instr->u = old_instr->u;
              new_instr->r = old_instr->r;
              new_instr->op1a = old_instr->op1a;
              new_instr->op1b = old_instr->op1b;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::PLD_i::behavior() {

          this->num_instr_cycles = 0;

          THROW_WARNING("Unimplemented instruction PLD.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::PLD_r::PLD_r(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory) {


        } // PLD_r()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::PLD_r::get_id() const throw() {

          return 143;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::PLD_r::get_name() const throw() {

          return "PLD_r";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::PLD_r::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "PLD";
          switch(this->r) {
            case 0: {
              oss << "W";
            break;}
          }
          oss << " [";
          oss << "rn";
          oss << ", ";
          switch(this->u) {
            case 0: {
              oss << "-";
            break;}
            case 1: {
              oss << "+";
            break;}
          }
          oss << std::dec << this->rm_bit;
          oss << "]";
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::PLD_r::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rm_bit = (bitstring & 0xf);
          this->rm.set_alias(REGS[this->rm_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
          this->u = (bitstring & 0x800000) >> 23;
          this->r = (bitstring & 0x400000) >> 22;
          this->op1a = (bitstring & 0xe0) >> 5;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::PLD_r::replicate(Instruction*
        instr) const throw() {

          PLD_r* new_instr = new PLD_r(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            PLD_r* old_instr = dynamic_cast<PLD_r*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rm_bit = old_instr->rm_bit;
              new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
              new_instr->u = old_instr->u;
              new_instr->r = old_instr->r;
              new_instr->op1a = old_instr->op1a;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::PLD_r::behavior() {

          this->num_instr_cycles = 0;

          if (!r && (rn_bit == 15))
          THROW_EXCEPTION("Invalid PLD (register) encoding: r =0 and rn = 0xF.");

          if (rm_bit == 15)
          THROW_EXCEPTION("Invalid PLD (register) encoding: rm = 0xF.");

          if (rd_bit != 15)
          THROW_WARNING("Invalid PLD (register) encoding: rd != 0xF.");

          THROW_WARNING("Unimplemented instruction PLD.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::RFE::RFE(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory) {


        } // RFE()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::RFE::get_id() const throw() {

          return 144;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::RFE::get_name() const throw() {

          return "RFE";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::RFE::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "RFE";
          switch(this->u) {
            case 0: {
              oss << "D";
            break;}
            case 1: {
              oss << "I";
            break;}
          }
          switch(this->p) {
            case 0: {
              oss << "A";
            break;}
            case 1: {
              oss << "B";
            break;}
          }
          oss << " R";
          oss << std::dec << this->rn_bit;
          switch(this->w) {
            case 1: {
              oss << "!";
            break;}
          }
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::RFE::set_params(const unsigned& bitstring)
        throw() {

          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->p = (bitstring & 0x1000000) >> 24;
          this->u = (bitstring & 0x800000) >> 23;
          this->w = (bitstring & 0x200000) >> 21;
          this->imm0 = (bitstring & 0xf000) >> 12;
          this->imm1 = (bitstring & 0xf00) >> 8;
          this->op1 = (bitstring & 0xf0) >> 4;
          this->imm2 = (bitstring & 0xf);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::RFE::replicate(Instruction* instr)
        const throw() {

          RFE* new_instr = new RFE(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            RFE* old_instr = dynamic_cast<RFE*>(instr);
            if (old_instr) {
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->p = old_instr->p;
              new_instr->u = old_instr->u;
              new_instr->w = old_instr->w;
              new_instr->imm0 = old_instr->imm0;
              new_instr->imm1 = old_instr->imm1;
              new_instr->op1 = old_instr->op1;
              new_instr->imm2 = old_instr->imm2;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::RFE::behavior() {

          this->num_instr_cycles = 0;

          if (rn_bit == 15)
          THROW_EXCEPTION("Invalid RFE encoding: rn = 0xF.");

          if (imm0)
          THROW_WARNING("Invalid RFE encoding: rd != 0x0.");

          if (imm1 != 0xA)
          THROW_WARNING("Invalid RFE encoding: rs != 0xA.");

          if (imm1)
          THROW_WARNING("Invalid RFE encoding: op1 != 0x0.");

          if (imm2)
          THROW_WARNING("Invalid RFE encoding: rm != 0x0.");

          THROW_WARNING("Unimplemented instruction RFE.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::SETEND::SETEND(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory) {


        } // SETEND()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::SETEND::get_id() const throw() {

          return 145;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::SETEND::get_name() const throw() {

          return "SETEND";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::SETEND::get_mnemonic() const
        throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "SETEND ";
          switch(this->E) {
            case 0: {
              oss << "LE";
            break;}
            case 1: {
              oss << "BE";
            break;}
          }
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::SETEND::set_params(const unsigned& bitstring)
        throw() {

          this->op2 = (bitstring & 0xc0000) >> 18;
          this->M = (bitstring & 0x20000) >> 17;
          this->b15to10 = (bitstring & 0xfc00) >> 10;
          this->E = (bitstring & 0x200) >> 9;
          this->A = (bitstring & 0x100) >> 8;
          this->mode1 = (bitstring & 0xf);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::SETEND::replicate(Instruction*
        instr) const throw() {

          SETEND* new_instr = new SETEND(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            SETEND* old_instr = dynamic_cast<SETEND*>(instr);
            if (old_instr) {
              new_instr->op2 = old_instr->op2;
              new_instr->M = old_instr->M;
              new_instr->b15to10 = old_instr->b15to10;
              new_instr->E = old_instr->E;
              new_instr->A = old_instr->A;
              new_instr->mode1 = old_instr->mode1;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::SETEND::behavior() {

          this->num_instr_cycles = 0;

          if (op2)
          THROW_WARNING("Invalid SETEND encoding: bit[19:18] != 0x0.");

          if (M)
          THROW_WARNING("Invalid SETEND encoding: bit[17] != 0.");

          if (b15to10)
          THROW_WARNING("Invalid SETEND encoding: bit[15:9] != 0x0.");

          if (A)
          THROW_WARNING("Invalid SETEND encoding: bit[8] != 0.");

          if (mode1)
          THROW_WARNING("Invalid SETEND encoding: bit[3:0] != 0x0.");

          THROW_WARNING("Unimplemented instruction SETEND.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::SEV::SEV(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // SEV()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::SEV::get_id() const throw() {

          return 146;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::SEV::get_name() const throw() {

          return "SEV";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::SEV::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "SEV";
          oss << std::showbase << std::hex << this->cond;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::SEV::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::SEV::replicate(Instruction* instr)
        const throw() {

          SEV* new_instr = new SEV(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            SEV* old_instr = dynamic_cast<SEV*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
              new_instr->cond = old_instr->cond;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::SEV::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if (rd_bit != 15)
          THROW_WARNING("Invalid SEV encoding: rd != 0xF.");

          if (rs_bit)
          THROW_WARNING("Invalid SEV encoding: rs != 0x0.");

          THROW_WARNING("Unimplemented instruction SEV.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::SRS::SRS(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory) {


        } // SRS()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::SRS::get_id() const throw() {

          return 147;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::SRS::get_name() const throw() {

          return "SRS";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::SRS::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "SRS";
          switch(this->u) {
            case 0: {
              oss << "D";
            break;}
            case 1: {
              oss << "I";
            break;}
          }
          switch(this->p) {
            case 0: {
              oss << "A";
            break;}
            case 1: {
              oss << "B";
            break;}
          }
          oss << " ";
          oss << "SP";
          switch(this->w) {
            case 1: {
              oss << "!";
            break;}
          }
          oss << " ";
          oss << std::showbase << std::hex << this->imm2;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::SRS::set_params(const unsigned& bitstring)
        throw() {

          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->p = (bitstring & 0x1000000) >> 24;
          this->u = (bitstring & 0x800000) >> 23;
          this->w = (bitstring & 0x200000) >> 21;
          this->imm0 = (bitstring & 0xf000) >> 12;
          this->imm1 = (bitstring & 0xf00) >> 8;
          this->op1 = (bitstring & 0xf0) >> 4;
          this->imm2 = (bitstring & 0xf);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::SRS::replicate(Instruction* instr)
        const throw() {

          SRS* new_instr = new SRS(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            SRS* old_instr = dynamic_cast<SRS*>(instr);
            if (old_instr) {
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->p = old_instr->p;
              new_instr->u = old_instr->u;
              new_instr->w = old_instr->w;
              new_instr->imm0 = old_instr->imm0;
              new_instr->imm1 = old_instr->imm1;
              new_instr->op1 = old_instr->op1;
              new_instr->imm2 = old_instr->imm2;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::SRS::behavior() {

          this->num_instr_cycles = 0;

          if (rn_bit != 0xD)
          THROW_WARNING("Invalid SRS encoding: rn != 0xD.");

          if (imm0)
          THROW_WARNING("Invalid SRS encoding: rd != 0x0.");

          if (imm1 != 0x5)
          THROW_WARNING("Invalid SRS encoding: rs != 0x5.");

          if (imm1 & 0xE)
          THROW_WARNING("Invalid SRS encoding: op1[3:1] != 0x0.");

          mode = ((imm1 << 4) & 0x10) | imm2;

          THROW_WARNING("Unimplemented instruction SRS.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::SVC::SVC(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // SVC()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::SVC::get_id() const throw() {

          return 148;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::SVC::get_name() const throw() {

          return "SVC";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::SVC::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "SVC";
          oss << std::showbase << std::hex << this->cond;
          oss << " ";
          oss << std::showbase << std::hex << this->swi_number;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::SVC::set_params(const unsigned& bitstring)
        throw() {

          this->cond = (bitstring & 0xf0000000) >> 28;
          this->swi_number = (bitstring & 0xffffff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::SVC::replicate(Instruction* instr)
        const throw() {

          SVC* new_instr = new SVC(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            SVC* old_instr = dynamic_cast<SVC*>(instr);
            if (old_instr) {
              new_instr->cond = old_instr->cond;
              new_instr->swi_number = old_instr->swi_number;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::SVC::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          // CallSupervisor(swi_number);
          // Calls the Supervisor, with appropriate trapping etc.
          /* TODO:
          // Will be taken to Hyp mode so must set HSR.
          if ((CPSR[CPSR_M] == (unsigned)EXECMODE::HYP)
          || (HaveVirtExt() && !IsSecure() && (CPSR[CPSR_M] == (unsigned)EXECMODE::USR)
          && HCR[HCR_TGE] == 1)) {
            unsigned HSR_value = 0;
            if (CurrentCond(this->bitstring) cond == 0xE) {
              HSR_value |= (swi_number & 0xFFFF);
            }
            WriteHSR(0x11, HSR_value);
          }*/

          // TakeSVCException();
          // Determine return information. SPSR is to be the current CPSR, after
          // changing the IT[] bits to give them the correct values for the
          // following instruction, and LR is to be the current PC minus 2 for
          // Thumb or 4 for ARM, to change the PC offsets of 4 or 8 respectively
          // from the address of the current instruction into the required
          // address of the next instruction, the SVC instruction having size 2
          // bytes for Thumb or 4 bytes for ARM.

          ITAdvance();
          unsigned LR_value = ((CPSR[CPSR_T] == 1)? PC-2 : PC-4);
          unsigned SPSR_value = CPSR;
          unsigned vect_offset = 8;

          /* TODO:
          bool take_to_hyp = false, route_to_hyp = false;
          // Check whether to take exception to Hyp mode: If in Hyp mode, stay
          // in Hyp mode.
          take_to_hyp = (HaveVirtExt() && HaveSecurityExt() && SCR[SCR_NS] == 1
          && CPSR[CPSR_M] == (unsigned)EXECMODE::HYP);

          // If HCR.TGE is set to 1, take to Hyp mode through Hyp Trap vector.
          route_to_hyp = (HaveVirtExt() && HaveSecurityExt() && !IsSecure() &&
          HCR[HCR_TGE] == 1 && CPSR[CPSR_M] == (unsigned)EXECMODE::USR);

          // if HCR.TGE == '1' and in a Non-secure PL1 mode, the effect is
          // UNPREDICTABLE

          if (take_to_hyp) {
            EnterHypMode(SPSR_value, LR_value, vect_offset);
          } else if (route_to_hyp) {
            EnterHypMode(SPSR_value, LR_value, 20);
          } else {
            // Enter Supervisor mode, and ensure Secure state if initially in
            // Monitor mode. This affects the Banked versions of various registers
            // accessed later in the code.
            if (CPSR[CPSR_M] == (unsigned)EXECMODE::MON) SCR[SCR_NS] = 0;*/

            // Make further CPSR changes: IRQs disabled, IT state reset, instruction
            // set and endianness set to SCTLR-configured values.
            // CPSR &= 0xF9FF03FF;
            CPSR[CPSR_IT72] = CPSR[CPSR_IT10] = 0;

            // CPSR &= 0xFEFFFFFF;
            CPSR[CPSR_J] = 0;

            // EE=0: little-endian; EE=1: big-endian
            // TODO: CPSR[CPSR_E] = SCTLR[SCTLR_EE];

            // Disable normal interrupts.
            // CPSR |= 0x00000080;
            CPSR[CPSR_I] = 1;

            // Execute in ARM state.
            // CPSR &= 0xFFFFFFDF
            // TE=0: ARM; TE=1: Thumb
            CPSR[CPSR_T] = 0; /* TODO: SCTLR[SCTLR_TE]; */

            // Enter supervisor mode.
            // CPSR &= 0xFFFFFFF0; CPSR |= 0x00000003;
            CPSR[CPSR_M] = (unsigned)EXECMODE::SVC;

            // Write return information to registers.
            SPSR[get_spsr_idx(CPSR[CPSR_M])] = SPSR_value;
            Rmode(14, CPSR[CPSR_M], true, LR_value);

            // Branch to SVC vector.
            PC = ExcVectorBase() + vect_offset;
          //}
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::UDF::UDF(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // UDF()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::UDF::get_id() const throw() {

          return 149;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::UDF::get_name() const throw() {

          return "UDF";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::UDF::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "UDF";
          oss << std::showbase << std::hex << this->cond;
          oss << " ";
          oss << std::showbase << std::hex << this->imm0;
          oss << std::showbase << std::hex << this->imm1;
          oss << std::showbase << std::hex << this->imm2;
          oss << std::showbase << std::hex << this->imm3;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::UDF::set_params(const unsigned& bitstring)
        throw() {

          this->cond = (bitstring & 0xf0000000) >> 28;
          this->imm0 = (bitstring & 0xf0000) >> 16;
          this->imm1 = (bitstring & 0xf000) >> 12;
          this->imm2 = (bitstring & 0xf00) >> 8;
          this->imm3 = (bitstring & 0xf);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::UDF::replicate(Instruction* instr)
        const throw() {

          UDF* new_instr = new UDF(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            UDF* old_instr = dynamic_cast<UDF*>(instr);
            if (old_instr) {
              new_instr->cond = old_instr->cond;
              new_instr->imm0 = old_instr->imm0;
              new_instr->imm1 = old_instr->imm1;
              new_instr->imm2 = old_instr->imm2;
              new_instr->imm3 = old_instr->imm3;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::UDF::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          THROW_WARNING("Unimplemented instruction UDF.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::WFE::WFE(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // WFE()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::WFE::get_id() const throw() {

          return 150;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::WFE::get_name() const throw() {

          return "WFE";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::WFE::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "WFE";
          oss << std::showbase << std::hex << this->cond;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::WFE::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::WFE::replicate(Instruction* instr)
        const throw() {

          WFE* new_instr = new WFE(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            WFE* old_instr = dynamic_cast<WFE*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
              new_instr->cond = old_instr->cond;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::WFE::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if (rd_bit != 15)
          THROW_WARNING("Invalid WFE encoding: rd != 0xF.");

          if (rs_bit)
          THROW_WARNING("Invalid WFE encoding: rs != 0x0.");

          THROW_WARNING("Unimplemented instruction WFE.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::WFI::WFI(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // WFI()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::WFI::get_id() const throw() {

          return 151;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::WFI::get_name() const throw() {

          return "WFI";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::WFI::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "WFI";
          oss << std::showbase << std::hex << this->cond;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::WFI::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::WFI::replicate(Instruction* instr)
        const throw() {

          WFI* new_instr = new WFI(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            WFI* old_instr = dynamic_cast<WFI*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
              new_instr->cond = old_instr->cond;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::WFI::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if (rd_bit != 15)
          THROW_WARNING("Invalid WFI encoding: rd != 0xF.");

          if (rs_bit)
          THROW_WARNING("Invalid WFI encoding: rs != 0x0.");

          THROW_WARNING("Unimplemented instruction WFI.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::YIELD::YIELD(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // YIELD()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::YIELD::get_id() const throw() {

          return 152;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::YIELD::get_name() const throw() {

          return "YIELD";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::YIELD::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "YIELD";
          oss << std::showbase << std::hex << this->cond;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::YIELD::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::YIELD::replicate(Instruction*
        instr) const throw() {

          YIELD* new_instr = new YIELD(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            YIELD* old_instr = dynamic_cast<YIELD*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
              new_instr->cond = old_instr->cond;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::YIELD::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if (rd_bit != 15)
          THROW_WARNING("Invalid YIELD encoding: rd != 0xF.");

          if (rs_bit)
          THROW_WARNING("Invalid YIELD encoding: rs != 0x0.");

          THROW_WARNING("Unimplemented instruction YIELD.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::SMC::SMC(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // SMC()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::SMC::get_id() const throw() {

          return 153;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::SMC::get_name() const throw() {

          return "SMC";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::SMC::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "SMC";
          oss << std::showbase << std::hex << this->cond;
          oss << " R";
          oss << std::dec << this->rm_bit;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::SMC::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rm_bit = (bitstring & 0xf);
          this->rm.set_alias(REGS[this->rm_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->rs_bit = (bitstring & 0xf00) >> 8;
          this->rs.set_alias(REGS[this->rs_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::SMC::replicate(Instruction* instr)
        const throw() {

          SMC* new_instr = new SMC(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            SMC* old_instr = dynamic_cast<SMC*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rm_bit = old_instr->rm_bit;
              new_instr->rm.set_alias(REGS[new_instr->rm_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->rs_bit = old_instr->rs_bit;
              new_instr->rs.set_alias(REGS[new_instr->rs_bit]);
              new_instr->cond = old_instr->cond;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::SMC::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          THROW_WARNING("Unimplemented instruction SMC.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::CDP::CDP(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // CDP()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::CDP::get_id() const throw() {

          return 154;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::CDP::get_name() const throw() {

          return "CDP";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::CDP::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "CDP";
          oss << std::showbase << std::hex << this->cond;
          oss << " ";
          oss << std::showbase << std::hex << this->cpnum;
          oss << ", ";
          oss << std::showbase << std::hex << this->op0;
          oss << ", ";
          oss << std::dec << this->cprd_bit;
          oss << ", ";
          oss << std::dec << this->cprn_bit;
          oss << ", ";
          oss << std::dec << this->cprm_bit;
          oss << ", ";
          oss << std::showbase << std::hex << this->op1;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::CDP::set_params(const unsigned& bitstring)
        throw() {

          this->cprn_bit = (bitstring & 0xf0000) >> 16;
          this->cprn.set_alias(CPREGS[this->cprn_bit]);
          this->cprm_bit = (bitstring & 0xf);
          this->cprm.set_alias(CPREGS[this->cprm_bit]);
          this->cprd_bit = (bitstring & 0xf000) >> 12;
          this->cprd.set_alias(CPREGS[this->cprd_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->op0 = (bitstring & 0xf00000) >> 20;
          this->cpnum = (bitstring & 0xf00) >> 8;
          this->op1 = (bitstring & 0xe0) >> 5;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::CDP::replicate(Instruction* instr)
        const throw() {

          CDP* new_instr = new CDP(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            CDP* old_instr = dynamic_cast<CDP*>(instr);
            if (old_instr) {
              new_instr->cprn_bit = old_instr->cprn_bit;
              new_instr->cprn.set_alias(CPREGS[new_instr->cprn_bit]);
              new_instr->cprm_bit = old_instr->cprm_bit;
              new_instr->cprm.set_alias(CPREGS[new_instr->cprm_bit]);
              new_instr->cprd_bit = old_instr->cprd_bit;
              new_instr->cprd.set_alias(CPREGS[new_instr->cprd_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->op0 = old_instr->op0;
              new_instr->cpnum = old_instr->cpnum;
              new_instr->op1 = old_instr->op1;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::CDP::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          THROW_WARNING("Unimplemented instruction CDP.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::LDC::LDC(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // LDC()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::LDC::get_id() const throw() {

          return 155;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::LDC::get_name() const throw() {

          return "LDC";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::LDC::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "LDC";
          switch(this->cond) {
            case 15: {
              oss << "2";
            break;}
          }
          oss << std::showbase << std::hex << this->cond;
          oss << " ";
          oss << std::showbase << std::hex << this->cpnum;
          oss << ", ";
          oss << std::dec << this->cprd_bit;
          oss << ", R";
          oss << std::dec << this->rn_bit;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::LDC::set_params(const unsigned& bitstring)
        throw() {

          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->cprd_bit = (bitstring & 0xf000) >> 12;
          this->cprd.set_alias(CPREGS[this->cprd_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->p = (bitstring & 0x1000000) >> 24;
          this->u = (bitstring & 0x800000) >> 23;
          this->d = (bitstring & 0x400000) >> 22;
          this->w = (bitstring & 0x200000) >> 21;
          this->cpnum = (bitstring & 0xf00) >> 8;
          this->imm = (bitstring & 0xff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::LDC::replicate(Instruction* instr)
        const throw() {

          LDC* new_instr = new LDC(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            LDC* old_instr = dynamic_cast<LDC*>(instr);
            if (old_instr) {
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->cprd_bit = old_instr->cprd_bit;
              new_instr->cprd.set_alias(CPREGS[new_instr->cprd_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->p = old_instr->p;
              new_instr->u = old_instr->u;
              new_instr->d = old_instr->d;
              new_instr->w = old_instr->w;
              new_instr->cpnum = old_instr->cpnum;
              new_instr->imm = old_instr->imm;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::LDC::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if ((rn_bit == 15) && (w || (!p && (CurrentInstrSet() != (unsigned)(ISMODE::ARM)))))
          THROW_EXCEPTION("Invalid LDC/LDC2 (literal) encoding: w = 1 or (p = 0 and current instruction set != ARM).");

          THROW_WARNING("Unimplemented instruction LDC.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::STC::STC(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // STC()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::STC::get_id() const throw() {

          return 156;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::STC::get_name() const throw() {

          return "STC";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::STC::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "STC";
          switch(this->cond) {
            case 15: {
              oss << "2";
            break;}
          }
          oss << std::showbase << std::hex << this->cond;
          oss << " ";
          oss << std::showbase << std::hex << this->cpnum;
          oss << ", ";
          oss << std::dec << this->cprd_bit;
          oss << ", R";
          oss << std::dec << this->rn_bit;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::STC::set_params(const unsigned& bitstring)
        throw() {

          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->cprd_bit = (bitstring & 0xf000) >> 12;
          this->cprd.set_alias(CPREGS[this->cprd_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->p = (bitstring & 0x1000000) >> 24;
          this->u = (bitstring & 0x800000) >> 23;
          this->d = (bitstring & 0x400000) >> 22;
          this->w = (bitstring & 0x200000) >> 21;
          this->cpnum = (bitstring & 0xf00) >> 8;
          this->imm = (bitstring & 0xff);
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::STC::replicate(Instruction* instr)
        const throw() {

          STC* new_instr = new STC(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            STC* old_instr = dynamic_cast<STC*>(instr);
            if (old_instr) {
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->cprd_bit = old_instr->cprd_bit;
              new_instr->cprd.set_alias(CPREGS[new_instr->cprd_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->p = old_instr->p;
              new_instr->u = old_instr->u;
              new_instr->d = old_instr->d;
              new_instr->w = old_instr->w;
              new_instr->cpnum = old_instr->cpnum;
              new_instr->imm = old_instr->imm;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::STC::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if ((rn_bit == 15) && (w || (CurrentInstrSet() != (unsigned)(ISMODE::ARM))))
          THROW_EXCEPTION("Invalid STC/STC2 encoding: rn = 0xF and (w = 1 or current instruction set != ARM).");

          THROW_WARNING("Unimplemented instruction STC.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::MCR::MCR(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // MCR()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MCR::get_id() const throw() {

          return 157;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MCR::get_name() const throw() {

          return "MCR";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MCR::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "MCR";
          switch(this->cond) {
            case 15: {
              oss << "2";
            break;}
          }
          oss << std::showbase << std::hex << this->cond;
          oss << " ";
          oss << std::showbase << std::hex << this->cpnum;
          oss << ", ";
          oss << std::showbase << std::hex << this->op1;
          oss << ", ";
          oss << std::dec << this->rd_bit;
          oss << ", ";
          oss << std::dec << this->rn_bit;
          oss << ", ";
          oss << std::dec << this->cprm_bit;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::MCR::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(CPREGS[this->rn_bit]);
          this->cprm_bit = (bitstring & 0xf);
          this->cprm.set_alias(CPREGS[this->cprm_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->op0 = (bitstring & 0xe00000) >> 21;
          this->cpnum = (bitstring & 0xf00) >> 8;
          this->op1 = (bitstring & 0xe0) >> 5;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::MCR::replicate(Instruction* instr)
        const throw() {

          MCR* new_instr = new MCR(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            MCR* old_instr = dynamic_cast<MCR*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(CPREGS[new_instr->rn_bit]);
              new_instr->cprm_bit = old_instr->cprm_bit;
              new_instr->cprm.set_alias(CPREGS[new_instr->cprm_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->op0 = old_instr->op0;
              new_instr->cpnum = old_instr->cpnum;
              new_instr->op1 = old_instr->op1;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MCR::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if (rd_bit == 15)
          THROW_EXCEPTION("Invalid MCR/MCR2 encoding: rd = 0xF.");

          if ((rd_bit == 13) && (CurrentInstrSet() != (unsigned)(ISMODE::ARM)))
          THROW_EXCEPTION("Invalid MCR/MCR2 encoding: rd = 0xD and current instruction set != ARM.");

          THROW_WARNING("Unimplemented instruction MCR.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::MCRR::MCRR(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // MCRR()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MCRR::get_id() const throw() {

          return 158;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MCRR::get_name() const throw() {

          return "MCRR";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MCRR::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "MCRR";
          switch(this->cond) {
            case 15: {
              oss << "2";
            break;}
          }
          oss << std::showbase << std::hex << this->cond;
          oss << " ";
          oss << std::showbase << std::hex << this->cpnum;
          oss << ", ";
          oss << std::showbase << std::hex << this->op1;
          oss << ", ";
          oss << std::dec << this->rd_bit;
          oss << ", ";
          oss << std::dec << this->rn_bit;
          oss << ", ";
          oss << std::dec << this->cprm_bit;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::MCRR::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->cprm_bit = (bitstring & 0xf);
          this->cprm.set_alias(CPREGS[this->cprm_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->cpnum = (bitstring & 0xf00) >> 8;
          this->op1 = (bitstring & 0xe0) >> 5;
          this->e = (bitstring & 0x10) >> 4;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::MCRR::replicate(Instruction*
        instr) const throw() {

          MCRR* new_instr = new MCRR(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            MCRR* old_instr = dynamic_cast<MCRR*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->cprm_bit = old_instr->cprm_bit;
              new_instr->cprm.set_alias(CPREGS[new_instr->cprm_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->cpnum = old_instr->cpnum;
              new_instr->op1 = old_instr->op1;
              new_instr->e = old_instr->e;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MCRR::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if ((rn_bit == 15) || (rd_bit == 15))
          THROW_EXCEPTION("Invalid MCRR/MCRR2 encoding: rn|rd = 0xF.");

          if (((rn_bit == 13) || (rd_bit == 13)) && (CurrentInstrSet() !=
          (unsigned)(ISMODE::ARM)))
          THROW_EXCEPTION("Invalid MCRR/MCRR2 encoding: rn|rd = 0xD and current instruction set != ARM.");

          THROW_WARNING("Unimplemented instruction MCRR.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::MRC::MRC(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // MRC()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MRC::get_id() const throw() {

          return 159;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MRC::get_name() const throw() {

          return "MRC";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MRC::get_mnemonic() const throw() {

          std::ostringstream oss (std::ostringstream::out);
          oss << "MRC";
          switch(this->cond) {
            case 15: {
              oss << "2";
            break;}
          }
          oss << std::showbase << std::hex << this->cond;
          oss << " ";
          oss << std::showbase << std::hex << this->cpnum;
          oss << ", ";
          oss << std::showbase << std::hex << this->op1;
          oss << ", ";
          oss << std::dec << this->rd_bit;
          oss << ", ";
          oss << std::dec << this->rn_bit;
          oss << ", ";
          oss << std::dec << this->cprm_bit;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::MRC::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(CPREGS[this->rn_bit]);
          this->cprm_bit = (bitstring & 0xf);
          this->cprm.set_alias(CPREGS[this->cprm_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->op0 = (bitstring & 0xe00000) >> 21;
          this->cpnum = (bitstring & 0xf00) >> 8;
          this->op1 = (bitstring & 0xe0) >> 5;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::MRC::replicate(Instruction* instr)
        const throw() {

          MRC* new_instr = new MRC(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            MRC* old_instr = dynamic_cast<MRC*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(CPREGS[new_instr->rn_bit]);
              new_instr->cprm_bit = old_instr->cprm_bit;
              new_instr->cprm.set_alias(CPREGS[new_instr->cprm_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->op0 = old_instr->op0;
              new_instr->cpnum = old_instr->cpnum;
              new_instr->op1 = old_instr->op1;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MRC::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if ((rd_bit == 13) && (CurrentInstrSet() != (unsigned)(ISMODE::ARM)))
          THROW_EXCEPTION("Invalid MRC/MRC2 encoding: rd = 0xD and current instruction set != ARM.");

          THROW_WARNING("Unimplemented instruction MRC.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::MRRC::MRRC(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory) :
          Instruction(R, instr_memory, data_memory),
          ConditionPassedOp(R, instr_memory, data_memory) {


        } // MRRC()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MRRC::get_id() const throw() {

          return 160;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MRRC::get_name() const throw() {

          return "MRRC";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::MRRC::get_mnemonic() const throw()
        {

          std::ostringstream oss (std::ostringstream::out);
          oss << "MRRC";
          switch(this->cond) {
            case 15: {
              oss << "2";
            break;}
          }
          oss << std::showbase << std::hex << this->cond;
          oss << " ";
          oss << std::showbase << std::hex << this->cpnum;
          oss << ", ";
          oss << std::showbase << std::hex << this->op1;
          oss << ", ";
          oss << std::dec << this->rd_bit;
          oss << ", ";
          oss << std::dec << this->rn_bit;
          oss << ", ";
          oss << std::dec << this->cprm_bit;
          return oss.str();
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        void core_armcortexa9_funclt::MRRC::set_params(const unsigned& bitstring)
        throw() {

          this->rd_bit = (bitstring & 0xf000) >> 12;
          this->rd.set_alias(REGS[this->rd_bit]);
          this->rn_bit = (bitstring & 0xf0000) >> 16;
          this->rn.set_alias(REGS[this->rn_bit]);
          this->cprm_bit = (bitstring & 0xf);
          this->cprm.set_alias(CPREGS[this->cprm_bit]);
          this->cond = (bitstring & 0xf0000000) >> 28;
          this->cpnum = (bitstring & 0xf00) >> 8;
          this->op1 = (bitstring & 0xe0) >> 5;
          this->e = (bitstring & 0x10) >> 4;
        } // set_params()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::MRRC::replicate(Instruction*
        instr) const throw() {

          MRRC* new_instr = new MRRC(R, instr_memory, data_memory);

          // Set instruction fields.
          if (instr) {
            MRRC* old_instr = dynamic_cast<MRRC*>(instr);
            if (old_instr) {
              new_instr->rd_bit = old_instr->rd_bit;
              new_instr->rd.set_alias(REGS[new_instr->rd_bit]);
              new_instr->rn_bit = old_instr->rn_bit;
              new_instr->rn.set_alias(REGS[new_instr->rn_bit]);
              new_instr->cprm_bit = old_instr->cprm_bit;
              new_instr->cprm.set_alias(CPREGS[new_instr->cprm_bit]);
              new_instr->cond = old_instr->cond;
              new_instr->cpnum = old_instr->cpnum;
              new_instr->op1 = old_instr->op1;
              new_instr->e = old_instr->e;
            }
          }
          return new_instr;
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::MRRC::behavior() {

          this->num_instr_cycles = 0;
          this->num_instr_cycles += ConditionPassed(this->cond);

          if ((rn_bit == 15) || (rd_bit == 15))
          THROW_EXCEPTION("Invalid MRRC/MRRC2 encoding: rn|rd = 0xF.");

          if (rn_bit == rd_bit)
          THROW_EXCEPTION("Invalid MRRC/MRRC2 encoding: rn = rd.");

          if (((rn_bit == 13) || (rd_bit == 13)) && (CurrentInstrSet() !=
          (unsigned)(ISMODE::ARM)))
          THROW_EXCEPTION("Invalid MRRC/MRRC2 encoding: rn|rd = 0xD and current instruction set != ARM.");

          THROW_WARNING("Unimplemented instruction MRRC.");
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::IRQIntrInstruction::IRQIntrInstruction(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory,
            bool& IRQ) :
          Instruction(R, instr_memory, data_memory),
          IRQ(IRQ) {


        } // IRQIntrInstruction()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::IRQIntrInstruction::get_id() const
        throw() {

          return (unsigned)-1;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::IRQIntrInstruction::get_name()
        const throw() {

          return "IRQIntrInstruction";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::IRQIntrInstruction::get_mnemonic()
        const throw() {

          return "IRQ";
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::IRQIntrInstruction::replicate(Instruction*
        instr) const throw() {

          return new IRQIntrInstruction(R, instr_memory, data_memory, this->IRQ);
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::IRQIntrInstruction::behavior() {

          this->num_instr_cycles = 0;
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

        core_armcortexa9_funclt::FIQIntrInstruction::FIQIntrInstruction(
            Registers& R,
            MemoryInterface& instr_memory,
            MemoryInterface& data_memory,
            bool& FIQ) :
          Instruction(R, instr_memory, data_memory),
          FIQ(FIQ) {


        } // FIQIntrInstruction()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::FIQIntrInstruction::get_id() const
        throw() {

          return (unsigned)-1;
        } // get_id()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::FIQIntrInstruction::get_name()
        const throw() {

          return "FIQIntrInstruction";
        } // get_name()

        // ---------------------------------------------------------------------

        std::string core_armcortexa9_funclt::FIQIntrInstruction::get_mnemonic()
        const throw() {

          return "FIQ";
        } // get_mnemonic()

        // ---------------------------------------------------------------------

        Instruction* core_armcortexa9_funclt::FIQIntrInstruction::replicate(Instruction*
        instr) const throw() {

          return new FIQIntrInstruction(R, instr_memory, data_memory, this->FIQ);
        } // replicate()

        // ---------------------------------------------------------------------

        unsigned core_armcortexa9_funclt::FIQIntrInstruction::behavior() {

          this->num_instr_cycles = 0;
          return this->num_instr_cycles;
        } // behavior()

        // ---------------------------------------------------------------------


        // *********************************************************************

