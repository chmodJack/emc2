/***************************************************************************//**
*
*           _/       _/_/_/      _/         _/
*         _/_/      _/    _/    _/_/      __/
*       _/  _/     _/    _/    _/ _/    _/_/
*     _/_/_/_/    _/_/_/      _/  _/  _/ _/
*   _/      _/   _/    _/    _/   _/_/  _/
* _/        _/  _/      _/  _/    _/   _/
*
* @brief    This file is part of the SoCRocket ARM ISS generated by TRAP.
* @details  This SystemC model was automatically generated by running
*           $ python ARMArch.py
*           Please refer to the ARM TRAP source files for documentation.
* @author   Lillian Tadros (TUDO ETIT IRF)
* @date     2014-12-01 tadros: Initial ARM Cortex A9 (ARMv7-A) version
*
*
* (c) 2014-2016
* Technische Universitaet Dortmund
* Institut fuer Roboterforschung
* Project Embedded Multi-Core Systems for Mixed Criticality
* Applications in Dynamic and Changeable Real-time Environments (EMC2)
*
*
* This file is part of ARMCortexA9.
*
* ARMCortexA9 is free software; you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License as
* published by the Free Software Foundation; either version 3 of the
* License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Affero General Public License for more details.
*
* You should have received a copy of the GNU Affero General Public
* License along with this program; if not, write to the
* Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
* or see <http://www.gnu.org/licenses/>.
*
*******************************************************************************/

#ifndef CORE_ARMCORTEXA9_FUNC_LT_INSTRUCTIONS_HPP
#define CORE_ARMCORTEXA9_FUNC_LT_INSTRUCTIONS_HPP

#include "arm/intunit/registers.hpp"
#include "arm/intunit/memory.hpp"

#include <modules/instruction.hpp>
#include <common/report.hpp>
#include <string>
#include <modules/register.hpp>
#include <systemc.h>
#include <sstream>


#define FUNC_MODEL
#define LT_IF


namespace core_armcortexa9_lt {

  /**
  * @brief Instruction Class
  *
  * All individual instructions derive from this class.
  */
  class Instruction : public InstructionBase {
    /// @name Constructors and Destructors
    /// @{

    public:
    Instruction(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~Instruction();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    void BranchWritePC(unsigned addr);
    void BXWritePC(unsigned addr);
    unsigned Rmode(
        unsigned reg_index, unsigned mode, bool write = false, unsigned value =
        0);
    bool valid_banked_reg_access(unsigned sys_mode);
    void update_alias(
        unsigned cur_mode, unsigned next_mode);
    int get_spsr_idx(unsigned mode);
    void restore_spsr();
    unsigned psr_mask(
        unsigned next_value, unsigned byte_mask, unsigned cur_mode, bool is_spsr,
        bool is_exception);
    unsigned CurrentInstrSet();
    bool valid_psr_mode(unsigned mode);
    void ITAdvance();
    bool InITBlock();
    bool LastInITBlock();
    void AddWithCarry(
        unsigned operand1, unsigned operand2, bool carry);
    void update_psr_sub(
        unsigned operand1, unsigned operand2, bool carry);
    void update_psr_bit(
        unsigned result, bool carry);
    unsigned sign_extend(
        unsigned bits, unsigned len_bits);
    unsigned LSL(
        unsigned to_shift, unsigned shift_amm, bool& carry);
    unsigned LSR(
        unsigned to_shift, unsigned shift_amm, bool& carry);
    unsigned ASR(
        unsigned to_shift, unsigned shift_amm, bool& carry);
    unsigned ROR(
        unsigned to_rotate, unsigned rotate_amm, bool& carry);
    unsigned RRX(
        unsigned to_rotate, bool carry_in, bool& carry);
    unsigned sat_q(
        int operand, unsigned saturate_to, bool is_signed, bool set_q_en);
    unsigned BitCount(unsigned operand);
    unsigned ExcVectorBase();
    bool HaveLPAE();
    bool HaveMPExt();
    bool HaveSecurityExt();
    bool HaveVirtExt();
    bool IsSecure();
    bool JazelleAcceptsExecution();
    virtual unsigned behavior() = 0;
    virtual Instruction* replicate() const throw() = 0;
    virtual void set_params(const unsigned& bitstring) throw() = 0;
    void print_trace();
    static inline void annul() {
      throw annul_exception();
    } // annul()

    static inline void flush() {

    } // flush()

    inline void stall(const unsigned& num_cycles) {
      this->total_instr_cycles += num_cycles;
    } // stall()


    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    public:
    Registers& R;
    LocalMemory& data_memory;
    unsigned& total_cycles;
    unsigned total_instr_cycles;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class Instruction

  /// **************************************************************************

  class InvalidInstr : public Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    InvalidInstr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~InvalidInstr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_name() const throw();
    std::string get_mnemonic() const throw();
    unsigned get_id() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------

  }; // class InvalidInstr

  /// **************************************************************************

  class UpdatePSRAddOp : public virtual Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    UpdatePSRAddOp(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    protected:
    unsigned UpdatePSRAdd(
        trap::RegisterAlias<unsigned>& rn, unsigned& rn_bit, trap::RegisterAlias<unsigned>& rd,
        unsigned& rd_bit, unsigned& s, unsigned& operand1, unsigned& operand2,
        bool& carry);

    /// @} Methods
    /// ------------------------------------------------------------------------

  }; // class UpdatePSRAddOp

  /// **************************************************************************

  class ConditionPassedOp : public virtual Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    ConditionPassedOp(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    protected:
    unsigned ConditionPassed(unsigned& cond);

    /// @} Methods
    /// ------------------------------------------------------------------------

  }; // class ConditionPassedOp

  /// **************************************************************************

  class ARMExpandImmOp : public virtual Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    ARMExpandImmOp(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    protected:
    unsigned ARMExpandImm(
        unsigned& rotate, unsigned& imm, unsigned& operand, bool& carry);

    /// @} Methods
    /// ------------------------------------------------------------------------

  }; // class ARMExpandImmOp

  /// **************************************************************************

  class DecodeImmShiftOp : public virtual Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    DecodeImmShiftOp(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    protected:
    unsigned DecodeImmShift(
        trap::RegisterAlias<unsigned>& rm, unsigned& rm_bit, unsigned& shift_amm,
        unsigned& shift_op, unsigned& operand, bool& carry);

    /// @} Methods
    /// ------------------------------------------------------------------------

  }; // class DecodeImmShiftOp

  /// **************************************************************************

  class DecodeRegShiftOp : public virtual Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    DecodeRegShiftOp(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    protected:
    unsigned DecodeRegShift(
        trap::RegisterAlias<unsigned>& rm, unsigned& rm_bit, trap::RegisterAlias<unsigned>& rs,
        unsigned& rs_bit, unsigned& shift_op, unsigned& operand, bool& carry);

    /// @} Methods
    /// ------------------------------------------------------------------------

  }; // class DecodeRegShiftOp

  /// **************************************************************************

  class UpdatePSRAddWithCarryOp : public virtual Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    UpdatePSRAddWithCarryOp(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    protected:
    unsigned UpdatePSRAddWithCarry(
        trap::RegisterAlias<unsigned>& rn, unsigned& rn_bit, trap::RegisterAlias<unsigned>& rd,
        unsigned& rd_bit, unsigned& s, unsigned& operand1, unsigned& operand2,
        bool& carry);

    /// @} Methods
    /// ------------------------------------------------------------------------

  }; // class UpdatePSRAddWithCarryOp

  /// **************************************************************************

  class UpdatePSRSubOp : public virtual Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    UpdatePSRSubOp(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    protected:
    unsigned UpdatePSRSub(
        trap::RegisterAlias<unsigned>& rn, unsigned& rn_bit, trap::RegisterAlias<unsigned>& rd,
        unsigned& rd_bit, unsigned& s, unsigned& operand1, unsigned& operand2,
        bool& carry);

    /// @} Methods
    /// ------------------------------------------------------------------------

  }; // class UpdatePSRSubOp

  /// **************************************************************************

  class UpdatePSRSubWithCarryOp : public virtual Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    UpdatePSRSubWithCarryOp(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    protected:
    unsigned UpdatePSRSubWithCarry(
        trap::RegisterAlias<unsigned>& rn, unsigned& rn_bit, trap::RegisterAlias<unsigned>& rd,
        unsigned& rd_bit, unsigned& s, unsigned& operand1, unsigned& operand2,
        bool& carry);

    /// @} Methods
    /// ------------------------------------------------------------------------

  }; // class UpdatePSRSubWithCarryOp

  /// **************************************************************************

  class UpdatePSRMulOp : public virtual Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    UpdatePSRMulOp(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    protected:
    unsigned UpdatePSRMul(
        unsigned& ss, unsigned& s, unsigned& l, sc_dt::uint64& result);

    /// @} Methods
    /// ------------------------------------------------------------------------

  }; // class UpdatePSRMulOp

  /// **************************************************************************

  class UpdatePSRBitOp : public virtual Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    UpdatePSRBitOp(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    protected:
    unsigned UpdatePSRBit(
        trap::RegisterAlias<unsigned>& rn, unsigned& rn_bit, trap::RegisterAlias<unsigned>& rd,
        unsigned& rd_bit, unsigned& s, unsigned& result, bool& carry);

    /// @} Methods
    /// ------------------------------------------------------------------------

  }; // class UpdatePSRBitOp

  /// **************************************************************************

  class LSOffsetOp : public virtual Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    LSOffsetOp(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    protected:
    unsigned LSOffset(
        trap::RegisterAlias<unsigned>& rn, unsigned& rn_bit, unsigned& p,
        unsigned& u, unsigned& w, unsigned& operand, unsigned& address);

    /// @} Methods
    /// ------------------------------------------------------------------------

  }; // class LSOffsetOp

  /// **************************************************************************

  class LSMReglistOp : public virtual Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    LSMReglistOp(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    protected:
    unsigned LSMReglist(
        trap::RegisterAlias<unsigned>& rn, unsigned& rn_bit, unsigned& p,
        unsigned& u, unsigned& reg_list, unsigned& start_address, unsigned&
        wb_address);

    /// @} Methods
    /// ------------------------------------------------------------------------

  }; // class LSMReglistOp

  /// **************************************************************************

  /**
  * @brief ADD/ADR
  *
  * Add adds a register value and either an immediate value, another register
  * value, or a shifted register value, and writes the result to the destination
  * register. It can optionally update the condition flags based on the result.
  * Address adds an immediate value to the PC value to form a PC-relative
  * address, and writes the result to the destination register.
  */
  class ADD_i : public UpdatePSRAddOp, public ConditionPassedOp, public ARMExpandImmOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    ADD_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~ADD_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand1;
    unsigned operand2;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned rotate;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class ADD_i

  /// **************************************************************************

  /**
  * @brief ADD/ADR
  *
  * Add adds a register value and either an immediate value, another register
  * value, or a shifted register value, and writes the result to the destination
  * register. It can optionally update the condition flags based on the result.
  * Address adds an immediate value to the PC value to form a PC-relative
  * address, and writes the result to the destination register.
  */
  class ADD_r : public UpdatePSRAddOp, public ConditionPassedOp, public DecodeImmShiftOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    ADD_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~ADD_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand1;
    unsigned operand2;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class ADD_r

  /// **************************************************************************

  /**
  * @brief ADD/ADR
  *
  * Add adds a register value and either an immediate value, another register
  * value, or a shifted register value, and writes the result to the destination
  * register. It can optionally update the condition flags based on the result.
  * Address adds an immediate value to the PC value to form a PC-relative
  * address, and writes the result to the destination register.
  */
  class ADD_sr : public DecodeRegShiftOp, public UpdatePSRAddOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    ADD_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~ADD_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned operand1;
    unsigned operand2;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class ADD_sr

  /// **************************************************************************

  /**
  * @brief ADC
  *
  * Add with Carry adds a register value, the carry flag and either an immediate
  * value, another register value, or a shifted register value, and writes the
  * result to the destination register. It can optionally update the condition
  * flags based on the result. Used to synthesize multi-word addition. If R0/R1,
  * and R2/R3 hold 64-bit values, with R0 and R2 holding the LSWs, the 64-bit
  * sum will be written to R4/R5:
  * ADDS R4, R0, R2
  * ADC R5, R1, R3
  * 
  */
  class ADC_i : public UpdatePSRAddWithCarryOp, public ConditionPassedOp, public
  ARMExpandImmOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    ADC_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~ADC_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand1;
    unsigned operand2;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned rotate;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class ADC_i

  /// **************************************************************************

  /**
  * @brief ADC
  *
  * Add with Carry adds a register value, the carry flag and either an immediate
  * value, another register value, or a shifted register value, and writes the
  * result to the destination register. It can optionally update the condition
  * flags based on the result. Used to synthesize multi-word addition. If R0/R1,
  * and R2/R3 hold 64-bit values, with R0 and R2 holding the LSWs, the 64-bit
  * sum will be written to R4/R5:
  * ADDS R4, R0, R2
  * ADC R5, R1, R3
  * 
  */
  class ADC_r : public UpdatePSRAddWithCarryOp, public ConditionPassedOp, public
  DecodeImmShiftOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    ADC_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~ADC_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand1;
    unsigned operand2;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class ADC_r

  /// **************************************************************************

  /**
  * @brief ADC
  *
  * Add with Carry adds a register value, the carry flag and either an immediate
  * value, another register value, or a shifted register value, and writes the
  * result to the destination register. It can optionally update the condition
  * flags based on the result. Used to synthesize multi-word addition. If R0/R1,
  * and R2/R3 hold 64-bit values, with R0 and R2 holding the LSWs, the 64-bit
  * sum will be written to R4/R5:
  * ADDS R4, R0, R2
  * ADC R5, R1, R3
  * 
  */
  class ADC_sr : public DecodeRegShiftOp, public UpdatePSRAddWithCarryOp, public
  ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    ADC_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~ADC_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned operand1;
    unsigned operand2;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class ADC_sr

  /// **************************************************************************

  /**
  * @brief SUB/ADR
  *
  * Subtract subtracts either an immediate value, a register value, or a shifted
  * register value from a register value, and writes the result to the destination
  * register. It can optionally update the condition flags based on the result.
  * Address adds an immediate value to the PC value to form a PC-relative
  * address, and writes the result to the destination register.
  */
  class SUB_i : public UpdatePSRSubOp, public ConditionPassedOp, public ARMExpandImmOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    SUB_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~SUB_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand1;
    unsigned operand2;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned rotate;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class SUB_i

  /// **************************************************************************

  /**
  * @brief SUB/ADR
  *
  * Subtract subtracts either an immediate value, a register value, or a shifted
  * register value from a register value, and writes the result to the destination
  * register. It can optionally update the condition flags based on the result.
  * Address adds an immediate value to the PC value to form a PC-relative
  * address, and writes the result to the destination register.
  */
  class SUB_r : public UpdatePSRSubOp, public ConditionPassedOp, public DecodeImmShiftOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    SUB_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~SUB_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand1;
    unsigned operand2;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class SUB_r

  /// **************************************************************************

  /**
  * @brief SUB/ADR
  *
  * Subtract subtracts either an immediate value, a register value, or a shifted
  * register value from a register value, and writes the result to the destination
  * register. It can optionally update the condition flags based on the result.
  * Address adds an immediate value to the PC value to form a PC-relative
  * address, and writes the result to the destination register.
  */
  class SUB_sr : public DecodeRegShiftOp, public UpdatePSRSubOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    SUB_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~SUB_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned operand1;
    unsigned operand2;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class SUB_sr

  /// **************************************************************************

  /**
  * @brief SBC
  *
  * Subtract with Carry subtracts the NOT(carry) flag and either an immediate
  * value, a register value, or a shifted register value from a register value,
  * and writes the result to the destination register. It can optionally update
  * the condition flags based on the result.
  */
  class SBC_i : public UpdatePSRSubWithCarryOp, public ConditionPassedOp, public
  ARMExpandImmOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    SBC_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~SBC_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand1;
    unsigned operand2;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned rotate;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class SBC_i

  /// **************************************************************************

  /**
  * @brief SBC
  *
  * Subtract with Carry subtracts the NOT(carry) flag and either an immediate
  * value, a register value, or a shifted register value from a register value,
  * and writes the result to the destination register. It can optionally update
  * the condition flags based on the result.
  */
  class SBC_r : public UpdatePSRSubWithCarryOp, public ConditionPassedOp, public
  DecodeImmShiftOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    SBC_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~SBC_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand1;
    unsigned operand2;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class SBC_r

  /// **************************************************************************

  /**
  * @brief SBC
  *
  * Subtract with Carry subtracts the NOT(carry) flag and either an immediate
  * value, a register value, or a shifted register value from a register value,
  * and writes the result to the destination register. It can optionally update
  * the condition flags based on the result.
  */
  class SBC_sr : public DecodeRegShiftOp, public UpdatePSRSubWithCarryOp, public
  ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    SBC_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~SBC_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned operand1;
    unsigned operand2;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class SBC_sr

  /// **************************************************************************

  /**
  * @brief RSB
  *
  * Reverse Subtract subtracts a register value from either an immediate value,
  * another register value, or a shifted register value, and writes the result
  * to the destination register. It can optionally update the condition flags
  * based on the result.
  */
  class RSB_i : public UpdatePSRSubOp, public ConditionPassedOp, public ARMExpandImmOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    RSB_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~RSB_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand1;
    unsigned operand2;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned rotate;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class RSB_i

  /// **************************************************************************

  /**
  * @brief RSB
  *
  * Reverse Subtract subtracts a register value from either an immediate value,
  * another register value, or a shifted register value, and writes the result
  * to the destination register. It can optionally update the condition flags
  * based on the result.
  */
  class RSB_r : public UpdatePSRSubOp, public ConditionPassedOp, public DecodeImmShiftOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    RSB_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~RSB_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand1;
    unsigned operand2;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class RSB_r

  /// **************************************************************************

  /**
  * @brief RSB
  *
  * Reverse Subtract subtracts a register value from either an immediate value,
  * another register value, or a shifted register value, and writes the result
  * to the destination register. It can optionally update the condition flags
  * based on the result.
  */
  class RSB_sr : public DecodeRegShiftOp, public UpdatePSRSubOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    RSB_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~RSB_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned operand1;
    unsigned operand2;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class RSB_sr

  /// **************************************************************************

  /**
  * @brief RSC
  *
  * Reverse Subtract with Carry subtracts a register value and the NOT(carry)
  * flag from either an immediate value, a register value, or a shifted register
  * value, and writes the result to the destination register. It can optionally
  * update the condition flags based on the result.
  */
  class RSC_i : public UpdatePSRSubWithCarryOp, public ConditionPassedOp, public
  ARMExpandImmOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    RSC_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~RSC_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand1;
    unsigned operand2;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned rotate;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class RSC_i

  /// **************************************************************************

  /**
  * @brief RSC
  *
  * Reverse Subtract with Carry subtracts a register value and the NOT(carry)
  * flag from either an immediate value, a register value, or a shifted register
  * value, and writes the result to the destination register. It can optionally
  * update the condition flags based on the result.
  */
  class RSC_r : public UpdatePSRSubWithCarryOp, public ConditionPassedOp, public
  DecodeImmShiftOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    RSC_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~RSC_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand1;
    unsigned operand2;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class RSC_r

  /// **************************************************************************

  /**
  * @brief RSC
  *
  * Reverse Subtract with Carry subtracts a register value and the NOT(carry)
  * flag from either an immediate value, a register value, or a shifted register
  * value, and writes the result to the destination register. It can optionally
  * update the condition flags based on the result.
  */
  class RSC_sr : public DecodeRegShiftOp, public UpdatePSRSubWithCarryOp, public
  ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    RSC_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~RSC_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned operand1;
    unsigned operand2;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class RSC_sr

  /// **************************************************************************

  /**
  * @brief UADD16/SADD16/UHADD16/SHADD16/UQADD16/QADD16/UADD8/SADD8/UHADD8/SHADD8/UQADD8/QADD8
  *
  * Unsigned/Signed (Halving/Saturating) Add 16/8 performs two/four unsigned/signed
  * 16-bit/8-bit integer additions, (halves the results/saturates the results,)
  * and writes the results to the destination register. The non-halving, non-saturating
  * variant sets the ASPR.GE flag based on the results.
  * I summed up 12 instructions in one for efficiency. To avoid nesting ifs I
  * tried to keep the choices orthogonal - at the price of more complex code.
  */
  class USHQADD : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    USHQADD(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~USHQADD();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned u;
    unsigned h;
    unsigned nq;
    unsigned b;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class USHQADD

  /// **************************************************************************

  /**
  * @brief USUB16/SSUB16/UHSUB16/SHSUB16/UQSUB16/QSUB16/USUB8/SSUB8/UHSUB8/SHSUB8/UQSUB8/QSUB8
  *
  * Unsigned/Signed (Halving/Saturating) Subtract 16/8 performs two/four unsigned/signed
  * 16-bit/8-bit integer subtractions, (halves the results/saturates the results,)
  * and writes the results to the destination register. The non-halving, non-saturating
  * variant sets the ASPR.GE flag based on the results.
  * I summed up 12 instructions in one for efficiency. To avoid nesting ifs I
  * tried to keep the choices orthogonal - at the price of more complex code.
  * NOTE: I would've liked to merge the ADD and SUB variants, but the instruction
  * format does not allow that.
  */
  class USHQSUB : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    USHQSUB(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~USHQSUB();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned u;
    unsigned h;
    unsigned nq;
    unsigned b;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class USHQSUB

  /// **************************************************************************

  /**
  * @brief USAD8/USADA8
  *
  * Unsigned Sum of Absolute Differences performs four unsigned 8-bit subtractions,
  * and adds the absolute values of the differences together.
  * I summed up both instructions in one for efficiency.
  */
  class USADA8 : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    USADA8(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~USADA8();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> ra;
    unsigned ra_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class USADA8

  /// **************************************************************************

  /**
  * @brief UXTH/SXTH/UXTAH/SXTAH/UXTB16/SXTB16/UXTAB16/SXTAB16/UXTB/SXTB/UXTAB/SXTAB
  *
  * Unsigned/Signed Extend (and Add) Halfword/Byte extracts one/two 16-bit/8-bit
  * values from a register, zero-/sign-extends them to 32-bits/16-bits each,
  * (adds the results to two 32-bit/16-bit values from another register,) and
  * writes the results to the destination register. The instruction can specify
  * a rotation by 0, 8, 16, or 24 bits before extracting the 16-bit/8-bit
  * values.
  * I summed up 12 instructions in one for efficiency.
  */
  class USXTAHB : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    USXTAHB(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~USXTAHB();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned u;
    unsigned w;
    unsigned h;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class USXTAHB

  /// **************************************************************************

  /**
  * @brief UASX/SASX/UHASX/SHASX/UQASX/QASX
  *
  * Unsigned/Signed (Halving/Saturating) Add and Subtract with Exchange exchanges
  * the two half-words of the second operand, performs one unsigned/signed
  * 16-bit integer addition and one unsigned/signed 16-bit subtraction, (halves
  * the results/saturates the results to the 16-bit unsigned/signed integer
  * range, ) and writes the results to the destination register.
  * I summed up 6 instructions in one for efficiency.
  */
  class USHQASX : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    USHQASX(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~USHQASX();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned u;
    unsigned h;
    unsigned nq;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class USHQASX

  /// **************************************************************************

  /**
  * @brief USAX/SSAX/UHSAX/SHSAX/UQSAX/QSAX
  *
  * Unsigned/Signed (Halving) Subtract and Add with Exchange exchanges the two
  * half-words of the second operand, performs one unsigned/signed 16-bit
  * integer subtraction and one unsigned/signed 16-bit addition, (halves the
  * results/saturates the results to the 16-bit unsigned/signed integer range, )
  * and writes the results to the destination register.
  * I summed up 6 instructions in one for efficiency.
  */
  class USHQSAX : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    USHQSAX(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~USHQSAX();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned u;
    unsigned h;
    unsigned nq;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class USHQSAX

  /// **************************************************************************

  /**
  * @brief USAT/SSAT
  *
  * Unsigned/Signed Saturate saturates an optionally-shifted signed value to a
  * selected unsigned/signed range. The Q flag is set if the operation saturates.
  * I summed up 2 instructions in one for efficiency.
  */
  class USSAT : public DecodeImmShiftOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    USSAT(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~USSAT();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned shift_amm;
    unsigned shift_op;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    unsigned cond;
    unsigned u;
    unsigned imm0;
    unsigned imm1;
    unsigned op1a;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class USSAT

  /// **************************************************************************

  /**
  * @brief USAT16/SSAT16
  *
  * Unsigned/Signed Saturate 16 saturates two signed 16-bit values to a selected
  * unsigned/signed range. The Q flag is set if the operation saturates.
  * I summed up 2 instructions in one for efficiency.
  */
  class USSAT16 : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    USSAT16(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~USSAT16();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned u;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class USSAT16

  /// **************************************************************************

  /**
  * @brief QADD/QDADD/QSUB/QDSUB
  *
  * Saturating (Double and) Add/Subtract adds/subtracts a (doubled) register
  * value and/from another register value, and writes the result to the destination
  * register. (Both the doubling and) the addition/subtraction has its/have
  * their result(s) saturated to the 32-bit signed integer range. The Q flag is
  * set if (either of) the operation(s) saturate(s).
  * I summed up 4 instructions in one for efficiency.
  */
  class QDADDSUB : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    QDADDSUB(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~QDADDSUB();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned d;
    unsigned s;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class QDADDSUB

  /// **************************************************************************

  /**
  * @brief MUL/MLA/MLS: 32 = (32 +/-) 32 x 32
  *
  * Multiply (Accumulate/Subtract) multiplies two register values, (and adds/subtracts
  * the product from a third register value). The least significant 32 bits of
  * the result are written to the destination register. These 32 bits do not
  * depend on whether the source register values are considered to be signed
  * values or unsigned values. MUL/MLA can optionally update the condition flags
  * based on the result.
  * I summed up 3 instructions in one for efficiency.
  */
  class MUL : public UpdatePSRMulOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    MUL(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~MUL();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    sc_dt::uint64 result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> ra;
    unsigned ra_bit;
    unsigned cond;
    unsigned l;
    unsigned ss;
    unsigned a;
    unsigned s;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class MUL

  /// **************************************************************************

  /**
  * @brief SMMUL/SMMLA/SMMLS: 32 = (32 +/-) 32 x 32
  *
  * Signed Most Significant Word Multiply (Accumulate/Subtract) multiplies two
  * signed 32-bit values, (and adds/subtracts the product from a third register
  * value). The most significant 32 bits of the result are written to the
  * destination register. Optionally, the instruction can specify that the
  * result is rounded instead of being truncated. In this case, the const
  * 0x80000000 is added to the product before the high word is extracted.
  * I summed up 3 instructions in one for efficiency.
  */
  class SMMUL : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    SMMUL(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~SMMUL();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> ra;
    unsigned ra_bit;
    unsigned cond;
    unsigned op1a;
    unsigned op1b;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class SMMUL

  /// **************************************************************************

  /**
  * @brief UMULL/SMULL/UMLAL/SMLAL
  *
  * UMULL/SMULL: 64 = 32 x 32
  * Unsigned/Signed Multiply Long multiplies two unsigned/signed 32-bit values
  * to produce a 64-bit result. It can optionally update the condition flags
  * based on the result.
  * UMLAL/SMLAL: 64 = 64 + 32 x 32
  * Unsigned/Signed Multiply Accumulate Long multiplinties two unsigned/signed
  * 32-bit values, and accumulates the product with a 64-bit value to produce a
  * 64-bit result. It can optionally update the condition flags based on the
  * result.
  * I summed up 4 instructions in one for efficiency.
  */
  class MULL : public UpdatePSRMulOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    MULL(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~MULL();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    sc_dt::uint64 result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> ra;
    unsigned ra_bit;
    unsigned cond;
    unsigned l;
    unsigned ss;
    unsigned a;
    unsigned s;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class MULL

  /// **************************************************************************

  /**
  * @brief UMAAL: 64 = 32 + 32 + 32 x 32
  *
  * Unsigned Multiply Accumulate Accumulate Long multiplies two unsigned 32-bit
  * values, accumulates the product with two 32-bit values, and writes the
  * 64-bit result to two registers.
  */
  class UMAAL : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    UMAAL(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~UMAAL();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> ra;
    unsigned ra_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class UMAAL

  /// **************************************************************************

  /**
  * @brief SMULxx/SMLAxx/SMLALxx/SMULWx/SMLAWx
  *
  * SMULxx/SMLAxx/SMLALxx: 32/64 = (32/64 +) 16 x 16
  * Signed Multiply (Accumulate/Accumulate Long) half-words multiplies two
  * signed 16-bit values taken from either the bottom half or the top half of
  * their respective source registers. The other halves of these source registers
  * are ignored. The 32-bit product is ((sign-extended to 64-bits and) added to
  * a 32-bit/64-bit accumulate value and the result is) written to the/two
  * destination register(s).
  * No overflow is possible during the SMULxx instruction.
  * Overflow is possible during the SMLAxx instruction, but only as a result of
  * the 32-bit addition. The Q flag is set if overflow occurs.
  * Overflow is possible during the SMLALxx instruction, but only as a result of
  * the 64-bit addition. This overflow is not detected if it occurs. Instead,
  * the result wraps around modulo 2^64.
  * SMULWx/SMLAWx: 32 = (32 +) 32 x 16
  * Signed Multiply (Accumulate) word by half-word multiplies a signed 32-bit
  * value and a signed 16-bit value taken from either the bottom half or the top
  * half of its source register. The other half of the second source register is
  * ignored. The most-significant 32 bits of the 48-bit product are (added to a
  * 32-bit accumulate value and the result is) written to the destination
  * register. The least-significant 16 bits of the 48-bit product are ignored.
  * No overflow is possible during the SMULWx instruction.
  * Overflow is possible during the SMLAWx instruction, but only as a result of
  * the 32-bit addition. The Q flag is set if overflow occurs.
  * I summed up 5 instructions in one for efficiency.
  */
  class SMULBW : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    SMULBW(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~SMULBW();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> ra;
    unsigned ra_bit;
    unsigned cond;
    unsigned op0;
    unsigned m;
    unsigned n;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class SMULBW

  /// **************************************************************************

  /**
  * @brief SMUAD/SMUSD/SMLAD/SMLSD/SMLALD/SMLSLD: 32/64 = (32/64 +) 16 x 16 +/-
  *        16 x 16
  *
  * Signed Dual Multiply (Accumulate) Add/Subtract half-words multiplies two
  * signed 16-bit values taken from either the bottom half or the top half of
  * their respective source registers. The other halves of these source registers
  * are ignored. The 32-bit product is ((sign-extended to 64-bits and) added to/
  * subtracted from a 32-bit/64-bit accumulate value and the result is) written
  * to the/two destination register(s).
  * Overflow is possible during the SMUxD/SMLxD instructions, but only as a
  * result of the 32-bit addition. The Q flag is set if overflow occurs.
  * Overflow is possible during the SMLxLD instruction, but only as a result of
  * the 64-bit addition. This overflow is not detected if it occurs. Instead,
  * the result wraps around modulo 2^64.
  * I summed up 6 instructions in one for efficiency.
  */
  class SMMULD : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    SMMULD(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~SMMULD();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> ra;
    unsigned ra_bit;
    unsigned cond;
    unsigned l;
    unsigned op1a;
    unsigned op1b;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class SMMULD

  /// **************************************************************************

  /**
  * @brief UDIV/SDIV
  *
  * Unsigned/Signed Divide divides a 32-bit unsigned/signed register value by a
  * 32-bit unsigned/signed register value, and writes the result to the destination
  * register.
  * I summed up 2 instructions in one for efficiency.
  */
  class DIV : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    DIV(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~DIV();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> ra;
    unsigned ra_bit;
    unsigned cond;
    unsigned s;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class DIV

  /// **************************************************************************

  /**
  * @brief AND
  *
  * And performs a bitwise AND of a register value and either an immediate
  * value, another register value, or a shifted register value, and writes the
  * result to the destination register. It can optionally update the condition
  * flags based on the results.
  */
  class AND_i : public UpdatePSRBitOp, public ConditionPassedOp, public ARMExpandImmOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    AND_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~AND_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned result;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned rotate;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class AND_i

  /// **************************************************************************

  /**
  * @brief AND
  *
  * And performs a bitwise AND of a register value and either an immediate
  * value, another register value, or a shifted register value, and writes the
  * result to the destination register. It can optionally update the condition
  * flags based on the results.
  */
  class AND_r : public UpdatePSRBitOp, public ConditionPassedOp, public DecodeImmShiftOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    AND_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~AND_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned result;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class AND_r

  /// **************************************************************************

  /**
  * @brief AND
  *
  * And performs a bitwise AND of a register value and either an immediate
  * value, another register value, or a shifted register value, and writes the
  * result to the destination register. It can optionally update the condition
  * flags based on the results.
  */
  class AND_sr : public DecodeRegShiftOp, public UpdatePSRBitOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    AND_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~AND_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class AND_sr

  /// **************************************************************************

  /**
  * @brief EOR
  *
  * Bitwise Exclusive OR performs a bitwise XOR of a register value and either
  * an immediate value, another register value, or a shifted register value, and
  * writes the result to the destination register. It can optionally update the
  * condition flags based on the result.
  */
  class EOR_i : public UpdatePSRBitOp, public ConditionPassedOp, public ARMExpandImmOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    EOR_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~EOR_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned result;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned rotate;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class EOR_i

  /// **************************************************************************

  /**
  * @brief EOR
  *
  * Bitwise Exclusive OR performs a bitwise XOR of a register value and either
  * an immediate value, another register value, or a shifted register value, and
  * writes the result to the destination register. It can optionally update the
  * condition flags based on the result.
  */
  class EOR_r : public UpdatePSRBitOp, public ConditionPassedOp, public DecodeImmShiftOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    EOR_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~EOR_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned result;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class EOR_r

  /// **************************************************************************

  /**
  * @brief EOR
  *
  * Bitwise Exclusive OR performs a bitwise XOR of a register value and either
  * an immediate value, another register value, or a shifted register value, and
  * writes the result to the destination register. It can optionally update the
  * condition flags based on the result.
  */
  class EOR_sr : public DecodeRegShiftOp, public UpdatePSRBitOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    EOR_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~EOR_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class EOR_sr

  /// **************************************************************************

  /**
  * @brief MVN
  *
  * Not writes the bitwise inverse of either an immediate value, a register
  * value, or a shifted register value, and writes the result to the destination
  * register. It can optionally update the condition flags based on the result.
  */
  class MVN_i : public ARMExpandImmOp, public UpdatePSRBitOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    MVN_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~MVN_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned rotate;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class MVN_i

  /// **************************************************************************

  /**
  * @brief MVN
  *
  * Not writes the bitwise inverse of either an immediate value, a register
  * value, or a shifted register value, and writes the result to the destination
  * register. It can optionally update the condition flags based on the result.
  */
  class MVN_r : public DecodeImmShiftOp, public UpdatePSRBitOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    MVN_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~MVN_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class MVN_r

  /// **************************************************************************

  /**
  * @brief MVN
  *
  * Not writes the bitwise inverse of either an immediate value, a register
  * value, or a shifted register value, and writes the result to the destination
  * register. It can optionally update the condition flags based on the result.
  */
  class MVN_sr : public DecodeRegShiftOp, public UpdatePSRBitOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    MVN_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~MVN_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class MVN_sr

  /// **************************************************************************

  /**
  * @brief ORR
  *
  * Or performs a bitwise OR of a register value and either an immediate value,
  * another register value, or a shifted register value, and writes the result
  * to the destination register. It can optionally update the condition flags
  * based on the result.
  */
  class ORR_i : public UpdatePSRBitOp, public ConditionPassedOp, public ARMExpandImmOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    ORR_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~ORR_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned result;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned rotate;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class ORR_i

  /// **************************************************************************

  /**
  * @brief ORR
  *
  * Or performs a bitwise OR of a register value and either an immediate value,
  * another register value, or a shifted register value, and writes the result
  * to the destination register. It can optionally update the condition flags
  * based on the result.
  */
  class ORR_r : public UpdatePSRBitOp, public ConditionPassedOp, public DecodeImmShiftOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    ORR_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~ORR_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned result;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class ORR_r

  /// **************************************************************************

  /**
  * @brief ORR
  *
  * Or performs a bitwise OR of a register value and either an immediate value,
  * another register value, or a shifted register value, and writes the result
  * to the destination register. It can optionally update the condition flags
  * based on the result.
  */
  class ORR_sr : public DecodeRegShiftOp, public UpdatePSRBitOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    ORR_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~ORR_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class ORR_sr

  /// **************************************************************************

  /**
  * @brief TEQ
  *
  * Test Equivalence performs a bitwise XOR of a register value and either an
  * immediate value, another register value, or a shifted register value. It
  * updates the condition flags based on the result, and discards the result.
  */
  class TEQ_i : public ARMExpandImmOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    TEQ_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~TEQ_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned rotate;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class TEQ_i

  /// **************************************************************************

  /**
  * @brief TEQ
  *
  * Test Equivalence performs a bitwise XOR of a register value and either an
  * immediate value, another register value, or a shifted register value. It
  * updates the condition flags based on the result, and discards the result.
  */
  class TEQ_r : public DecodeImmShiftOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    TEQ_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~TEQ_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class TEQ_r

  /// **************************************************************************

  /**
  * @brief TEQ
  *
  * Test Equivalence performs a bitwise XOR of a register value and either an
  * immediate value, another register value, or a shifted register value. It
  * updates the condition flags based on the result, and discards the result.
  */
  class TEQ_sr : public DecodeRegShiftOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    TEQ_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~TEQ_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class TEQ_sr

  /// **************************************************************************

  /**
  * @brief TST
  *
  * Test performs a bitwise AND of a register value and either an immediate
  * value, another register value, or a shifted register value. It updates the
  * condition flags based on the result, and discards the result.
  */
  class TST_i : public ARMExpandImmOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    TST_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~TST_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned rotate;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class TST_i

  /// **************************************************************************

  /**
  * @brief TST
  *
  * Test performs a bitwise AND of a register value and either an immediate
  * value, another register value, or a shifted register value. It updates the
  * condition flags based on the result, and discards the result.
  */
  class TST_r : public DecodeImmShiftOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    TST_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~TST_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class TST_r

  /// **************************************************************************

  /**
  * @brief TST
  *
  * Test performs a bitwise AND of a register value and either an immediate
  * value, another register value, or a shifted register value. It updates the
  * condition flags based on the result, and discards the result.
  */
  class TST_sr : public DecodeRegShiftOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    TST_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~TST_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class TST_sr

  /// **************************************************************************

  /**
  * @brief ASR
  *
  * Arithmetic Shift Right shifts a register value right by an immediate number
  * of bits or a value specified in a register, shifting in copies of its sign
  * bit, and writes the result to the destination register. It can optionally
  * update update the condition flags based on the result.
  */
  class ASR_r : public DecodeImmShiftOp, public UpdatePSRBitOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    ASR_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~ASR_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class ASR_r

  /// **************************************************************************

  /**
  * @brief ASR
  *
  * Arithmetic Shift Right shifts a register value right by an immediate number
  * of bits or a value specified in a register, shifting in copies of its sign
  * bit, and writes the result to the destination register. It can optionally
  * update update the condition flags based on the result.
  */
  class ASR_sr : public DecodeRegShiftOp, public UpdatePSRBitOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    ASR_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~ASR_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class ASR_sr

  /// **************************************************************************

  /**
  * @brief LSR
  *
  * Logical Shift Right shifts a register value right by an immediate number of
  * bits or a value specified in a register, shifting in zeros, and writes the
  * result to the destination register. It can optionally update the condition
  * flags based on the result.
  */
  class LSR_r : public DecodeImmShiftOp, public UpdatePSRBitOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    LSR_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LSR_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LSR_r

  /// **************************************************************************

  /**
  * @brief LSR
  *
  * Logical Shift Right shifts a register value right by an immediate number of
  * bits or a value specified in a register, shifting in zeros, and writes the
  * result to the destination register. It can optionally update the condition
  * flags based on the result.
  */
  class LSR_sr : public DecodeRegShiftOp, public UpdatePSRBitOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    LSR_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LSR_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LSR_sr

  /// **************************************************************************

  /**
  * @brief LSL
  *
  * Logical Shift Left shifts a register value right by an immediate number of
  * bits or a value specified in a register, shifting in zeros, and writes the
  * result to the destination register. It can optionally update the condition
  * flags based on the result.
  */
  class LSL_r : public DecodeImmShiftOp, public UpdatePSRBitOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    LSL_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LSL_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LSL_r

  /// **************************************************************************

  /**
  * @brief LSL
  *
  * Logical Shift Left shifts a register value right by an immediate number of
  * bits or a value specified in a register, shifting in zeros, and writes the
  * result to the destination register. It can optionally update the condition
  * flags based on the result.
  */
  class LSL_sr : public DecodeRegShiftOp, public UpdatePSRBitOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    LSL_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LSL_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LSL_sr

  /// **************************************************************************

  /**
  * @brief ROR/RRX
  *
  * Rotate Right rotates a register value by an immediate number of bits or a
  * value specified in a register. The bits that are rotated off the right end
  * are inserted into the vacated bit positions on the left, and the result is
  * written to the destination register. It can optionally update the condition
  * flags based on the result.
  */
  class ROR_r : public DecodeImmShiftOp, public UpdatePSRBitOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    ROR_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~ROR_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class ROR_r

  /// **************************************************************************

  /**
  * @brief ROR/RRX
  *
  * Rotate Right rotates a register value by an immediate number of bits or a
  * value specified in a register. The bits that are rotated off the right end
  * are inserted into the vacated bit positions on the left, and the result is
  * written to the destination register. It can optionally update the condition
  * flags based on the result.
  */
  class ROR_sr : public DecodeRegShiftOp, public UpdatePSRBitOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    ROR_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~ROR_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class ROR_sr

  /// **************************************************************************

  /**
  * @brief BFC/BFI
  *
  * Bit Field Clear clears any number of adjacent bits at any position in a
  * register without affecting other bits. Bit Field Insert copies any number of
  * adjacent bits at any position in a register into the same number of adjacent
  * bits at any position in the destination register.
  */
  class BFCI : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    BFCI(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~BFCI();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    unsigned cond;
    unsigned imm0;
    unsigned imm1;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class BFCI

  /// **************************************************************************

  /**
  * @brief BIC
  *
  * Bitwise Bit Clear performs a bitwise AND of a register value and the complement
  * of an immediate value, and writes the result to the destination register. It
  * can optionally update the condition flags based on the result.
  */
  class BIC_i : public UpdatePSRBitOp, public ConditionPassedOp, public ARMExpandImmOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    BIC_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~BIC_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned result;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned rotate;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class BIC_i

  /// **************************************************************************

  /**
  * @brief BIC
  *
  * Bitwise Bit Clear performs a bitwise AND of a register value and the complement
  * of an immediate value, and writes the result to the destination register. It
  * can optionally update the condition flags based on the result.
  */
  class BIC_r : public UpdatePSRBitOp, public ConditionPassedOp, public DecodeImmShiftOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    BIC_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~BIC_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned result;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class BIC_r

  /// **************************************************************************

  /**
  * @brief BIC
  *
  * Bitwise Bit Clear performs a bitwise AND of a register value and the complement
  * of an immediate value, and writes the result to the destination register. It
  * can optionally update the condition flags based on the result.
  */
  class BIC_sr : public DecodeRegShiftOp, public UpdatePSRBitOp, public ConditionPassedOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    BIC_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~BIC_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned result;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned s;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class BIC_sr

  /// **************************************************************************

  /**
  * @brief CLZ
  *
  * Count Leading Zeros returns the number of binary zero bits before the first
  * binary one bit in a value.
  */
  class CLZ : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    CLZ(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~CLZ();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class CLZ

  /// **************************************************************************

  /**
  * @brief PKH
  *
  * Pack Half-word combines one half-word of its first operand with the other
  * half-word of its shifted second operand.
  */
  class PKH : public DecodeImmShiftOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    PKH(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~PKH();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned shift_op;
    unsigned shift_amm;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned imm;
    unsigned op1a;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class PKH

  /// **************************************************************************

  /**
  * @brief RBIT
  *
  * Reverse Bits reverses the bit order in a 32-bit register.
  */
  class RBIT : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    RBIT(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~RBIT();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class RBIT

  /// **************************************************************************

  /**
  * @brief REV
  *
  * Byte-Reverse Word reverses the byte order in a 32-bit register.
  */
  class REV : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    REV(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~REV();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class REV

  /// **************************************************************************

  /**
  * @brief REV16
  *
  * Byte-Reverse Packed Half-Word reverses the byte order in each 16-bit half-word
  * of a 32-bit register.
  */
  class REV16 : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    REV16(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~REV16();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class REV16

  /// **************************************************************************

  /**
  * @brief REVSH
  *
  * Byte-Reverse Signed Half-Word reverses the byte order in the lower 16-bit
  * half-word of a 32-bit register, and sign-extends the result to 32 bits.
  */
  class REVSH : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    REVSH(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~REVSH();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class REVSH

  /// **************************************************************************

  /**
  * @brief UBFX/SBFX
  *
  * Unsigned/Signed Bit Field Extract extracts any number of adjacent bits at
  * any position from a register, zero-/sign-extends them to 32 bits, and writes
  * the result to the destination register.
  */
  class USBFX : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    USBFX(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~USBFX();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    unsigned cond;
    unsigned u;
    unsigned imm0;
    unsigned imm1;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class USBFX

  /// **************************************************************************

  /**
  * @brief SEL
  *
  * Select Bytes selects each byte of its result from either its first operand
  * or its second operand, according to the values of the GE flags.
  */
  class SEL : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    SEL(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~SEL();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class SEL

  /// **************************************************************************

  /**
  * @brief CMN
  *
  * Compare Negative adds a register value and an immediate value. Updates the
  * condition flags based on the results, then discards the results.
  */
  class CMN_i : public ARMExpandImmOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    CMN_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~CMN_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned rotate;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class CMN_i

  /// **************************************************************************

  /**
  * @brief CMN
  *
  * Compare Negative adds a register value and an immediate value. Updates the
  * condition flags based on the results, then discards the results.
  */
  class CMN_r : public DecodeImmShiftOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    CMN_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~CMN_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class CMN_r

  /// **************************************************************************

  /**
  * @brief CMN
  *
  * Compare Negative adds a register value and an immediate value. Updates the
  * condition flags based on the results, then discards the results.
  */
  class CMN_sr : public DecodeRegShiftOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    CMN_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~CMN_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class CMN_sr

  /// **************************************************************************

  /**
  * @brief CMP
  *
  * Compare Positive subtracts an immediate value from a register value. Updates
  * the condition flags based on the results, then discards the results.
  */
  class CMP_i : public ARMExpandImmOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    CMP_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~CMP_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned rotate;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class CMP_i

  /// **************************************************************************

  /**
  * @brief CMP
  *
  * Compare Positive subtracts an immediate value from a register value. Updates
  * the condition flags based on the results, then discards the results.
  */
  class CMP_r : public DecodeImmShiftOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    CMP_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~CMP_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class CMP_r

  /// **************************************************************************

  /**
  * @brief CMP
  *
  * Compare Positive subtracts an immediate value from a register value. Updates
  * the condition flags based on the results, then discards the results.
  */
  class CMP_sr : public DecodeRegShiftOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    CMP_sr(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~CMP_sr();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class CMP_sr

  /// **************************************************************************

  /**
  * @brief LDR/LDRT
  *
  * Load Register calculates an address from a base register value and either an
  * immediate offset or an offset specified by a register, loads a word from
  * memory, and writes it to a register. It can use offset, post-indexed, or
  * pre-indexed addressing.
  * Load Register (literal) calculates an address from the PC value and an
  * immediate offset, loads a word from memory, and writes it to a register.
  */
  class LDR_i : public ConditionPassedOp, public LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDR_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDR_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDR_i

  /// **************************************************************************

  /**
  * @brief LDR/LDRT
  *
  * Load Register calculates an address from a base register value and either an
  * immediate offset or an offset specified by a register, loads a word from
  * memory, and writes it to a register. It can use offset, post-indexed, or
  * pre-indexed addressing.
  * Load Register (literal) calculates an address from the PC value and an
  * immediate offset, loads a word from memory, and writes it to a register.
  */
  class LDR_r : public DecodeImmShiftOp, public ConditionPassedOp, public
  LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDR_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDR_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDR_r

  /// **************************************************************************

  /**
  * @brief LDREX
  *
  * Load Register Exclusive calculates an address from a base register value and
  * an immediate offset, loads a word from memory, and writes it to a register.
  * If the address has the Shared Memory attribute, it marks the physical
  * address as exclusive access for the executing processor in a global monitor.
  * It then causes the executing processor to indicate an active exclusive
  * access in the local monitor.
  */
  class LDREX : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDREX(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDREX();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDREX

  /// **************************************************************************

  /**
  * @brief LDRB/LDRBT
  *
  * Load Register Byte calculates an address from a base register value and
  * either an immediate offset or an offset specified by a register, loads a
  * byte from memory, zero-extends it to a word, and writes it to a register. It
  * can use offset, post-indexed, or pre-indexed addressing.
  * Load Register Byte (literal) calculates an address from the PC value and an
  * immediate offset, loads a byte from memory, zero-extends it to a word, and
  * writes it to a register.
  */
  class LDRB_i : public ConditionPassedOp, public LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDRB_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDRB_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDRB_i

  /// **************************************************************************

  /**
  * @brief LDRB/LDRBT
  *
  * Load Register Byte calculates an address from a base register value and
  * either an immediate offset or an offset specified by a register, loads a
  * byte from memory, zero-extends it to a word, and writes it to a register. It
  * can use offset, post-indexed, or pre-indexed addressing.
  * Load Register Byte (literal) calculates an address from the PC value and an
  * immediate offset, loads a byte from memory, zero-extends it to a word, and
  * writes it to a register.
  */
  class LDRB_r : public DecodeImmShiftOp, public ConditionPassedOp, public
  LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDRB_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDRB_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDRB_r

  /// **************************************************************************

  /**
  * @brief LDREXB
  *
  * Load Register Exclusive Byte calculates an address from a base register
  * value and an immediate offset, loads a byte from memory, and writes it to a
  * register. If the address has the Shared Memory attribute, it marks the
  * physical address as exclusive access for the executing processor in a global
  * monitor. It then causes the executing processor to indicate an active
  * exclusive access in the local monitor.
  */
  class LDREXB : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDREXB(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDREXB();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDREXB

  /// **************************************************************************

  /**
  * @brief LDRSB/LDRSBT
  *
  * Load Register Signed Byte calculates an address from a base register value
  * and either an immediate offset or an offset specified by a register, loads a
  * byte from memory, sign-extends it to a word, and writes it to a register. It
  * can use offset, post-indexed, or pre-indexed addressing.
  * Load Register Signed Byte (literal) calculates an address from the PC value
  * and an immediate offset, loads a byte from memory, sign-extends it to a
  * word, and writes it to a register.
  */
  class LDRSB_i : public ConditionPassedOp, public LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDRSB_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDRSB_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDRSB_i

  /// **************************************************************************

  /**
  * @brief LDRSB/LDRSBT
  *
  * Load Register Signed Byte calculates an address from a base register value
  * and either an immediate offset or an offset specified by a register, loads a
  * byte from memory, sign-extends it to a word, and writes it to a register. It
  * can use offset, post-indexed, or pre-indexed addressing.
  * Load Register Signed Byte (literal) calculates an address from the PC value
  * and an immediate offset, loads a byte from memory, sign-extends it to a
  * word, and writes it to a register.
  */
  class LDRSB_r : public ConditionPassedOp, public LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDRSB_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDRSB_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDRSB_r

  /// **************************************************************************

  /**
  * @brief LDRH/LDRHT
  *
  * Load Register Half-word calculates an address from a base register value and
  * either an immediate offset or an offset specified by a register, loads a
  * half-word from memory, zero-extends it to a word, and writes it to a register.
  * It can use offset, post-indexed, or pre-indexed addressing. Load Register
  * Half-word (literal) calculates an address from the PC value and an immediate
  * offset, loads a half-word from memory, zero-extends it to a word, and writes
  * it to a register.
  */
  class LDRH_i : public ConditionPassedOp, public LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDRH_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDRH_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDRH_i

  /// **************************************************************************

  /**
  * @brief LDRH/LDRHT
  *
  * Load Register Half-word calculates an address from a base register value and
  * either an immediate offset or an offset specified by a register, loads a
  * half-word from memory, zero-extends it to a word, and writes it to a register.
  * It can use offset, post-indexed, or pre-indexed addressing. Load Register
  * Half-word (literal) calculates an address from the PC value and an immediate
  * offset, loads a half-word from memory, zero-extends it to a word, and writes
  * it to a register.
  */
  class LDRH_r : public ConditionPassedOp, public LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDRH_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDRH_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDRH_r

  /// **************************************************************************

  /**
  * @brief LDREXH
  *
  * Load Register Exclusive Half-word calculates an address from a base register
  * value and an immediate offset, loads a byte from memory, and writes it to a
  * register. If the address has the Shared Memory attribute, it marks the
  * physical address as exclusive access for the executing processor in a global
  * monitor. It then causes the executing processor to indicate an active
  * exclusive access in the local monitor.
  */
  class LDREXH : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDREXH(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDREXH();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDREXH

  /// **************************************************************************

  /**
  * @brief LDRSH/LDRSHT
  *
  * Load Register Signed Half-word calculates an address from a base register
  * value and either an immediate offset or an offset specified by a register,
  * loads a half-word from memory, sign-extends it to a word, and writes it to a
  * register. It can use offset, post-indexed, or pre-indexed addressing.
  * Load Register Signed Half-word (literal) calculates an address from the PC
  * value and an immediate offset, loads a half-word from memory, sign-extends
  * it to a word, and writes it to a register.
  */
  class LDRSH_i : public ConditionPassedOp, public LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDRSH_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDRSH_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDRSH_i

  /// **************************************************************************

  /**
  * @brief LDRSH/LDRSHT
  *
  * Load Register Signed Half-word calculates an address from a base register
  * value and either an immediate offset or an offset specified by a register,
  * loads a half-word from memory, sign-extends it to a word, and writes it to a
  * register. It can use offset, post-indexed, or pre-indexed addressing.
  * Load Register Signed Half-word (literal) calculates an address from the PC
  * value and an immediate offset, loads a half-word from memory, sign-extends
  * it to a word, and writes it to a register.
  */
  class LDRSH_r : public ConditionPassedOp, public LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDRSH_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDRSH_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDRSH_r

  /// **************************************************************************

  /**
  * @brief LDRD
  *
  * Load Register Dual calculates an address from a base register value and
  * either an immediate offset or an offset specified by a register, loads a
  * double-word from memory, and writes it to a register. It can use offset,
  * post-indexed, or pre-indexed addressing.
  * Load Register Dual (literal) calculates an address from the PC value and an
  * immediate offset, loads a double-word from memory, and writes it to a
  * register.
  */
  class LDRD_i : public ConditionPassedOp, public LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDRD_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDRD_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDRD_i

  /// **************************************************************************

  /**
  * @brief LDRD
  *
  * Load Register Dual calculates an address from a base register value and
  * either an immediate offset or an offset specified by a register, loads a
  * double-word from memory, and writes it to a register. It can use offset,
  * post-indexed, or pre-indexed addressing.
  * Load Register Dual (literal) calculates an address from the PC value and an
  * immediate offset, loads a double-word from memory, and writes it to a
  * register.
  */
  class LDRD_r : public ConditionPassedOp, public LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDRD_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDRD_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDRD_r

  /// **************************************************************************

  /**
  * @brief LDREXD
  *
  * Load Register Exclusive Dual calculates an address from a base register
  * value and an immediate offset, loads a double-word from memory, and writes
  * it to two registers. If the address has the Shared Memory attribute, it
  * marks the physical address as exclusive access for the executing processor
  * in a global monitor. It then causes the executing processor to indicate an
  * active exclusive access in the local monitor.
  */
  class LDREXD : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDREXD(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDREXD();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDREXD

  /// **************************************************************************

  /**
  * @brief LDREXD
  *
  * Load Register Exclusive Dual calculates an address from a base register
  * value and an immediate offset, loads a double-word from memory, and writes
  * it to two registers. If the address has the Shared Memory attribute, it
  * marks the physical address as exclusive access for the executing processor
  * in a global monitor. It then causes the executing processor to indicate an
  * active exclusive access in the local monitor.
  */
  class STR_i : public ConditionPassedOp, public LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STR_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STR_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STR_i

  /// **************************************************************************

  /**
  * @brief LDREXD
  *
  * Load Register Exclusive Dual calculates an address from a base register
  * value and an immediate offset, loads a double-word from memory, and writes
  * it to two registers. If the address has the Shared Memory attribute, it
  * marks the physical address as exclusive access for the executing processor
  * in a global monitor. It then causes the executing processor to indicate an
  * active exclusive access in the local monitor.
  */
  class STR_r : public DecodeImmShiftOp, public ConditionPassedOp, public
  LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STR_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STR_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STR_r

  /// **************************************************************************

  /**
  * @brief STREX
  *
  * Store Register Exclusive calculates an address from a base register value
  * and an immediate offset and stores a word from a register to memory if the
  * executing processor has exclusive access to the memory addressed.
  */
  class STREX : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STREX(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STREX();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STREX

  /// **************************************************************************

  /**
  * @brief STRB/STRBT
  *
  * Store Register Byte calculates an address from a base register value and
  * either an immediate offset or an offset specified by a register and stores a
  * byte from a register to memory. It can use offset, post-indexed, or pre-indexed
  * addressing.
  */
  class STRB_i : public ConditionPassedOp, public LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STRB_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STRB_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STRB_i

  /// **************************************************************************

  /**
  * @brief STRB/STRBT
  *
  * Store Register Byte calculates an address from a base register value and
  * either an immediate offset or an offset specified by a register and stores a
  * byte from a register to memory. It can use offset, post-indexed, or pre-indexed
  * addressing.
  */
  class STRB_r : public DecodeImmShiftOp, public ConditionPassedOp, public
  LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STRB_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STRB_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned shift_amm;
    unsigned shift_op;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STRB_r

  /// **************************************************************************

  /**
  * @brief STREXB
  *
  * Store Register Exclusive Byte calculates an address from a base register
  * value and an immediate offset and stores a byte from a register to memory if
  * the executing processor has exclusive access to the memory addressed.
  */
  class STREXB : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STREXB(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STREXB();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STREXB

  /// **************************************************************************

  /**
  * @brief STRH/STRHT
  *
  * Store Register Half-word calculates an address from a base register value
  * and either an immediate offset or an offset specified by a register, and
  * stores a half-word from a register to memory. It can use offset, post-indexed,
  * or pre-indexed addressing.
  */
  class STRH_i : public ConditionPassedOp, public LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STRH_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STRH_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STRH_i

  /// **************************************************************************

  /**
  * @brief STRH/STRHT
  *
  * Store Register Half-word calculates an address from a base register value
  * and either an immediate offset or an offset specified by a register, and
  * stores a half-word from a register to memory. It can use offset, post-indexed,
  * or pre-indexed addressing.
  */
  class STRH_r : public ConditionPassedOp, public LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STRH_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STRH_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STRH_r

  /// **************************************************************************

  /**
  * @brief STREXH
  *
  * Store Register Exclusive Half-word calculates an address from a base register
  * value and an immediate offset and stores a half-word from a register to
  * memory if the executing processor has exclusive access to the memory addressed.
  */
  class STREXH : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STREXH(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STREXH();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STREXH

  /// **************************************************************************

  /**
  * @brief STRD/STRDT
  *
  * Store Register Dual calculates an address from a base register value and
  * either an immediate offset or an offset specified by a register, and stores
  * two words from two registers to memory. It can use offset, post-indexed, or
  * pre-indexed addressing.
  */
  class STRD : public ConditionPassedOp, public LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STRD(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STRD();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STRD

  /// **************************************************************************

  /**
  * @brief STRD/STRDT
  *
  * Store Register Dual calculates an address from a base register value and
  * either an immediate offset or an offset specified by a register, and stores
  * two words from two registers to memory. It can use offset, post-indexed, or
  * pre-indexed addressing.
  */
  class STRD_r : public ConditionPassedOp, public LSOffsetOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STRD_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STRD_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    unsigned address;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STRD_r

  /// **************************************************************************

  /**
  * @brief STREXD
  *
  * Store Register Exclusive Dual calculates an address from a base register
  * value and an immediate offset and stores a double-word from two registers to
  * memory if the executing processor has exclusive access to the memory addressed.
  */
  class STREXD : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STREXD(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STREXD();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STREXD

  /// **************************************************************************

  /**
  * @brief LDM
  *
  * Load Multiple Increment After loads multiple registers from consecutive
  * memory locations using an address from a base register. The consecutive
  * memory locations start at this address, and the address just above the
  * highest of those locations can optionally be written back to the base
  * register. The registers loaded can include the PC, causing a branch to a
  * loaded address. If the instruction is an exception return (s == 1), the SPSR
  * of the current mode is copied to the CPSR. If the instruction is a user
  * register instruction, the registers loaded cannot include the PC. The
  * processor reads the base register normally, using the current mode to
  * determine the correct banked version of the register. This version cannot
  * write back to the base register.
  */
  class LDM : public ConditionPassedOp, public LSMReglistOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDM(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDM();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned start_address;
    unsigned wb_address;

    private:
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned s;
    unsigned w;
    unsigned reg_list;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDM

  /// **************************************************************************

  /**
  * @brief LDMIB
  *
  * Load Multiple Increment Before loads multiple registers from consecutive
  * memory locations using an address from a base register. The consecutive
  * memory locations start just above this address, and the address of the
  * highest of those locations can optionally be written back to the base
  * register. The registers loaded can include the PC, causing a branch to a
  * loaded address. If the instruction is an exception return (s == 1), the SPSR
  * of the current mode is copied to the CPSR.
  */
  class LDMIB : public ConditionPassedOp, public LSMReglistOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDMIB(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDMIB();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned start_address;
    unsigned wb_address;

    private:
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned s;
    unsigned w;
    unsigned reg_list;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDMIB

  /// **************************************************************************

  /**
  * @brief LDMDA
  *
  * Load Multiple Decrement After loads multiple registers from consecutive
  * memory locations using an address from a base register. The consecutive
  * memory locations end at this address, and the address just below the lowest
  * of those locations can optionally be written back to the base register. The
  * registers loaded can include the PC, causing a branch to a loaded address.
  * If the instruction is an exception return (s == 1), the SPSR of the current
  * mode is copied to the CPSR.
  */
  class LDMDA : public ConditionPassedOp, public LSMReglistOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDMDA(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDMDA();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned start_address;
    unsigned wb_address;

    private:
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned s;
    unsigned w;
    unsigned reg_list;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDMDA

  /// **************************************************************************

  /**
  * @brief LDMDB
  *
  * Load Multiple Decrement Before loads multiple registers from consecutive
  * memory locations using an address from a base register. The consecutive
  * memory locations end just below this address, and the address of the lowest
  * of those locations can optionally be written back to the base register. The
  * registers loaded can include the PC, causing a branch to a loaded address.
  * If the instruction is an exception return (s == 1), the SPSR of the current
  * mode is copied to the CPSR.
  */
  class LDMDB : public ConditionPassedOp, public LSMReglistOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDMDB(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDMDB();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned start_address;
    unsigned wb_address;

    private:
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned s;
    unsigned w;
    unsigned reg_list;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDMDB

  /// **************************************************************************

  /**
  * @brief POP
  *
  * Pop Multiple Registers loads multiple registers from the stack, loading from
  * consecutive memory locations starting at the address in SP, and updates SP
  * to point just above the loaded data.
  */
  class POP_single : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    POP_single(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~POP_single();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    unsigned cond;
    unsigned imm0;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class POP_single

  /// **************************************************************************

  /**
  * @brief POP
  *
  * Pop Multiple Registers loads multiple registers from the stack, loading from
  * consecutive memory locations starting at the address in SP, and updates SP
  * to point just above the loaded data.
  */
  class POP_block : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    POP_block(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~POP_block();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    unsigned cond;
    unsigned imm0;
    unsigned imm1;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class POP_block

  /// **************************************************************************

  /**
  * @brief STM
  *
  * Store Multiple Increment After stores multiple registers to consecutive
  * memory locations using an address from a base register. The consecutive
  * memory locations start at this address, and the address just above the
  * highest of those locations can optionally be written back to the base
  * register. If the instruction is a user register instruction, the processor
  * reads the base register normally, using the current mode to determine the
  * correct banked version of the register. This version cannot write back to
  * the base register.
  */
  class STM : public ConditionPassedOp, public LSMReglistOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STM(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STM();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned start_address;
    unsigned wb_address;

    private:
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned s;
    unsigned w;
    unsigned reg_list;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STM

  /// **************************************************************************

  /**
  * @brief STMIB
  *
  * Store Multiple Increment Before stores multiple registers to consecutive
  * memory locations using an address from a base register. The consecutive
  * memory locations start just above this address, and the address of the
  * highest of those locations can optionally be written back to the base
  * register.
  */
  class STMIB : public ConditionPassedOp, public LSMReglistOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STMIB(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STMIB();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned start_address;
    unsigned wb_address;

    private:
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned s;
    unsigned w;
    unsigned reg_list;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STMIB

  /// **************************************************************************

  /**
  * @brief STMDA
  *
  * Store Multiple Decrement After stores multiple registers to consecutive
  * memory locations using an address from a base register. The consecutive
  * memory locations end at this address, and the address just below the lowest
  * of those locations can optionally be written back to the base register.
  */
  class STMDA : public ConditionPassedOp, public LSMReglistOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STMDA(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STMDA();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned start_address;
    unsigned wb_address;

    private:
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned s;
    unsigned w;
    unsigned reg_list;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STMDA

  /// **************************************************************************

  /**
  * @brief STMDB
  *
  * Store Multiple Decrement Before stores multiple registers to consecutive
  * memory locations using an address from a base register. The consecutive
  * memory locations end just below this address, and the address of the lowest
  * of those locations can optionally be written back to the base register.
  */
  class STMDB : public ConditionPassedOp, public LSMReglistOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STMDB(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STMDB();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned start_address;
    unsigned wb_address;

    private:
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned s;
    unsigned w;
    unsigned reg_list;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STMDB

  /// **************************************************************************

  /**
  * @brief PUSH
  *
  * Push Multiple Registers stores multiple registers to the stack, storing to
  * consecutive memory locations ending just below the address in SP, and
  * updates SP to point to the start of the stored data.
  */
  class PUSH_single : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    PUSH_single(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~PUSH_single();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    unsigned cond;
    unsigned imm0;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class PUSH_single

  /// **************************************************************************

  /**
  * @brief PUSH
  *
  * Push Multiple Registers stores multiple registers to the stack, storing to
  * consecutive memory locations ending just below the address in SP, and
  * updates SP to point to the start of the stored data.
  */
  class PUSH_block : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    PUSH_block(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~PUSH_block();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    unsigned cond;
    unsigned imm0;
    unsigned imm1;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class PUSH_block

  /// **************************************************************************

  /**
  * @brief MOV
  *
  * Move writes either an immediate or a register value to the destination
  * register. It can optionally update the condition flags based on the value.
  */
  class MOV_i : public UpdatePSRBitOp, public ConditionPassedOp, public ARMExpandImmOp
  {
    /// @name Constructors and Destructors
    /// @{

    public:
    MOV_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~MOV_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned result;
    bool carry;
    unsigned operand;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;
    unsigned rotate;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class MOV_i

  /// **************************************************************************

  /**
  * @brief MOV
  *
  * Move writes either an immediate or a register value to the destination
  * register. It can optionally update the condition flags based on the value.
  */
  class MOV_r : public UpdatePSRBitOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    MOV_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~MOV_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned result;
    bool carry;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned cond;
    unsigned s;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class MOV_r

  /// **************************************************************************

  /**
  * @brief MOVW
  *
  * Move writes an immediate value to the destination register.
  */
  class MOVW : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    MOVW(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~MOVW();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    unsigned cond;
    unsigned imm0a;
    unsigned imm0b;
    unsigned imm1a;
    unsigned b;
    unsigned imm1b;
    unsigned op1;
    unsigned imm2;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class MOVW

  /// **************************************************************************

  /**
  * @brief MOVT
  *
  * Move Top writes an immediate value to the top half-word of the destination
  * register. It does not affect the contents of the bottom half-word.
  */
  class MOVT : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    MOVT(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~MOVT();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    unsigned cond;
    unsigned imm0a;
    unsigned imm0b;
    unsigned imm1a;
    unsigned b;
    unsigned imm1b;
    unsigned op1;
    unsigned imm2;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class MOVT

  /// **************************************************************************

  /**
  * @brief SWP
  *
  * Swap swaps a word or a byte between registers and memory. It loads a word/byte
  * from the memory address given by the value of register rn. The value of (the
  * least significant byte of) register rm is stored to the memory address given
  * by rn, and the original loaded value is (zero-extended to 32-bits and)
  * written to register rd. If the same register is specified for rd and rm,
  * this instruction swaps the value of (the least significant byte of) the
  * register and the (byte) value at memory address (and clears the most significant
  * three bytes of the register). The memory system ensures that no other memory
  * access can occur to the memory location between the load access and the
  * store access.
  * NOTE: Deprecated in favor of LDREX(B)/STREX(B)
  * 
  */
  class SWP : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    SWP(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~SWP();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned b;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class SWP

  /// **************************************************************************

  /**
  * @brief MRS
  *
  * Move to Register from Banked or Special Register moves the value form either
  * the APSR (user mode) or the SPSR (system mode) into an ARM core register.
  * The banked version moves the value from either the SPSR or the banked
  * versions of special registers (SP, LR, etc) into an ARM core register.
  */
  class MRS : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    MRS(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~MRS();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    unsigned cond;
    unsigned r;
    unsigned imm0a;
    unsigned imm0b;
    unsigned imm1a;
    unsigned b;
    unsigned imm1b;
    unsigned imm2;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class MRS

  /// **************************************************************************

  /**
  * @brief MSR
  *
  * Move to Special or Banked Register moves selected bits of either an immediate
  * value or the value of an ARM core register into the corresponding bits of
  * either the APSR (user mode) or the SPSR (system mode) of the current mode.
  * The banked version moves the value of an ARM core register into the corresponding
  * bits of either the SPSR or the banked versions of special registers (SP, LR,
  * etc).
  */
  class MSR_i : public ARMExpandImmOp, public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    MSR_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~MSR_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    protected:
    unsigned operand;
    bool carry;
    unsigned rotate;
    unsigned imm;

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    unsigned cond;
    unsigned r;
    unsigned imm0a;
    unsigned imm0b;
    unsigned imm1a;
    unsigned b;
    unsigned imm1b;
    unsigned op1;
    unsigned imm2;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class MSR_i

  /// **************************************************************************

  /**
  * @brief MSR
  *
  * Move to Special or Banked Register moves selected bits of either an immediate
  * value or the value of an ARM core register into the corresponding bits of
  * either the APSR (user mode) or the SPSR (system mode) of the current mode.
  * The banked version moves the value of an ARM core register into the corresponding
  * bits of either the SPSR or the banked versions of special registers (SP, LR,
  * etc).
  */
  class MSR_r : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    MSR_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~MSR_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    unsigned cond;
    unsigned r;
    unsigned imm0a;
    unsigned imm0b;
    unsigned imm1a;
    unsigned b;
    unsigned imm1b;
    unsigned imm2;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class MSR_r

  /// **************************************************************************

  /**
  * @brief B
  *
  * Branch causes a branch to a target address.
  * TODO: BnX instructions perform branches without changing the instruction set
  * since only the ARM ISA is implemented.
  */
  class B : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    B(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~B();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    unsigned cond;
    unsigned offset;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class B

  /// **************************************************************************

  /**
  * @brief BL
  *
  * Branch with Link calls a subroutine at a PC-relative address.
  */
  class BL : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    BL(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~BL();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    unsigned cond;
    unsigned offset;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class BL

  /// **************************************************************************

  /**
  * @brief BX
  *
  * Branch and Exchange causes a branch to an address and instruction set
  * specified by a register.
  */
  class BX : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    BX(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~BX();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class BX

  /// **************************************************************************

  /**
  * @brief BLX
  *
  * Branch with Link and Exchange calls a subroutine at a PC-relative address
  * and changes the instruction set from ARM to Thumb or vice versa.
  */
  class BLX_i : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    BLX_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~BLX_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    unsigned cond;
    unsigned l;
    unsigned offset;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class BLX_i

  /// **************************************************************************

  /**
  * @brief BLX
  *
  * Branch with Link and Exchange calls a subroutine at a PC-relative address
  * and changes the instruction set from ARM to Thumb or vice versa.
  */
  class BLX_r : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    BLX_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~BLX_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class BLX_r

  /// **************************************************************************

  /**
  * @brief BXJ
  *
  * Branch and Exchange Jazelle attempts to change to the Jazelle state. On
  * fail, it branches to an address and instruction set specified by a register
  * as though it were a BX instruction.
  */
  class BXJ : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    BXJ(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~BXJ();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class BXJ

  /// **************************************************************************

  /**
  * @brief TODO: BKPT
  *
  * Breakpoint causes a software breakpoint to occur.
  */
  class BKPT : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    BKPT(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~BKPT();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class BKPT

  /// **************************************************************************

  /**
  * @brief TODO: CLREX
  *
  * Clear-Exclusive clears the local record of the executing processor that an
  * address has had a request for an exclusive access.
  */
  class CLREX : public Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    CLREX(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~CLREX();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class CLREX

  /// **************************************************************************

  /**
  * @brief TODO: CPS
  *
  * Processor State changes one or more of the CPSR[A, I, F] interrupt mask bits
  * and the CPSR[M] mode field without changing the other CPSR bits.
  */
  class CPS : public Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    CPS(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~CPS();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    unsigned op2;
    unsigned M;
    unsigned b15to10;
    unsigned E;
    unsigned A;
    unsigned I;
    unsigned F;
    unsigned mode0;
    unsigned mode1;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class CPS

  /// **************************************************************************

  /**
  * @brief TODO: DBG
  *
  * Debug Hint provides a hint to debug and related systems.
  */
  class DBG : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    DBG(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~DBG();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;
    unsigned rm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class DBG

  /// **************************************************************************

  /**
  * @brief TODO: DMB
  *
  * Data Memory Barrier is a memory barrier that ensures the ordering of observations
  * of memory accesses.
  */
  class DMB : public Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    DMB(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~DMB();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class DMB

  /// **************************************************************************

  /**
  * @brief TODO: DSB
  *
  * Data Synchronization Barrier is a memory barrier that ensures the completion
  * of memory accesses.
  */
  class DSB : public Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    DSB(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~DSB();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class DSB

  /// **************************************************************************

  /**
  * @brief TODO: ISB
  *
  * Instruction Synchronization Barrier flushes the pipeline in the processor,
  * so that all following instructions are fetched from cache or memory, after
  * the instruction has been completed. It ensures that the effects of context
  * changing operations executed before the ISB instruction are visible to the
  * instructions fetched after the ISB. Context changing operations include
  * changing the Address Space Identifier (ASID), TLB maintenance operations,
  * branch predictor maintenance operations, and all changes to the CP15 registers.
  * In addition, any branches that appear in program order after the ISB instruction
  * are written into the branch prediction logic with the context that is
  * visible after the ISB instruction. This is needed to ensure correct execution
  * of the instruction stream.
  */
  class ISB : public Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    ISB(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~ISB();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class ISB

  /// **************************************************************************

  /**
  * @brief NOP
  *
  * No Operation does nothing. This instruction can be used for instruction
  * alignment purposes.
  */
  class NOP : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    NOP(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~NOP();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class NOP

  /// **************************************************************************

  /**
  * @brief TODO: PLI
  *
  * Preload Instruction signals the memory system that instruction memory
  * accesses from a specified address are likely in the near future. The memory
  * system can respond by taking actions that are expected to speed up the
  * memory accesses when they do occur, such as pre-loading the cache line
  * containing the specified address into the instruction cache. The effect of a
  * PLI instruction is IMPLEMENTATION DEFINED.
  */
  class PLI_i : public Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    PLI_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~PLI_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned u;
    unsigned op1a;
    unsigned op1b;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class PLI_i

  /// **************************************************************************

  /**
  * @brief TODO: PLI
  *
  * Preload Instruction signals the memory system that instruction memory
  * accesses from a specified address are likely in the near future. The memory
  * system can respond by taking actions that are expected to speed up the
  * memory accesses when they do occur, such as pre-loading the cache line
  * containing the specified address into the instruction cache. The effect of a
  * PLI instruction is IMPLEMENTATION DEFINED.
  */
  class PLI_r : public Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    PLI_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~PLI_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned u;
    unsigned op1a;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class PLI_r

  /// **************************************************************************

  /**
  * @brief TODO: PLD
  *
  * Preload Data signals the memory system that data memory accesses from a
  * specified address are likely in the near future. The memory system can
  * respond by taking actions that are expected to speed up the memory accesses
  * when they do occur, such as pre-loading the cache line containing the
  * specified address into the instruction cache. On an architecture variant
  * that includes both the PLD and the PLDW instructions, the PLD instruction
  * signals that the likely memory access is a read, and the PLDW instruction
  * signals that it is a write. The effect of a PLD or PLDW instruction is
  * IMPLEMENTATION DEFINED.
  */
  class PLD_i : public Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    PLD_i(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~PLD_i();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned u;
    unsigned r;
    unsigned op1a;
    unsigned op1b;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class PLD_i

  /// **************************************************************************

  /**
  * @brief TODO: PLD
  *
  * Preload Data signals the memory system that data memory accesses from a
  * specified address are likely in the near future. The memory system can
  * respond by taking actions that are expected to speed up the memory accesses
  * when they do occur, such as pre-loading the cache line containing the
  * specified address into the instruction cache. On an architecture variant
  * that includes both the PLD and the PLDW instructions, the PLD instruction
  * signals that the likely memory access is a read, and the PLDW instruction
  * signals that it is a write. The effect of a PLD or PLDW instruction is
  * IMPLEMENTATION DEFINED.
  */
  class PLD_r : public Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    PLD_r(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~PLD_r();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned u;
    unsigned r;
    unsigned op1a;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class PLD_r

  /// **************************************************************************

  /**
  * @brief TODO: RFE
  *
  * Return from Exception loads the PC and the CPSR from the word at the specified
  * address and the following word respectively.
  */
  class RFE : public Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    RFE(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~RFE();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm0;
    unsigned imm1;
    unsigned op1;
    unsigned imm2;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class RFE

  /// **************************************************************************

  /**
  * @brief TODO: SETEND
  *
  * Set Endianness writes a new value to ENDIANSTATE.
  */
  class SETEND : public Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    SETEND(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~SETEND();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    unsigned op2;
    unsigned M;
    unsigned b15to10;
    unsigned E;
    unsigned A;
    unsigned mode1;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class SETEND

  /// **************************************************************************

  /**
  * @brief TODO: SEV
  *
  * Send Event is a hint that causes an event to be signaled to all processors
  * in the multi-processor system.
  */
  class SEV : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    SEV(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~SEV();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class SEV

  /// **************************************************************************

  /**
  * @brief TODO: SRS
  *
  * Store Return State stores the LR and SPSR of the current mode to the stack
  * of a specified mode.
  */
  class SRS : public Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    SRS(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~SRS();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    unsigned p;
    unsigned u;
    unsigned w;
    unsigned imm0;
    unsigned imm1;
    unsigned op1;
    unsigned imm2;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class SRS

  /// **************************************************************************

  /**
  * @brief SVC
  *
  * Supervisor Call, previously called Software Interrupt, requests a supervisor
  * function, causing the processor to enter Supervisor mode. Typically, the SVC
  * instruction is executed to request an operating system function.
  */
  class SVC : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    SVC(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~SVC();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    unsigned cond;
    unsigned swi_number;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class SVC

  /// **************************************************************************

  /**
  * @brief TODO: UDF
  *
  * Permanently Undefined generates an Undefined Instruction exception.
  */
  class UDF : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    UDF(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~UDF();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    unsigned cond;
    unsigned imm0;
    unsigned imm1;
    unsigned imm2;
    unsigned imm3;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class UDF

  /// **************************************************************************

  /**
  * @brief TODO: WFE
  *
  * Wait for Event is a hint that permits the processor to enter a low-power
  * state until one of a number of events occur, including events signaled by
  * executing the SEV instruction on any processor in the multi-processor
  * system.
  */
  class WFE : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    WFE(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~WFE();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class WFE

  /// **************************************************************************

  /**
  * @brief TODO: WFI
  *
  * Wait for Interrupt is a hint that permits the processor to enter a low-power
  * state until one of a number of asynchronous events occur.
  */
  class WFI : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    WFI(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~WFI();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class WFI

  /// **************************************************************************

  /**
  * @brief TODO: YIELD
  *
  * Yield is a hint that indicates to the hardware that it the software is
  * performing a task, for example a spin-lock, that could be swapped out to
  * improve overall system performance. Hardware can use this hint to suspend
  * and resume multiple software threads if it supports the capability.
  */
  class YIELD : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    YIELD(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~YIELD();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class YIELD

  /// **************************************************************************

  /**
  * @brief TODO: SMC
  *
  * Secure Monitor Call causes a Secure Monitor Call exception.
  */
  class SMC : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    SMC(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~SMC();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rm;
    unsigned rm_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> rs;
    unsigned rs_bit;
    unsigned cond;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class SMC

  /// **************************************************************************

  /**
  * @brief TODO: CDP/CDP2
  *
  * Coprocessor Data Processing tells a coprocessor to perform an operation that
  * is independent of ARM core registers and memory. If no coprocessor can
  * execute the instruction, an Undefined Instruction exception is generated.
  */
  class CDP : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    CDP(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~CDP();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> cprn;
    unsigned cprn_bit;
    trap::RegisterAlias<unsigned> cprm;
    unsigned cprm_bit;
    trap::RegisterAlias<unsigned> cprd;
    unsigned cprd_bit;
    unsigned cond;
    unsigned op0;
    unsigned cpnum;
    unsigned op1;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class CDP

  /// **************************************************************************

  /**
  * @brief TODO: LDC/LDC2
  *
  * Load Coprocessor loads memory data from a sequence of consecutive memory
  * addresses to a coprocessor. If no coprocessor can execute the instruction,
  * an Undefined Instruction exception is generated.
  */
  class LDC : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    LDC(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~LDC();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> cprd;
    unsigned cprd_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned d;
    unsigned w;
    unsigned cpnum;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class LDC

  /// **************************************************************************

  /**
  * @brief TODO: STC/STC2
  *
  * Store Coprocessor stores data from a coprocessor to a sequence of consecutive
  * memory addresses. If no coprocessor can execute the instruction, an Undefined
  * Instruction exception is generated.
  */
  class STC : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    STC(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~STC();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> cprd;
    unsigned cprd_bit;
    unsigned cond;
    unsigned p;
    unsigned u;
    unsigned d;
    unsigned w;
    unsigned cpnum;
    unsigned imm;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class STC

  /// **************************************************************************

  /**
  * @brief TODO: MCR/MCR2
  *
  * Move to Coprocessor from ARM core registers passes the value of an ARM core
  * register to a coprocessor. If no coprocessor can execute the instruction, an
  * Undefined Instruction exception is generated.
  */
  class MCR : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    MCR(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~MCR();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> cprm;
    unsigned cprm_bit;
    unsigned cond;
    unsigned op0;
    unsigned cpnum;
    unsigned op1;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class MCR

  /// **************************************************************************

  /**
  * @brief TODO: MCRR/MCRR2
  *
  * Move to Coprocessor from two ARM core registers passes the value of two ARM
  * core registers to a coprocessor. If no coprocessor can execute the instruction,
  * an Undefined Instruction exception is generated.
  */
  class MCRR : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    MCRR(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~MCRR();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> cprm;
    unsigned cprm_bit;
    unsigned cond;
    unsigned cpnum;
    unsigned op1;
    unsigned e;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class MCRR

  /// **************************************************************************

  /**
  * @brief TODO: MRC/MRC2
  *
  * Move to ARM core register from Coprocessor causes a coprocessor to transfer
  * a value to an ARM core register or to the condition flags. If no coprocessor
  * can execute the instruction, an Undefined Instruction exception is generated.
  */
  class MRC : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    MRC(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~MRC();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> cprm;
    unsigned cprm_bit;
    unsigned cond;
    unsigned op0;
    unsigned cpnum;
    unsigned op1;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class MRC

  /// **************************************************************************

  /**
  * @brief TODO: MRRC/MRRC2
  *
  * Move to two ARM core registers from Coprocessor causes a coprocessor to
  * transfer values to two ARM core registers. If no coprocessor can execute the
  * instruction, an Undefined Instruction exception is generated.
  */
  class MRRC : public ConditionPassedOp {
    /// @name Constructors and Destructors
    /// @{

    public:
    MRRC(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles);
    virtual ~MRRC();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    std::string get_name() const throw();
    unsigned get_id() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_mnemonic() const throw();

    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    trap::RegisterAlias<unsigned> rd;
    unsigned rd_bit;
    trap::RegisterAlias<unsigned> rn;
    unsigned rn_bit;
    trap::RegisterAlias<unsigned> cprm;
    unsigned cprm_bit;
    unsigned cond;
    unsigned cpnum;
    unsigned op1;
    unsigned e;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class MRRC

  /// **************************************************************************

  /**
  * @brief IRQ Instruction Class
  *
  * Wraps IRQ exception handling behavior as a dummy instruction.
  */
  class IRQIntrInstruction : public Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    IRQIntrInstruction(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles, bool&
        IRQ);
    virtual ~IRQIntrInstruction();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_name() const throw();
    std::string get_mnemonic() const throw();
    unsigned get_id() const throw();
    inline void set_interrupt_value(const bool& interrupt_value) throw() {
      this->IRQ = interrupt_value;
    } // set_interrupt_value()


    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    public:
    bool& IRQ;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class IRQIntrInstruction

  /// **************************************************************************

  /**
  * @brief IRQ Instruction Class
  *
  * Wraps IRQ exception handling behavior as a dummy instruction.
  */
  class FIQIntrInstruction : public Instruction {
    /// @name Constructors and Destructors
    /// @{

    public:
    FIQIntrInstruction(
        Registers& R, LocalMemory& data_memory, unsigned& total_cycles, bool&
        FIQ);
    virtual ~FIQIntrInstruction();

    /// @} Constructors and Destructors
    /// ------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned behavior();
    Instruction* replicate() const throw();
    void set_params(const unsigned& bitstring) throw();
    std::string get_name() const throw();
    std::string get_mnemonic() const throw();
    unsigned get_id() const throw();
    inline void set_interrupt_value(const bool& interrupt_value) throw() {
      this->FIQ = interrupt_value;
    } // set_interrupt_value()


    /// @} Methods
    /// ------------------------------------------------------------------------
    /// @name Data
    /// @{

    public:
    bool& FIQ;

    /// @} Data
    /// ------------------------------------------------------------------------

  }; // class FIQIntrInstruction

  /// **************************************************************************

} // namespace core_armcortexa9_lt

#endif // CORE_ARMCORTEXA9_FUNC_LT_INSTRUCTIONS_HPP
