/***************************************************************************//**
*
*           _/       _/_/_/      _/         _/
*         _/_/      _/    _/    _/_/      __/
*       _/  _/     _/    _/    _/ _/    _/_/
*     _/_/_/_/    _/_/_/      _/  _/  _/ _/
*   _/      _/   _/    _/    _/   _/_/  _/
* _/        _/  _/      _/  _/    _/   _/
*
* @brief    This file is part of the SoCRocket ARM ISS generated by TRAP.
* @details  This SystemC model was automatically generated by running
*           $ python ARMArch.py
*           Please refer to the ARM TRAP source files for documentation.
* @author   Lillian Tadros (Technische Universitaet Dortmund)
* @date     2015-2016 Technische Universitaet Dortmund
*
*
* (c) 2014-2016
* Technische Universitaet Dortmund
* Institut fuer Roboterforschung
* Project Embedded Multi-Core Systems for Mixed Criticality
* Applications in Dynamic and Changeable Real-time Environments (EMC2)
*
*
* This file is part of ARMCortexA9.
*
* ARMCortexA9 is free software; you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License as
* published by the Free Software Foundation; either version 3 of the
* License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Affero General Public License for more details.
*
* You should have received a copy of the GNU Affero General Public
* License along with this program; if not, write to the
* Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
* or see <http://www.gnu.org/licenses/>.
*
*******************************************************************************/

#include "interface.hpp"
#include "registers.hpp"
#include "memory.hpp"

#include <modules/abi_if.hpp>
#include <systemc.h>
#include <boost/circular_buffer.hpp>
#include <modules/instruction.hpp>
#include <vector>
#include <common/report.hpp>
#include <string>


using namespace core_armcortexa9_funclt;

using namespace trap;

core_armcortexa9_funclt::Interface::Interface(
    Registers& R,
    MemoryInterface& data_memory,
    bool& instr_executing,
    sc_event& instr_end_event,
    boost::circular_buffer<HistoryInstrType>& history_instr_queue,
    unsigned& PROGRAM_LIMIT) :
  R(R),
  data_memory(data_memory),
  instr_executing(instr_executing),
  instr_end_event(instr_end_event),
  history_instr_queue(history_instr_queue),
  PROGRAM_LIMIT(PROGRAM_LIMIT) {

  std::vector<std::string> temp_vec;
  temp_vec.clear();
  temp_vec.push_back("SVC");
  this->routine_entry_sequence.push_back(temp_vec);
  temp_vec.clear();
  temp_vec.push_back("");
  this->routine_entry_sequence.push_back(temp_vec);
  temp_vec.clear();
  temp_vec.push_back("");
  this->routine_entry_sequence.push_back(temp_vec);
} // Interface()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Interface::num_gdb_regs() const throw() {

  return 1;
} // num_gdb_regs()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Interface::read_gdb_reg(const unsigned&
gdb_id) const throw() {

  switch(gdb_id) {
    case 0: {
      return REGS[0];
    break;}
    case 1: {
      return REGS[1];
    break;}
    case 2: {
      return REGS[2];
    break;}
    case 3: {
      return REGS[3];
    break;}
    case 4: {
      return REGS[4];
    break;}
    case 5: {
      return REGS[5];
    break;}
    case 6: {
      return REGS[6];
    break;}
    case 7: {
      return REGS[7];
    break;}
    case 8: {
      return REGS[8];
    break;}
    case 9: {
      return REGS[9];
    break;}
    case 10: {
      return REGS[10];
    break;}
    case 11: {
      return REGS[11];
    break;}
    case 12: {
      return REGS[12];
    break;}
    case 13: {
      return REGS[13];
    break;}
    case 14: {
      return REGS[14];
    break;}
    case 15: {
      return REGS[15];
    break;}
    case 16: {
      return CPSR;
    break;}
    default: {
      return 0;
    }
  }
} // read_gdb_reg()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Interface::set_gdb_reg(
    const unsigned& new_value,
    const unsigned& gdb_id) throw() {

  switch(gdb_id) {
    case 0: {
      REGS[0].write_force(new_value);
    break;}
    case 1: {
      REGS[1].write_force(new_value);
    break;}
    case 2: {
      REGS[2].write_force(new_value);
    break;}
    case 3: {
      REGS[3].write_force(new_value);
    break;}
    case 4: {
      REGS[4].write_force(new_value);
    break;}
    case 5: {
      REGS[5].write_force(new_value);
    break;}
    case 6: {
      REGS[6].write_force(new_value);
    break;}
    case 7: {
      REGS[7].write_force(new_value);
    break;}
    case 8: {
      REGS[8].write_force(new_value);
    break;}
    case 9: {
      REGS[9].write_force(new_value);
    break;}
    case 10: {
      REGS[10].write_force(new_value);
    break;}
    case 11: {
      REGS[11].write_force(new_value);
    break;}
    case 12: {
      REGS[12].write_force(new_value);
    break;}
    case 13: {
      REGS[13].write_force(new_value);
    break;}
    case 14: {
      REGS[14].write_force(new_value);
    break;}
    case 15: {
      REGS[15].write_force(new_value);
    break;}
    case 16: {
      CPSR.write_force(new_value);
    break;}
    default: {
      THROW_EXCEPTION("Register corresponding to GDB id " << gdb_id << " not found.");
    }
  }
} // set_gdb_reg()

// -----------------------------------------------------------------------------

std::vector<unsigned> core_armcortexa9_funclt::Interface::read_args() const
throw() {

  std::vector<unsigned> args;
  args.push_back(this->REGS[0]);
  args.push_back(this->REGS[1]);
  args.push_back(this->REGS[2]);
  args.push_back(this->REGS[3]);
  return args;
} // read_args()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Interface::set_args(const std::vector<unsigned>&
args) throw() {

  if (args.size() > 4) {
    THROW_EXCEPTION("Too many arguments for processor ABI, given " << args.size()
    << ", expected up to 4 .");
  }
  std::vector<unsigned>::const_iterator arg_it = args.begin(), arg_end = args.end();
  if (arg_it != arg_end) {
    REGS[0].write_force(*arg_it);
    arg_it++;
  }
  if (arg_it != arg_end) {
    REGS[1].write_force(*arg_it);
    arg_it++;
  }
  if (arg_it != arg_end) {
    REGS[2].write_force(*arg_it);
    arg_it++;
  }
  if (arg_it != arg_end) {
    REGS[3].write_force(*arg_it);
    arg_it++;
  }
} // set_args()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Interface::read_PC() const throw() {

  return PC + 8;
} // read_PC()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Interface::set_PC(const unsigned& new_value)
throw() {

  PC.write_force(new_value);
} // set_PC()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Interface::read_LR() const throw() {

  return LR;
} // read_LR()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Interface::set_LR(const unsigned& new_value)
throw() {

  LR.write_force(new_value);
} // set_LR()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Interface::read_SP() const throw() {

  return SP;
} // read_SP()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Interface::set_SP(const unsigned& new_value)
throw() {

  SP.write_force(new_value);
} // set_SP()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Interface::read_return_value() const throw() {

  return REGS[0];
} // read_return_value()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Interface::set_return_value(const unsigned&
new_value) throw() {

  REGS[0].write_force(new_value);
} // set_return_value()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Interface::read_mem(const unsigned& address) {

  return this->data_memory.read_word_dbg(address);
} // read_mem()

// -----------------------------------------------------------------------------

unsigned char core_armcortexa9_funclt::Interface::read_char_mem(const unsigned&
address) {

  return this->data_memory.read_byte_dbg(address);
} // read_char_mem()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Interface::write_mem(
    const unsigned& address,
    unsigned datum) {

  this->data_memory.write_word_dbg(address, datum);
} // write_mem()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Interface::write_char_mem(
    const unsigned& address,
    unsigned char datum) {

  this->data_memory.write_byte_dbg(address, datum);
} // write_char_mem()

// -----------------------------------------------------------------------------

unsigned char* core_armcortexa9_funclt::Interface::get_state() const throw() {

  unsigned char* cur_state = new unsigned char[248];
  unsigned char* cur_state_temp = cur_state;
  *((unsigned*)cur_state_temp) = CPSR.read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = SCR.read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = SCTLR.read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = SPSR[0].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = SPSR[1].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = SPSR[2].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = SPSR[3].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = SPSR[4].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = SPSR[5].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = SPSR[6].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[0].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[1].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[2].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[3].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[4].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[5].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[6].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[7].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[8].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[9].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[10].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[11].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[12].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[13].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[14].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[15].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[16].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[17].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[18].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[19].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[20].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[21].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[22].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[23].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[24].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[25].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[26].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[27].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[28].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[29].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[30].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[31].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[32].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[33].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = RB[34].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = CPREGS[0].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = CPREGS[1].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = CPREGS[2].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = CPREGS[3].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = CPREGS[4].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = CPREGS[5].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = CPREGS[6].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = CPREGS[7].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = CPREGS[8].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = CPREGS[9].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = CPREGS[10].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = CPREGS[11].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = CPREGS[12].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = CPREGS[13].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = CPREGS[14].read_force();
  cur_state_temp += 4;
  *((unsigned*)cur_state_temp) = CPREGS[15].read_force();
  cur_state_temp += 4;
  return cur_state;
} // get_state()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Interface::set_state(unsigned char* state) throw()
{

  unsigned char* cur_state_temp = state;
  CPSR.write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  SCR.write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  SCTLR.write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  SPSR[0].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  SPSR[1].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  SPSR[2].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  SPSR[3].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  SPSR[4].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  SPSR[5].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  SPSR[6].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[0].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[1].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[2].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[3].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[4].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[5].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[6].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[7].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[8].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[9].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[10].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[11].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[12].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[13].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[14].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[15].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[16].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[17].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[18].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[19].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[20].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[21].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[22].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[23].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[24].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[25].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[26].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[27].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[28].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[29].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[30].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[31].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[32].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[33].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  RB[34].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  CPREGS[0].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  CPREGS[1].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  CPREGS[2].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  CPREGS[3].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  CPREGS[4].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  CPREGS[5].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  CPREGS[6].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  CPREGS[7].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  CPREGS[8].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  CPREGS[9].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  CPREGS[10].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  CPREGS[11].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  CPREGS[12].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  CPREGS[13].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  CPREGS[14].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
  CPREGS[15].write_force(*((unsigned*)cur_state_temp));
  cur_state_temp += 4;
} // set_state()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Interface::get_exit_value() throw() {

  return this->exit_value;
} // get_exit_value()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Interface::set_exit_value(unsigned value) throw()
{

  this->exit_value = value;
} // set_exit_value()

// -----------------------------------------------------------------------------

bool core_armcortexa9_funclt::Interface::is_executing_instr() const throw() {

  return this->instr_executing;
} // is_executing_instr()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::Interface::wait_instr_end() const throw() {

  if (this->instr_executing) {
    wait(this->instr_end_event);
  }
} // wait_instr_end()

// -----------------------------------------------------------------------------

bool core_armcortexa9_funclt::Interface::is_routine_entry(const InstructionBase*
instr) throw() {

  std::vector<std::string> next_names = this->routine_entry_sequence[this->routine_entry_state];
  std::vector<std::string>::const_iterator names_it, names_end;
  std::string cur_name = instr->get_name();
  for (names_it = next_names.begin(), names_end = next_names.end(); names_it !=
  names_end; names_it++) {
    if (cur_name == *names_it || *names_it == "") {
      if (this->routine_entry_state == 2) {
        this->routine_entry_state = 0;
        return true;
      }
      this->routine_entry_state++;
      return false;
    }
  }
  this->routine_entry_state = 0;
  return false;
} // is_routine_entry()

// -----------------------------------------------------------------------------

bool core_armcortexa9_funclt::Interface::is_routine_exit(const InstructionBase*
instr) throw() {

  std::vector<std::string> next_names = this->routine_exit_sequence[this->routine_exit_state];
  std::vector<std::string>::const_iterator names_it, names_end;
  std::string cur_name = instr->get_name();
  for (names_it = next_names.begin(), names_end = next_names.end(); names_it !=
  names_end; names_it++) {
    if (cur_name == *names_it || *names_it == "") {
      if (this->routine_exit_state == -1) {
        this->routine_exit_state = 0;
        return true;
      }
      this->routine_exit_state++;
      return false;
    }
  }
  this->routine_exit_state = 0;
  return false;
} // is_routine_exit()

// -----------------------------------------------------------------------------

boost::circular_buffer<HistoryInstrType>& core_armcortexa9_funclt::Interface::get_history()
{

  return this->history_instr_queue;
} // get_history()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::Interface::get_code_limit() {

  return this->PROGRAM_LIMIT;
} // get_code_limit()

// -----------------------------------------------------------------------------

int core_armcortexa9_funclt::Interface::get_id() const throw() {

  return (MP_ID);
} // get_id()

// -----------------------------------------------------------------------------

bool core_armcortexa9_funclt::Interface::is_little_endian() const throw() {

  return true;
} // is_little_endian()

// -----------------------------------------------------------------------------


// *****************************************************************************

