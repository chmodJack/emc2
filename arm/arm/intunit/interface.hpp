/***************************************************************************//**
*
*           _/       _/_/_/      _/         _/
*         _/_/      _/    _/    _/_/      __/
*       _/  _/     _/    _/    _/ _/    _/_/
*     _/_/_/_/    _/_/_/      _/  _/  _/ _/
*   _/      _/   _/    _/    _/   _/_/  _/
* _/        _/  _/      _/  _/    _/   _/
*
* @brief    This file is part of the SoCRocket ARM ISS generated by TRAP.
* @details  This SystemC model was automatically generated by running
*           $ python ARMArch.py
*           Please refer to the ARM TRAP source files for documentation.
* @author   Lillian Tadros (Technische Universitaet Dortmund)
* @date     2015-2016 Technische Universitaet Dortmund
*
*
* (c) 2014-2016
* Technische Universitaet Dortmund
* Institut fuer Roboterforschung
* Project Embedded Multi-Core Systems for Mixed Criticality
* Applications in Dynamic and Changeable Real-time Environments (EMC2)
*
*
* This file is part of ARMCortexA9.
*
* ARMCortexA9 is free software; you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License as
* published by the Free Software Foundation; either version 3 of the
* License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Affero General Public License for more details.
*
* You should have received a copy of the GNU Affero General Public
* License along with this program; if not, write to the
* Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
* or see <http://www.gnu.org/licenses/>.
*
*******************************************************************************/

#ifndef CORE_ARMCORTEXA9_FUNC_LT_INTERFACE_HPP
#define CORE_ARMCORTEXA9_FUNC_LT_INTERFACE_HPP

#include "registers.hpp"
#include "memory.hpp"

#include <modules/abi_if.hpp>
#include <systemc.h>
#include <boost/circular_buffer.hpp>
#include <modules/instruction.hpp>
#include <vector>
#include <common/report.hpp>
#include <string>


#define FUNC_MODEL
#define LT_IF

using namespace trap;

namespace core_armcortexa9_funclt {

  /**
  * @brief Interface Class
  *
  * Creates the interface used by TRAP-Gen tools to access the processor core.
  */
  class Interface : public ABIIf<unsigned> {
    /// @name Constructors and Destructors
    /// @{

    public:
    Interface(
        Registers& R, MemoryInterface& data_memory, bool& instr_executing,
        sc_event& instr_end_event, boost::circular_buffer<HistoryInstrType>&
        history_instr_queue, unsigned& PROGRAM_LIMIT);
    virtual ~Interface() {}


    /// @} Constructors and Destructors
    // -------------------------------------------------------------------------
    /// @name Methods
    /// @{

    public:
    unsigned num_gdb_regs() const throw();
    unsigned read_gdb_reg(const unsigned& gdb_id) const throw();
    void set_gdb_reg(const unsigned& new_value, const unsigned& gdb_id) throw();
    std::vector<unsigned> read_args() const throw();
    void set_args(const std::vector<unsigned>& args) throw();
    unsigned read_PC() const throw();
    void set_PC(const unsigned& new_value) throw();
    unsigned read_LR() const throw();
    void set_LR(const unsigned& new_value) throw();
    unsigned read_SP() const throw();
    void set_SP(const unsigned& new_value) throw();
    unsigned read_return_value() const throw();
    void set_return_value(const unsigned& new_value) throw();
    unsigned read_mem(const unsigned& address);
    unsigned char read_char_mem(const unsigned& address);
    void write_mem(const unsigned& address, unsigned datum);
    void write_char_mem(const unsigned& address, unsigned char datum);
    unsigned char* get_state() const throw();
    void set_state(unsigned char* state) throw();
    unsigned get_exit_value() throw();
    void set_exit_value(unsigned value) throw();
    bool is_executing_instr() const throw();
    void wait_instr_end() const throw();
    bool is_routine_entry(const InstructionBase* instr) throw();
    bool is_routine_exit(const InstructionBase* instr) throw();
    boost::circular_buffer<HistoryInstrType>& get_history();
    unsigned get_code_limit();
    int get_id() const throw();
    bool is_little_endian() const throw();

    /// @} Methods
    // -------------------------------------------------------------------------
    /// @name Data
    /// @{

    private:
    Registers& R;
    MemoryInterface& data_memory;
    bool& instr_executing;
    sc_event& instr_end_event;
    boost::circular_buffer<HistoryInstrType>& history_instr_queue;
    unsigned& PROGRAM_LIMIT;
    int routine_entry_state;
    int routine_exit_state;
    std::vector<std::vector<std::string> > routine_entry_sequence;
    std::vector<std::vector<std::string> > routine_exit_sequence;
    unsigned exit_value;

    /// @} Data
    // -------------------------------------------------------------------------

  }; // class Interface

  // ***************************************************************************

} // namespace core_armcortexa9_funclt

#endif // CORE_ARMCORTEXA9_FUNC_LT_INTERFACE_HPP
