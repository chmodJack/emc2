/***************************************************************************//**
*
*           _/       _/_/_/      _/         _/
*         _/_/      _/    _/    _/_/      __/
*       _/  _/     _/    _/    _/ _/    _/_/
*     _/_/_/_/    _/_/_/      _/  _/  _/ _/
*   _/      _/   _/    _/    _/   _/_/  _/
* _/        _/  _/      _/  _/    _/   _/
*
* @brief    This file is part of the SoCRocket ARM ISS generated by TRAP.
* @details  This SystemC model was automatically generated by running
*           $ python ARMArch.py
*           Please refer to the ARM TRAP source files for documentation.
* @author   Lillian Tadros (Technische Universitaet Dortmund)
* @date     2015-2016 Technische Universitaet Dortmund
*
*
* (c) 2014-2016
* Technische Universitaet Dortmund
* Institut fuer Roboterforschung
* Project Embedded Multi-Core Systems for Mixed Criticality
* Applications in Dynamic and Changeable Real-time Environments (EMC2)
*
*
* This file is part of ARMCortexA9.
*
* ARMCortexA9 is free software; you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License as
* published by the Free Software Foundation; either version 3 of the
* License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Affero General Public License for more details.
*
* You should have received a copy of the GNU Affero General Public
* License along with this program; if not, write to the
* Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
* or see <http://www.gnu.org/licenses/>.
*
*******************************************************************************/

#include "irqPorts.hpp"

#include <systemc.h>
#include <tlm.h>
#include <common/report.hpp>
#include <tlm_utils/multi_passthrough_target_socket.h>


using namespace core_armcortexa9_funclt;

core_armcortexa9_funclt::TLMIntrPort_1::TLMIntrPort_1(
    sc_module_name port_name,
    bool& irq_signal) :
  sc_module(port_name),
  irq_signal(irq_signal),
  target_socket(port_name) {

  this->target_socket.register_b_transport(this, &TLMIntrPort_1::b_transport);
  this->target_socket.register_nb_transport_fw(this, &TLMIntrPort_1::nb_transport_fw);
  this->target_socket.register_transport_dbg(this, &TLMIntrPort_1::transport_dbg);
  end_module();
} // TLMIntrPort_1()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::TLMIntrPort_1::b_transport(
    int tag,
    tlm::tlm_generic_payload& trans,
    sc_time& delay) {

  unsigned char* ptr = trans.get_data_ptr();
  sc_dt::uint64 adr = trans.get_address();
  if (*ptr == 0) {
    // Lower the interrupt.
    this->irq_signal = -1;
  } else {
    // Raise the interrupt.
    this->irq_signal = adr;
  }
  trans.set_response_status(tlm::TLM_OK_RESPONSE);
} // b_transport()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::TLMIntrPort_1::transport_dbg(
    int tag,
    tlm::tlm_generic_payload& trans) {

  unsigned char* ptr = trans.get_data_ptr();
  sc_dt::uint64 adr = trans.get_address();
  if (*ptr == 0) {
    // Lower the interrupt.
    this->irq_signal = -1;
  } else {
    // Raise the interrupt.
    this->irq_signal = adr;
  }
  trans.set_response_status(tlm::TLM_OK_RESPONSE);
  return trans.get_data_length();
} // transport_dbg()

// -----------------------------------------------------------------------------

tlm::tlm_sync_enum core_armcortexa9_funclt::TLMIntrPort_1::nb_transport_fw(
    int tag,
    tlm::tlm_generic_payload& trans,
    tlm::tlm_phase& phase,
    sc_time& delay) {

  THROW_EXCEPTION("Method not yet implemented.");
  return tlm::TLM_COMPLETED;
} // nb_transport_fw()

// -----------------------------------------------------------------------------


// *****************************************************************************

