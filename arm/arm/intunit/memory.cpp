/***************************************************************************//**
*
*           _/       _/_/_/      _/         _/
*         _/_/      _/    _/    _/_/      __/
*       _/  _/     _/    _/    _/ _/    _/_/
*     _/_/_/_/    _/_/_/      _/  _/  _/ _/
*   _/      _/   _/    _/    _/   _/_/  _/
* _/        _/  _/      _/  _/    _/   _/
*
* @brief    This file is part of the SoCRocket ARM ISS generated by TRAP.
* @details  This SystemC model was automatically generated by running
*           $ python ARMArch.py
*           Please refer to the ARM TRAP source files for documentation.
* @author   Lillian Tadros (Technische Universitaet Dortmund)
* @date     2015-2016 Technische Universitaet Dortmund
*
*
* (c) 2014-2016
* Technische Universitaet Dortmund
* Institut fuer Roboterforschung
* Project Embedded Multi-Core Systems for Mixed Criticality
* Applications in Dynamic and Changeable Real-time Environments (EMC2)
*
*
* This file is part of ARMCortexA9.
*
* ARMCortexA9 is free software; you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License as
* published by the Free Software Foundation; either version 3 of the
* License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Affero General Public License for more details.
*
* You should have received a copy of the GNU Affero General Public
* License along with this program; if not, write to the
* Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
* or see <http://www.gnu.org/licenses/>.
*
*******************************************************************************/

#include "memory.hpp"

#include <systemc.h>
#include <common/tools_if.hpp>
#include <common/report.hpp>


using namespace core_armcortexa9_funclt;

using namespace trap;

sc_dt::uint64 core_armcortexa9_funclt::MemoryInterface::read_dword_dbg(const
unsigned& address) const {

  return this->read_dword(address);
} // read_dword_dbg()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::MemoryInterface::read_word_dbg(const unsigned&
address) const {

  return this->read_word(address);
} // read_word_dbg()

// -----------------------------------------------------------------------------

unsigned short int core_armcortexa9_funclt::MemoryInterface::read_half_dbg(const
unsigned& address) const {

  return this->read_half(address);
} // read_half_dbg()

// -----------------------------------------------------------------------------

unsigned char core_armcortexa9_funclt::MemoryInterface::read_byte_dbg(const
unsigned& address) const {

  return this->read_byte(address);
} // read_byte_dbg()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::MemoryInterface::write_dword_dbg(
    const unsigned& address,
    sc_dt::uint64 datum) {

  this->write_dword(address, datum);
} // write_dword_dbg()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::MemoryInterface::write_word_dbg(
    const unsigned& address,
    unsigned datum) {

  this->write_word(address, datum);
} // write_word_dbg()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::MemoryInterface::write_half_dbg(
    const unsigned& address,
    unsigned short int datum) {

  this->write_half(address, datum);
} // write_half_dbg()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::MemoryInterface::write_byte_dbg(
    const unsigned& address,
    unsigned char datum) {

  this->write_byte(address, datum);
} // write_byte_dbg()

// -----------------------------------------------------------------------------


// *****************************************************************************

core_armcortexa9_funclt::LocalMemory::LocalMemory(unsigned size) :
  size(size) {

  this->memory = new char[size];
  this->debugger = NULL;
} // LocalMemory()

// -----------------------------------------------------------------------------

core_armcortexa9_funclt::LocalMemory::~LocalMemory() {

  delete [] this->memory;
} // ~LocalMemory()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LocalMemory::set_debugger(MemoryToolsIf<unsigned>*
debugger) {

  this->debugger = debugger;
} // set_debugger()

// -----------------------------------------------------------------------------

sc_dt::uint64 core_armcortexa9_funclt::LocalMemory::read_dword(const unsigned&
address) const throw() {

  if (address >= this->size) {
    THROW_ERROR("Address " << std::hex << std::showbase << address << " out of memory.");
  }

  sc_dt::uint64 datum = *(sc_dt::uint64*)(this->memory + (unsigned long)address);
#ifdef BIG_ENDIAN_BO
  unsigned datum1 = (unsigned)(datum);
  this->swap_endianess(datum1);
  unsigned datum2 = (unsigned)(datum >> 32);
  this->swap_endianess(datum2);
  datum = datum1 | (((sc_dt::uint64)datum2) << 32);
#endif

  return datum;
} // read_dword()

// -----------------------------------------------------------------------------

unsigned short int core_armcortexa9_funclt::LocalMemory::read_half(const unsigned&
address) const throw() {

  if (address >= this->size) {
    THROW_ERROR("Address " << std::hex << std::showbase << address << " out of memory.");
  }

  unsigned short int datum = *(unsigned short int*)(this->memory + (unsigned
  long)address);
  // Endianess conversion: The processor is always modeled with the host endianess.
  // In case they are different, the endianess is swapped.
#ifdef BIG_ENDIAN_BO
  this->swap_endianess(datum);
#endif

  return datum;
} // read_half()

// -----------------------------------------------------------------------------

unsigned char core_armcortexa9_funclt::LocalMemory::read_byte(const unsigned&
address) const throw() {

  if (address >= this->size) {
    THROW_ERROR("Address " << std::hex << std::showbase << address << " out of memory.");
  }

  unsigned char datum = *(unsigned char*)(this->memory + (unsigned long)address);

  return datum;
} // read_byte()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LocalMemory::read_instr(const unsigned&
address) const throw() {

  if (address >= this->size) {
    THROW_ERROR("Address " << std::hex << std::showbase << address << " out of memory.");
  }

  unsigned datum = *(unsigned*)(this->memory + (unsigned long)address);
  // Endianess conversion: The processor is always modeled with the host endianess.
  // In case they are different, the endianess is swapped.
#ifdef BIG_ENDIAN_BO
  this->swap_endianess(datum);
#endif

  return datum;
} // read_instr()

// -----------------------------------------------------------------------------

sc_dt::uint64 core_armcortexa9_funclt::LocalMemory::read_dword_dbg(const unsigned&
address) const throw() {

  if (address >= this->size) {
    THROW_ERROR("Address " << std::hex << std::showbase << address << " out of memory.");
  }

  sc_dt::uint64 datum = *(sc_dt::uint64*)(this->memory + (unsigned long)address);
#ifdef BIG_ENDIAN_BO
  unsigned datum1 = (unsigned)(datum);
  this->swap_endianess(datum1);
  unsigned datum2 = (unsigned)(datum >> 32);
  this->swap_endianess(datum2);
  datum = datum1 | (((sc_dt::uint64)datum2) << 32);
#endif

  return datum;
} // read_dword_dbg()

// -----------------------------------------------------------------------------

unsigned core_armcortexa9_funclt::LocalMemory::read_word_dbg(const unsigned&
address) const throw() {

  if (address >= this->size) {
    THROW_ERROR("Address " << std::hex << std::showbase << address << " out of memory.");
  }

  unsigned datum = *(unsigned*)(this->memory + (unsigned long)address);
  // Endianess conversion: The processor is always modeled with the host endianess.
  // In case they are different, the endianess is swapped.
#ifdef BIG_ENDIAN_BO
  this->swap_endianess(datum);
#endif

  return datum;
} // read_word_dbg()

// -----------------------------------------------------------------------------

unsigned short int core_armcortexa9_funclt::LocalMemory::read_half_dbg(const
unsigned& address) const throw() {

  if (address >= this->size) {
    THROW_ERROR("Address " << std::hex << std::showbase << address << " out of memory.");
  }

  unsigned short int datum = *(unsigned short int*)(this->memory + (unsigned
  long)address);
  // Endianess conversion: The processor is always modeled with the host endianess.
  // In case they are different, the endianess is swapped.
#ifdef BIG_ENDIAN_BO
  this->swap_endianess(datum);
#endif

  return datum;
} // read_half_dbg()

// -----------------------------------------------------------------------------

unsigned char core_armcortexa9_funclt::LocalMemory::read_byte_dbg(const unsigned&
address) const throw() {

  if (address >= this->size) {
    THROW_ERROR("Address " << std::hex << std::showbase << address << " out of memory.");
  }

  unsigned char datum = *(unsigned char*)(this->memory + (unsigned long)address);

  return datum;
} // read_byte_dbg()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LocalMemory::write_dword(
    const unsigned& address,
    sc_dt::uint64 datum) throw() {

  if (address >= this->size) {
    THROW_ERROR("Address " << std::hex << std::showbase << address << " out of memory.");
  }
  if (this->debugger != NULL) {
    this->debugger->notify_address(address, sizeof(datum));
  }

#ifdef BIG_ENDIAN_BO
  unsigned datum1 = (unsigned)(datum);
  this->swap_endianess(datum1);
  unsigned datum2 = (unsigned)(datum >> 32);
  this->swap_endianess(datum2);
  datum = datum1 | (((sc_dt::uint64)datum2) << 32);
#endif

  *(sc_dt::uint64*)(this->memory + (unsigned long)address) = datum;
} // write_dword()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LocalMemory::write_half(
    const unsigned& address,
    unsigned short int datum) throw() {

#ifdef BIG_ENDIAN_BO
#else
#endif
  if (address >= this->size) {
    THROW_ERROR("Address " << std::hex << std::showbase << address << " out of memory.");
  }
  if (this->debugger != NULL) {
    this->debugger->notify_address(address, sizeof(datum));
  }

  // Endianess conversion: The processor is always modeled with the host endianess.
  // In case they are different, the endianess is swapped.
#ifdef BIG_ENDIAN_BO
  this->swap_endianess(datum);
#endif

  *(unsigned short int*)(this->memory + (unsigned long)address) = datum;
} // write_half()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LocalMemory::write_byte(
    const unsigned& address,
    unsigned char datum) throw() {

#ifdef BIG_ENDIAN_BO
#else
#endif
  if (address >= this->size) {
    THROW_ERROR("Address " << std::hex << std::showbase << address << " out of memory.");
  }
  if (this->debugger != NULL) {
    this->debugger->notify_address(address, sizeof(datum));
  }


  *(unsigned char*)(this->memory + (unsigned long)address) = datum;
} // write_byte()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LocalMemory::write_dword_dbg(
    const unsigned& address,
    sc_dt::uint64 datum) throw() {

  if (address >= this->size) {
    THROW_ERROR("Address " << std::hex << std::showbase << address << " out of memory.");
  }
  if (this->debugger != NULL) {
    this->debugger->notify_address(address, sizeof(datum));
  }

#ifdef BIG_ENDIAN_BO
  unsigned datum1 = (unsigned)(datum);
  this->swap_endianess(datum1);
  unsigned datum2 = (unsigned)(datum >> 32);
  this->swap_endianess(datum2);
  datum = datum1 | (((sc_dt::uint64)datum2) << 32);
#endif

  *(sc_dt::uint64*)(this->memory + (unsigned long)address) = datum;
} // write_dword_dbg()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LocalMemory::write_word_dbg(
    const unsigned& address,
    unsigned datum) throw() {

  if (address >= this->size) {
    THROW_ERROR("Address " << std::hex << std::showbase << address << " out of memory.");
  }
  if (this->debugger != NULL) {
    this->debugger->notify_address(address, sizeof(datum));
  }

  // Endianess conversion: The processor is always modeled with the host endianess.
  // In case they are different, the endianess is swapped.
#ifdef BIG_ENDIAN_BO
  this->swap_endianess(datum);
#endif

  *(unsigned*)(this->memory + (unsigned long)address) = datum;
} // write_word_dbg()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LocalMemory::write_half_dbg(
    const unsigned& address,
    unsigned short int datum) throw() {

#ifdef BIG_ENDIAN_BO
#else
#endif
  if (address >= this->size) {
    THROW_ERROR("Address " << std::hex << std::showbase << address << " out of memory.");
  }
  if (this->debugger != NULL) {
    this->debugger->notify_address(address, sizeof(datum));
  }

  // Endianess conversion: The processor is always modeled with the host endianess.
  // In case they are different, the endianess is swapped.
#ifdef BIG_ENDIAN_BO
  this->swap_endianess(datum);
#endif

  *(unsigned short int*)(this->memory + (unsigned long)address) = datum;
} // write_half_dbg()

// -----------------------------------------------------------------------------

void core_armcortexa9_funclt::LocalMemory::write_byte_dbg(
    const unsigned& address,
    unsigned char datum) throw() {

#ifdef BIG_ENDIAN_BO
#else
#endif
  if (address >= this->size) {
    THROW_ERROR("Address " << std::hex << std::showbase << address << " out of memory.");
  }
  if (this->debugger != NULL) {
    this->debugger->notify_address(address, sizeof(datum));
  }


  *(unsigned char*)(this->memory + (unsigned long)address) = datum;
} // write_byte_dbg()

// -----------------------------------------------------------------------------


// *****************************************************************************

