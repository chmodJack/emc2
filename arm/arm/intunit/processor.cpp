/***************************************************************************//**
*
*           _/       _/_/_/      _/         _/
*         _/_/      _/    _/    _/_/      __/
*       _/  _/     _/    _/    _/ _/    _/_/
*     _/_/_/_/    _/_/_/      _/  _/  _/ _/
*   _/      _/   _/    _/    _/   _/_/  _/
* _/        _/  _/      _/  _/    _/   _/
*
* @brief    This file is part of the SoCRocket ARM ISS generated by TRAP.
* @details  This SystemC model was automatically generated by running
*           $ python ARMArch.py
*           Please refer to the ARM TRAP source files for documentation.
* @author   Lillian Tadros (TUDO ETIT IRF)
* @date     2014-12-01 tadros: Initial ARM Cortex A9 (ARMv7-A) version
*
*
* (c) 2014-2016
* Technische Universitaet Dortmund
* Institut fuer Roboterforschung
* Project Embedded Multi-Core Systems for Mixed Criticality
* Applications in Dynamic and Changeable Real-time Environments (EMC2)
*
*
* This file is part of ARMCortexA9.
*
* ARMCortexA9 is free software; you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License as
* published by the Free Software Foundation; either version 3 of the
* License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Affero General Public License for more details.
*
* You should have received a copy of the GNU Affero General Public
* License along with this program; if not, write to the
* Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
* or see <http://www.gnu.org/licenses/>.
*
*******************************************************************************/

#include "arm/intunit/processor.hpp"
#include "arm/intunit/instructions.hpp"
#include "arm/intunit/interface.hpp"
#include "arm/intunit/registers.hpp"
#include "arm/intunit/memory.hpp"
#include "arm/intunit/irqPorts.hpp"
#include "arm/intunit/decoder.hpp"

#include <systemc.h>
#include <common/report.hpp>
#include <string>
#include <common/tools_if.hpp>
#include <boost/circular_buffer.hpp>
#include <modules/instruction.hpp>
#include <iostream>
#include <fstream>

#ifdef __GNUC__
#ifdef __GNUC_MINOR__
#if (__GNUC__ >= 4 && __GNUC_MINOR__ >= 3)
#include <tr1/unordered_map>
#define template_map std::tr1::unordered_map
#else
#include <ext/hash_map>
#define  template_map __gnu_cxx::hash_map
#endif
#else
#include <ext/hash_map>
#define  template_map __gnu_cxx::hash_map
#endif
#else
#ifdef _WIN32
#include <hash_map>
#define  template_map stdext::hash_map
#else
#include <map>
#define  template_map std::map
#endif
#endif


using namespace core_armcortexa9_lt;

using namespace trap;

SC_HAS_PROCESS(CoreARMCortexA9LT);
core_armcortexa9_lt::CoreARMCortexA9LT::CoreARMCortexA9LT(
    sc_module_name name, MemoryInterface *memory, bool _extensions_vfp, bool _extensions_simd, bool
    _extensions_cp, bool _extensions_virtualization, bool _extensions_security,
    bool _extensions_large_physical_address, bool _extensions_mp, bool _extensions_debug,
    bool _ismode_arm, bool _ismode_thumb, bool _ismode_jazelle, bool _ismode_thumbee)
    :
  sc_module(name),
  extensions_vfp(_extensions_vfp),
  extensions_simd(_extensions_simd),
  extensions_cp(_extensions_cp),
  extensions_virtualization(_extensions_virtualization),
  extensions_security(_extensions_security),
  extensions_large_physical_address(_extensions_large_physical_address),
  extensions_mp(_extensions_mp),
  extensions_debug(_extensions_debug),
  ismode_arm(_ismode_arm),
  ismode_thumb(_ismode_thumb),
  ismode_jazelle(_ismode_jazelle),
  ismode_thumbee(_ismode_thumbee),
  R(MPROC_ID, ENTRY_POINT),
  mem(memory),
  data_memory(*mem),
  IRQ_port("IRQ_port", IRQ),
  FIQ_port("FIQ_port", FIQ) {
  this->reset_called = false;
  CoreARMCortexA9LT::num_instances++;
  // Initialize the array containing the initial instance of the instructions.
  this->INSTRUCTIONS = new Instruction*[162];
  this->INSTRUCTIONS[0] = new ADD_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[1] = new ADD_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[2] = new ADD_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[3] = new ADC_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[4] = new ADC_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[5] = new ADC_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[6] = new SUB_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[7] = new SUB_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[8] = new SUB_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[9] = new SBC_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[10] = new SBC_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[11] = new SBC_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[12] = new RSB_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[13] = new RSB_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[14] = new RSB_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[15] = new RSC_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[16] = new RSC_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[17] = new RSC_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[18] = new USHQADD(R, data_memory, total_cycles);
  this->INSTRUCTIONS[19] = new USHQSUB(R, data_memory, total_cycles);
  this->INSTRUCTIONS[20] = new USADA8(R, data_memory, total_cycles);
  this->INSTRUCTIONS[21] = new USXTAHB(R, data_memory, total_cycles);
  this->INSTRUCTIONS[22] = new USHQASX(R, data_memory, total_cycles);
  this->INSTRUCTIONS[23] = new USHQSAX(R, data_memory, total_cycles);
  this->INSTRUCTIONS[24] = new USSAT(R, data_memory, total_cycles);
  this->INSTRUCTIONS[25] = new USSAT16(R, data_memory, total_cycles);
  this->INSTRUCTIONS[26] = new QDADDSUB(R, data_memory, total_cycles);
  this->INSTRUCTIONS[27] = new MUL(R, data_memory, total_cycles);
  this->INSTRUCTIONS[28] = new SMMUL(R, data_memory, total_cycles);
  this->INSTRUCTIONS[29] = new MULL(R, data_memory, total_cycles);
  this->INSTRUCTIONS[30] = new UMAAL(R, data_memory, total_cycles);
  this->INSTRUCTIONS[31] = new SMULBW(R, data_memory, total_cycles);
  this->INSTRUCTIONS[32] = new SMMULD(R, data_memory, total_cycles);
  this->INSTRUCTIONS[33] = new DIV(R, data_memory, total_cycles);
  this->INSTRUCTIONS[34] = new AND_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[35] = new AND_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[36] = new AND_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[37] = new EOR_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[38] = new EOR_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[39] = new EOR_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[40] = new MVN_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[41] = new MVN_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[42] = new MVN_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[43] = new ORR_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[44] = new ORR_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[45] = new ORR_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[46] = new TEQ_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[47] = new TEQ_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[48] = new TEQ_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[49] = new TST_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[50] = new TST_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[51] = new TST_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[52] = new ASR_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[53] = new ASR_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[54] = new LSR_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[55] = new LSR_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[56] = new LSL_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[57] = new LSL_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[58] = new ROR_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[59] = new ROR_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[60] = new BFCI(R, data_memory, total_cycles);
  this->INSTRUCTIONS[61] = new BIC_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[62] = new BIC_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[63] = new BIC_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[64] = new CLZ(R, data_memory, total_cycles);
  this->INSTRUCTIONS[65] = new PKH(R, data_memory, total_cycles);
  this->INSTRUCTIONS[66] = new RBIT(R, data_memory, total_cycles);
  this->INSTRUCTIONS[67] = new REV(R, data_memory, total_cycles);
  this->INSTRUCTIONS[68] = new REV16(R, data_memory, total_cycles);
  this->INSTRUCTIONS[69] = new REVSH(R, data_memory, total_cycles);
  this->INSTRUCTIONS[70] = new USBFX(R, data_memory, total_cycles);
  this->INSTRUCTIONS[71] = new SEL(R, data_memory, total_cycles);
  this->INSTRUCTIONS[72] = new CMN_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[73] = new CMN_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[74] = new CMN_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[75] = new CMP_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[76] = new CMP_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[77] = new CMP_sr(R, data_memory, total_cycles);
  this->INSTRUCTIONS[78] = new LDR_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[79] = new LDR_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[80] = new LDREX(R, data_memory, total_cycles);
  this->INSTRUCTIONS[81] = new LDRB_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[82] = new LDRB_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[83] = new LDREXB(R, data_memory, total_cycles);
  this->INSTRUCTIONS[84] = new LDRSB_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[85] = new LDRSB_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[86] = new LDRH_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[87] = new LDRH_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[88] = new LDREXH(R, data_memory, total_cycles);
  this->INSTRUCTIONS[89] = new LDRSH_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[90] = new LDRSH_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[91] = new LDRD_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[92] = new LDRD_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[93] = new LDREXD(R, data_memory, total_cycles);
  this->INSTRUCTIONS[94] = new STR_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[95] = new STR_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[96] = new STREX(R, data_memory, total_cycles);
  this->INSTRUCTIONS[97] = new STRB_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[98] = new STRB_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[99] = new STREXB(R, data_memory, total_cycles);
  this->INSTRUCTIONS[100] = new STRH_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[101] = new STRH_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[102] = new STREXH(R, data_memory, total_cycles);
  this->INSTRUCTIONS[103] = new STRD(R, data_memory, total_cycles);
  this->INSTRUCTIONS[104] = new STRD_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[105] = new STREXD(R, data_memory, total_cycles);
  this->INSTRUCTIONS[106] = new LDM(R, data_memory, total_cycles);
  this->INSTRUCTIONS[107] = new LDMIB(R, data_memory, total_cycles);
  this->INSTRUCTIONS[108] = new LDMDA(R, data_memory, total_cycles);
  this->INSTRUCTIONS[109] = new LDMDB(R, data_memory, total_cycles);
  this->INSTRUCTIONS[110] = new POP_single(R, data_memory, total_cycles);
  this->INSTRUCTIONS[111] = new POP_block(R, data_memory, total_cycles);
  this->INSTRUCTIONS[112] = new STM(R, data_memory, total_cycles);
  this->INSTRUCTIONS[113] = new STMIB(R, data_memory, total_cycles);
  this->INSTRUCTIONS[114] = new STMDA(R, data_memory, total_cycles);
  this->INSTRUCTIONS[115] = new STMDB(R, data_memory, total_cycles);
  this->INSTRUCTIONS[116] = new PUSH_single(R, data_memory, total_cycles);
  this->INSTRUCTIONS[117] = new PUSH_block(R, data_memory, total_cycles);
  this->INSTRUCTIONS[118] = new MOV_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[119] = new MOV_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[120] = new MOVW(R, data_memory, total_cycles);
  this->INSTRUCTIONS[121] = new MOVT(R, data_memory, total_cycles);
  this->INSTRUCTIONS[122] = new SWP(R, data_memory, total_cycles);
  this->INSTRUCTIONS[123] = new MRS(R, data_memory, total_cycles);
  this->INSTRUCTIONS[124] = new MSR_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[125] = new MSR_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[126] = new B(R, data_memory, total_cycles);
  this->INSTRUCTIONS[127] = new BL(R, data_memory, total_cycles);
  this->INSTRUCTIONS[128] = new BX(R, data_memory, total_cycles);
  this->INSTRUCTIONS[129] = new BLX_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[130] = new BLX_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[131] = new BXJ(R, data_memory, total_cycles);
  this->INSTRUCTIONS[132] = new BKPT(R, data_memory, total_cycles);
  this->INSTRUCTIONS[133] = new CLREX(R, data_memory, total_cycles);
  this->INSTRUCTIONS[134] = new CPS(R, data_memory, total_cycles);
  this->INSTRUCTIONS[135] = new DBG(R, data_memory, total_cycles);
  this->INSTRUCTIONS[136] = new DMB(R, data_memory, total_cycles);
  this->INSTRUCTIONS[137] = new DSB(R, data_memory, total_cycles);
  this->INSTRUCTIONS[138] = new ISB(R, data_memory, total_cycles);
  this->INSTRUCTIONS[139] = new NOP(R, data_memory, total_cycles);
  this->INSTRUCTIONS[140] = new PLI_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[141] = new PLI_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[142] = new PLD_i(R, data_memory, total_cycles);
  this->INSTRUCTIONS[143] = new PLD_r(R, data_memory, total_cycles);
  this->INSTRUCTIONS[144] = new RFE(R, data_memory, total_cycles);
  this->INSTRUCTIONS[145] = new SETEND(R, data_memory, total_cycles);
  this->INSTRUCTIONS[146] = new SEV(R, data_memory, total_cycles);
  this->INSTRUCTIONS[147] = new SRS(R, data_memory, total_cycles);
  this->INSTRUCTIONS[148] = new SVC(R, data_memory, total_cycles);
  this->INSTRUCTIONS[149] = new UDF(R, data_memory, total_cycles);
  this->INSTRUCTIONS[150] = new WFE(R, data_memory, total_cycles);
  this->INSTRUCTIONS[151] = new WFI(R, data_memory, total_cycles);
  this->INSTRUCTIONS[152] = new YIELD(R, data_memory, total_cycles);
  this->INSTRUCTIONS[153] = new SMC(R, data_memory, total_cycles);
  this->INSTRUCTIONS[154] = new CDP(R, data_memory, total_cycles);
  this->INSTRUCTIONS[155] = new LDC(R, data_memory, total_cycles);
  this->INSTRUCTIONS[156] = new STC(R, data_memory, total_cycles);
  this->INSTRUCTIONS[157] = new MCR(R, data_memory, total_cycles);
  this->INSTRUCTIONS[158] = new MCRR(R, data_memory, total_cycles);
  this->INSTRUCTIONS[159] = new MRC(R, data_memory, total_cycles);
  this->INSTRUCTIONS[160] = new MRRC(R, data_memory, total_cycles);
  this->INSTRUCTIONS[161] = new InvalidInstr(R, data_memory, total_cycles);
  this->IRQ_instr = new IRQIntrInstruction(R, data_memory, total_cycles, this->IRQ);
  this->FIQ_instr = new FIQIntrInstruction(R, data_memory, total_cycles, this->FIQ);
  this->total_cycles = 0;
  this->history_en = false;
  this->history_instr_queue.set_capacity(1000);
  this->history_undumped_elements = 0;
  this->num_instructions = 0;
  this->ENTRY_POINT = 0;
  this->MPROC_ID = 0;
  this->PROGRAM_LIMIT = 0;
  this->PROGRAM_START = 0;
  this->ABIIf = new Interface(this->PROGRAM_LIMIT, this->data_memory, this->R,
  this->instr_executing, this->history_instr_queue);
  SC_THREAD(main_loop);
  this->total_cycles = 0;
  end_module();
} // CoreARMCortexA9LT()

/// ----------------------------------------------------------------------------

core_armcortexa9_lt::CoreARMCortexA9LT::~CoreARMCortexA9LT() {
  CoreARMCortexA9LT::num_instances--;
  for (int i = 0; i < 162; i++) {
    delete this->INSTRUCTIONS[i];
  }
  delete [] this->INSTRUCTIONS;
  template_map<unsigned, CacheElem>::const_iterator cache_it, cache_end;
  for (cache_it = this->instr_cache.begin(), cache_end = this->instr_cache.end();
  cache_it != cache_end; cache_it++) {
    delete cache_it->second.instr;
  }
  delete this->ABIIf;
  delete this->IRQ_instr;
  delete this->FIQ_instr;
#ifdef ENABLE_HISTORY
  if (this->history_en) {
    // In case a queue dump file has been specified, check if it needs to be
    // saved.
    if (this->history_file) {
      if (this->history_undumped_elements > 0) {
        std::vector<std::string> history_vector;
        boost::circular_buffer<HistoryInstrType>::const_reverse_iterator history_it,
        history_end;
        unsigned history_read = 0;
        for (history_read = 0, history_it = this->history_instr_queue.rbegin(),
        history_end = this->history_instr_queue.rend(); history_it != history_end
        && history_read < this->history_undumped_elements; history_it++, history_read++)
        {
          history_vector.push_back(history_it->get_mnemonic());
        }
        std::vector<std::string>::const_reverse_iterator history_vector_it,
        history_vector_end;
        for (history_vector_it = history_vector.rbegin(), history_vector_end =
        history_vector.rend(); history_vector_it != history_vector_end; history_vector_it++)
        {
          this->history_file <<  *history_vector_it << std::endl;
        }
      }
      this->history_file.flush();
      this->history_file.close();
    }
  }
#endif
} // ~CoreARMCortexA9LT()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::CoreARMCortexA9LT::main_loop() {
  template_map<unsigned, CacheElem >::iterator icache_end = this->instr_cache.end();

  while(true) {
    unsigned num_cycles = 0;
    this->instr_executing = true;
    if (FIQ) {
      std::cerr << "Received interrupt " << std::hex << std::showbase << IRQ <<
      '.' << std::endl;this->FIQ_instr->set_interrupt_value(FIQ);
      try {
        num_cycles = this->FIQ_instr->behavior();
      }
      catch(annul_exception& etc) {
        this->FIQ_instr->print_trace();
        std::cerr << "Skipped Instruction " << this->FIQ_instr->get_name() <<
        '.' << std::endl;
        num_cycles = 0;
      }

    }
    else if (IRQ) {
      std::cerr << "Received interrupt " << std::hex << std::showbase << IRQ <<
      '.' << std::endl;this->IRQ_instr->set_interrupt_value(IRQ);
      try {
        num_cycles = this->IRQ_instr->behavior();
      }
      catch(annul_exception& etc) {
        this->IRQ_instr->print_trace();
        std::cerr << "Skipped Instruction " << this->IRQ_instr->get_name() <<
        '.' << std::endl;
        num_cycles = 0;
      }

    }
    else {
      unsigned cur_PC = RB[15];
#ifdef ENABLE_HISTORY
      HistoryInstrType instr_queue_elem;
      if (this->history_en) {

        instr_queue_elem.address = cur_PC;
      }
#endif
      unsigned bitstring = this->data_memory.read_word(cur_PC);
      std::cerr << "Current PC: " << std::hex << std::showbase << cur_PC <<
      '.' << std::endl;
      template_map< unsigned, CacheElem >::iterator cached_instr = this->instr_cache.find(bitstring);
      if (cached_instr != icache_end) {
        Instruction* cur_instr_ptr = cached_instr->second.instr;
        // Instruction found, call it.
        if (cur_instr_ptr != NULL) {
#ifdef ENABLE_HISTORY
          if (this->history_en) {
            instr_queue_elem.name = cur_instr_ptr->get_name();
            instr_queue_elem.mnemonic = cur_instr_ptr->get_mnemonic();
          }
#endif
          try {
#ifndef DISABLE_TOOLS
            if (!(this->tool_manager.issue(cur_PC, cur_instr_ptr))) {
#endif
              num_cycles = cur_instr_ptr->behavior();
              cur_instr_ptr->print_trace();
#ifndef DISABLE_TOOLS
            }
            else {
              std::cerr << "Instruction anulled by tools." << std::endl <<
              std::endl;
            }
#endif
          }
          catch(annul_exception& etc) {
            cur_instr_ptr->print_trace();
            std::cerr << "Skipped Instruction " << cur_instr_ptr->get_name() <<
            '.' << std::endl;
            num_cycles = 0;
          }
        } else {
          unsigned& cur_count = cached_instr->second.count;
          int instr_id = this->decoder.decode(bitstring);
          Instruction* instr = this->INSTRUCTIONS[instr_id];
          instr->set_params(bitstring);
#ifdef ENABLE_HISTORY
          if (this->history_en) {
            instr_queue_elem.name = instr->get_name();
            instr_queue_elem.mnemonic = instr->get_mnemonic();
          }
#endif
          try {
#ifndef DISABLE_TOOLS
            if (!(this->tool_manager.issue(cur_PC, instr))) {
#endif
              num_cycles = instr->behavior();
              instr->print_trace();
#ifndef DISABLE_TOOLS
            }
            else {
              std::cerr << "Instruction anulled by tools." << std::endl <<
              std::endl;
            }
#endif
          }
          catch(annul_exception& etc) {
            instr->print_trace();
            std::cerr << "Skipped Instruction " << instr->get_name() << '.' <<
            std::endl;
            num_cycles = 0;
          }
          if (cur_count < 256) {
            cur_count++;
          } else {
            // Add the instruction to the i-cache.
            cached_instr->second.instr = instr;
            this->INSTRUCTIONS[instr_id] = instr->replicate();
          }
        }
      } else {
        // Current instruction is not present in the cache. Perform regular
        // decoding.
        int instr_id = this->decoder.decode(bitstring);
        Instruction* instr = this->INSTRUCTIONS[instr_id];
        instr->set_params(bitstring);
#ifdef ENABLE_HISTORY
        if (this->history_en) {
          instr_queue_elem.name = instr->get_name();
          instr_queue_elem.mnemonic = instr->get_mnemonic();
        }
#endif
        try {
#ifndef DISABLE_TOOLS
          if (!(this->tool_manager.issue(cur_PC, instr))) {
#endif
            num_cycles = instr->behavior();
            instr->print_trace();
#ifndef DISABLE_TOOLS
          }
          else {
            std::cerr << "Instruction anulled by tools." << std::endl << std::endl;
          }
#endif
        }
        catch(annul_exception& etc) {
          instr->print_trace();
          std::cerr << "Skipped Instruction " << instr->get_name() << '.' <<
          std::endl;
          num_cycles = 0;
        }
        this->instr_cache.insert(std::pair<unsigned, CacheElem>(bitstring,
        CacheElem()));
        icache_end = this->instr_cache.end();
      }
#ifdef ENABLE_HISTORY
      if (this->history_en) {
        // Add current instruction to history queue.
        this->history_instr_queue.push_back(instr_queue_elem);
        // In case a queue dump file has been specified, check if it needs to be
        // saved.
        if (this->history_file) {
          this->history_undumped_elements++;
          if (history_undumped_elements == this->history_instr_queue.capacity())
          {
            boost::circular_buffer<HistoryInstrType>::const_iterator history_it,
            history_end;
            for (history_it = this->history_instr_queue.begin(), history_end =
            this->history_instr_queue.end(); history_it != history_end; history_it++)
            {
              this->history_file << history_it->get_mnemonic() << std::endl;
            }
            this->history_undumped_elements = 0;
          }
        }
      }
#endif
    }
    this->total_cycles += (num_cycles + 1);
    this->instr_executing = false;
    this->num_instructions++;

    ID_AFR0.clock_cycle();
  }
} // main_loop()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::CoreARMCortexA9LT::reset() {
  this->R.reset();
  this->RB[15] = this->ENTRY_POINT;
  this->IRQ = 0;
  this->FIQ = 0;

  this->reset_called = true;
} // reset()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::CoreARMCortexA9LT::end_of_elaboration() {
  if (!this->reset_called) {
    this->reset();
  }
  this->reset_called = false;
} // end_of_elaboration()

/// ----------------------------------------------------------------------------

Instruction* core_armcortexa9_lt::CoreARMCortexA9LT::decode(unsigned bitstring)
{
  int instr_id = this->decoder.decode(bitstring);
  if (instr_id >= 0) {
    Instruction* instr = this->INSTRUCTIONS[instr_id];
    instr->set_params(bitstring);
    return instr;
  }
  return NULL;
} // decode()

/// ----------------------------------------------------------------------------

Interface& core_armcortexa9_lt::CoreARMCortexA9LT::get_interface() {
  return *this->ABIIf;
} // get_interface()

/// ----------------------------------------------------------------------------

void core_armcortexa9_lt::CoreARMCortexA9LT::enable_history(std::string file_name)
{
  this->history_en = true;
  this->history_file.open(file_name.c_str(), ios::out | ios::ate);
} // enable_history()

/// ----------------------------------------------------------------------------

int core_armcortexa9_lt::CoreARMCortexA9LT::num_instances = 0;

/// ****************************************************************************

