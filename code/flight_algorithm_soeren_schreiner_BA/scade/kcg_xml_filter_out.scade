/* $*************** KCG Version 6.1.2 (build i5) ****************
** Command: x2s612 D:/Bachelor-SVN/Programmcode/scade/Package1.xscade
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */

/* xscade source: D:/Bachelor-SVN/Programmcode/scade/Package1.xscade */
package Main
  const WEIGHT_NEW_VALUE : real = 0.5;
  
  const PI : real = 3.14159265;
  
  const PI180 : real = 0.01745329;
  
  const ACC_CONSTANT : real = 0.04905;
  
  const GYRO_CONSTANT : real = 0.84;
  
  const TIMERPERIOD : real = 0.002;
  
  const GRAVITY : real = 9.81;
  
  const BAROMETER_CONSTANT : real = 0.025;
  
  const TIMERCYCLES : real = 500.0;
  
  const ANGLES_INIT : angleValues = { theta:0.0, phi:0.0, psi:0.0 };
  
  const MIN_GAS_REAL : real = 200.0;
  
  const MAX_GAS_REAL : real = 2047.0;
  
  const
    RC_NORMALIZING : rcNormalizingValues
      = {
          thrustMin:0.0265251989,
          thrust:0.001428571,
          yaw:0.002857142,
          pitch:0.002857142,
          roll:0.002857142 };
  
  const
    RC_OFFSET_VALUES : rcValues = { thrust:162, yaw:512, pitch:512, roll:512 };
  
  const
    RC_MAX_VALUES : rcValuesReal
      = { thrust:1885.0, yaw:25.0, pitch:25.0, roll:25.0 };
  
  const GYRO_CORRECTION : real = 0.005;
  
  const
    CONTROLLER_THETA_PHI_SETTINGS : controllerSettings
      = { Kp:60.0, Ki:0.4, Kd:0.0, Ks:15.0 };
  
  const
    CONTROLLER_PSI_SETTINGS : controllerSettings
      = { Kp:50.0, Ki:0.0, Kd:0.0, Ks:15.0 };
  
  const
    CONTROLLER_HEIGHT_SETTINGS : controllerSettings
      = { Kp:35.0, Ki:0.015, Kd:0.0, Ks:9.0 };
  
  const
    MOTOR_VALUES_DEFAULT : motorValues
      = { motorFront:0, motorRear:0, motorLeft:0, motorRight:0 };
  
  const
    ANALOG_OFFSET_VALUES_DEFAULT : analogOffsetValues
      = {
          accX:0.0,
          accY:0.0,
          accZ:0.0,
          gyroPitch:0.0,
          gyroRoll:0.0,
          gyroYaw:0.0,
          barometer:0.0 };
  
  const I_LIMITATION_MIN : real = -500.0;
  
  const I_LIMITATION_MAX : real = 500.0;
  
  const ZERO_REAL : real = 0.0;
  
  const MAX_GAS : int = 2047;
  
  const MIN_GAS : int = 200;
  
  const ZERO : int = 0;
  
  const ANGLE_360_REAL : real = 360.0;
  
  const ANGLE_N180_Real : real = -180.0;
  
  const ANGLE_180_REAL : real = 180.0;
  
  const SENSITIVITY_GAS_STICK_HC : real = 100.0;
  
  const I_LIMITATION_MAX_HC : real = 1885.0;
  
  const I_LIMITATION_MIN_HC : real = 150.0;
  
  const SENSITIVITY_STICKS_SP : int = 6;
  
  const KALMAN_HEIGHT : real = 0.3;
  
  const KALMAN_HEIGHT_SPEED : real = 0.01;
  
  const ONE_N_REAL : real = -1.0;
  
  const ONE_REAL : real = 1.0;
  
  const KALMAN_THETA_PHI_CONSTANT : real = 0.000005;
  
  const KALMAN_THETA_PHI_MAX : real = 0.001;
  
  const
    SETPOINT_VALUES_DEFAULT : rcValuesReal
      = { thrust:0.0, yaw:0.0, pitch:0.0, roll:0.0 };
  
  const KALMAN_PSI_CONSTANT : real = 0.000005;
  
  const KALMAN_PSI_MAX : real = 0.002;
  
  const MAX_AC_GAS : real = 1200.0;
  
  const MIN_AC_GAS : real = -1200.0;
  
  const MIN_HC_GAS : real = 200.0;
  
  const MAX_HC_GAS : real = 1885.0;
  
  const
    ATTITUDE_CONTROLLER_VALUES_DEFAULT : attitudeController
      = {
          theta:{ Kp:0.0, Ki:0.0, Kd:0.0, Ks:0.0 },
          thetaFinal:0.0,
          phi:{ Kp:0.0, Ki:0.0, Kd:0.0, Ks:0.0 },
          phiFinal:0.0,
          psi:{ Kp:0.0, Ki:0.0, Kd:0.0, Ks:0.0 },
          psiFinal:0.0 };
  
  const
    HEIGHT_CONTROLLER_VALUES_DEFAULT : heightController
      = {
          thrust:{ Kp:0.0, Ki:0.0, Kd:0.0, Ks:0.0 },
          thrustFinal:0.0,
          setpoint:0.0,
          activated:false };
  
  const SCALING_GAS_STICK_HC : real = 280.0;
  
  const
    ACCELERTION_ANGLES_DEFAULT : accelerationAngles
      = { accTheta:0.0, accPhi:0.0 };
  
  const TWO_REAL : real = 2.0;
  
  const DEACTIVATE_OFFSET_CORRECTION : real = 10.0;
  
  const STOP_GIER : real = 230.0;
  
  const LOST_CONNECTION_HC_SETPOINT : real = -0.5;
  
  const ANGLE_90_REAL : real = 90.0;
  
  const ANGLE_N90_REAL : real = -90.0;
  
  const GYRO_CORRECTION_DIFF : real = 1.0;
  
  type
    motorValues = {
      motorFront : int,
      motorRear : int,
      motorLeft : int,
      motorRight : int
    };
  
  type angleValues = { theta : real, phi : real, psi : real };
  
  type
    analogValues = {
      accX : int,
      accY : int,
      accZ : int,
      gyroPitch : int,
      gyroRoll : int,
      gyroYaw : int,
      barometer : int,
      compass : real
    };
  
  type
    analogOffsetValues = {
      accX : real,
      accY : real,
      accZ : real,
      gyroPitch : real,
      gyroRoll : real,
      gyroYaw : real,
      barometer : real
    };
  
  type
    analogValuesReal = {
      accX : real,
      accY : real,
      accZ : real,
      gyroPitch : real,
      gyroRoll : real,
      gyroYaw : real,
      barometer : real,
      compass : real
    };
  
  type
    sinCosValues = {
      sinTheta : real,
      cosTheta : real,
      sinPhi : real,
      cosPhi : real,
      sinPsi : real,
      cosPsi : real
    };
  
  type accelerations = { accX : real, accY : real, accZ : real };
  
  type accelerationAngles = { accTheta : real, accPhi : real };
  
  type rcValues = { thrust : int, yaw : int, pitch : int, roll : int };
  
  type rcValuesReal = { thrust : real, yaw : real, pitch : real, roll : real };
  
  type
    rcFlags = { motorsOn : bool, heightControl : bool, lostConnection : bool };
  
  type
    rcNormalizingValues = {
      thrustMin : real,
      thrust : real,
      yaw : real,
      pitch : real,
      roll : real
    };
  
  type controllerSettings = { Kp : real, Ki : real, Kd : real, Ks : real };
  
  type
    attitudeController = {
      theta : controllerSettings,
      thetaFinal : real,
      phi : controllerSettings,
      phiFinal : real,
      psi : controllerSettings,
      psiFinal : real
    };
  
  type
    heightController = {
      thrust : controllerSettings,
      thrustFinal : real,
      setpoint : real,
      activated : bool
    };
  
  node main(
      rcFlags : Main::rcFlags;
      rcValues : Main::rcValues;
      analogValues : Main::analogValues;
      analogOffsetValues : Main::analogOffsetValues)
    returns (
      motorValues : Main::motorValues default = MOTOR_VALUES_DEFAULT;
      anlgeValues : angleValues default = ANGLES_INIT;
      anlgeSpeedValues : angleValues default = ANGLES_INIT;
      heightValue : real default = 0.0;
      heightSpeedValue : real default = 0.0;
      analogCorrectedOffsetValues
      : Main::analogOffsetValues
      default = ANALOG_OFFSET_VALUES_DEFAULT;
      setpointValues : rcValuesReal default = SETPOINT_VALUES_DEFAULT;
      attitudeControllerValues
      : attitudeController
      default = ATTITUDE_CONTROLLER_VALUES_DEFAULT;
      heightControllerValues
      : heightController
      default = HEIGHT_CONTROLLER_VALUES_DEFAULT;
      accelerationAngleValues
      : accelerationAngles
      default = ACCELERTION_ANGLES_DEFAULT)
  var
    _L2 : Main::rcFlags;
    _L3 : Main::rcValues;
    _L4 : Main::analogValues;
    _L5 : Main::analogOffsetValues;
    _L8 : Main::motorValues;
    _L9 : angleValues;
    _L10 : angleValues;
    _L11 : real;
    _L12 : real;
    _L13 : Main::analogOffsetValues;
    _L14 : rcValuesReal;
    _L15 : attitudeController;
    _L16 : heightController;
    _L17 : accelerationAngles;
  let
    _L2= rcFlags;
    _L3= rcValues;
    _L4= analogValues;
    _L5= analogOffsetValues;
    anlgeSpeedValues= _L10;
    anlgeValues= _L9;
    heightSpeedValue= _L12;
    heightControllerValues= _L16;
    analogCorrectedOffsetValues= _L13;
    _L8, _L13, _L9, _L10, _L11, _L12, _L14, _L15, _L16, _L17=
      #1 Controller::controller(_L2, _L3, _L4, _L5);
    setpointValues= _L14;
    attitudeControllerValues= _L15;
    heightValue= _L11;
    motorValues= _L8;
    accelerationAngleValues= _L17;
  tel
  
end;

/* $*************** KCG Version 6.1.2 (build i5) ****************
** -
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */
/* $*************** KCG Version 6.1.2 (build i5) ****************
** Command: x2s612 D:/Bachelor-SVN/Programmcode/scade/Package2.xscade
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */

/* xscade source: D:/Bachelor-SVN/Programmcode/scade/Package2.xscade */
package Controller
  package HeightController
    node heightController(
        rcFlags : Main::rcFlags;
        setpointValues : Main::rcValuesReal;
        heightValue : real;
        heightSpeedValue : real)
      returns (thrust : real; heightControllerValues : Main::heightController)
    var
      _L1 : real;
      _L2 : real;
      _L3 : Main::rcValuesReal;
      _L4 : Main::rcFlags;
      _L8 : bool;
      _L7 : bool;
      _L5 : bool;
      _L11 : bool;
      _L15 : real;
      _L14 : real;
      _L13 : real;
      _L12 : real;
      _L16 : Main::controllerSettings;
      _L17 : real;
      _L21 : real;
      _L33 : real;
      _L38 : bool;
      _L40 : Main::controllerSettings;
      _L42 : Main::heightController;
      _L43 : real;
    let
      _L1= heightValue;
      _L2= heightSpeedValue;
      _L3= setpointValues;
      _L4= rcFlags;
      thrust= _L43;
      _L8, _L7, _L5= (flatten Main::rcFlags)(_L4);
      _L11= _L7 or _L5;
      _L15, _L14, _L13, _L12= (flatten Main::rcValuesReal)(_L3);
      _= _L14;
      _= _L13;
      _= _L12;
      _L16= Main::CONTROLLER_HEIGHT_SETTINGS;
      _L40, _L17= #1 PIDHeightController(_L33, _L1, _L16, _L2, _L15, _L38);
      _L21= #1 getOffsetGasPosition(_L5, _L38, _L15);
      _L33= #1 getHeightSetpoint(_L38, _L21, _L1);
      _L38= _L8 and _L11;
      heightControllerValues= _L42;
      _L42= (make Main::heightController)(_L40, _L17, _L21, _L38);
      _L43= if _L38 then _L17 else _L15;
    tel
    
    node PIDHeightController(
        setpointValue : real;
        actualValue : real;
        settingValues : Main::controllerSettings;
        speedValue : real;
        integralStartValue : real;
        activeSignal : bool)
      returns (controllerParts : Main::controllerSettings; motorValue : real)
    var
      _L1 : real;
      _L2 : real;
      _L3 : real;
      _L4 : Main::controllerSettings;
      _L5 : real;
      _L6 : real;
      _L7 : real;
      _L16 : real;
      _L15 : real;
      _L14 : real;
      _L13 : real;
      _L17 : real;
      _L20 : real;
      _L21 : bool;
      _L49 : Main::controllerSettings;
      _L51 : real;
      _L53 : real;
      _L55 : real;
      _L56 : real;
    let
      _L1= setpointValue;
      _L2= actualValue;
      _L3= _L1 - _L2;
      _L4= settingValues;
      _L5= _L53 + _L55;
      _L6= _L5 + _L56;
      _L7= _L6 - _L51;
      motorValue= _L7;
      _L16, _L15, _L14, _L13= (flatten Main::controllerSettings)(_L4);
      _L17= speedValue;
      _L20= integralStartValue;
      _L21= activeSignal;
      controllerParts= _L49;
      _L49= (make Main::controllerSettings)(_L53, _L55, _L56, _L51);
      _L51= #1 dampingTermHC(_L13, _L17);
      _L53= #1 proportionalTermHC(_L16, _L3);
      _L55= #1 integralTermHC(_L15, _L1, _L3, _L20, _L21);
      _L56= #1 derivativeTermHC(_L14, _L3);
    tel
    
    node getOffsetGasPosition(
        lostConnectionSignal : bool;
        activeSignal : bool;
        thrustValue : real)
      returns (setpointValue : real)
    var
      _L1 : real;
      _L2 : bool;
      _L3 : real;
      _L4 : real;
      _L5 : real;
      _L6 : real;
      _L8 : real;
      _L9 : bool;
      _L10 : real;
      _L11 : real;
      _L12 : bool;
      _L13 : real;
      _L14 : real;
    let
      _L1= thrustValue;
      setpointValue= _L13;
      _L2= activeSignal;
      _L3= if _L9 then _L1 else _L4;
      _L4= fby(_L3; 1; 0.0);
      _L5= _L1 - _L3;
      _L6= #1 Functions::rcAdjustingReal(_L5, _L8);
      _L8= Main::SENSITIVITY_GAS_STICK_HC;
      _L9= not _L2;
      _L10= _L6 / _L11;
      _L11= Main::SCALING_GAS_STICK_HC;
      _L12= lostConnectionSignal;
      _L13= if _L12 then _L14 else _L10;
      _L14= Main::LOST_CONNECTION_HC_SETPOINT;
    tel
    
    node getHeightSetpoint(
        activeSignal : bool;
        setpointValue : real;
        heightValue : real)
      returns (heightSetpointValue : real)
    var
      _L5 : bool;
      _L3 : real;
      _L2 : real;
      _L1 : real;
      _L7 : real;
      _L6 : bool;
      _L10 : real;
      _L12 : real;
      _L14 : bool;
      _L15 : bool;
    let
      heightSetpointValue= _L3;
      _L1= fby(_L3; 1; 0.0);
      _L2= heightValue;
      _L3= if _L14 then _L12 else _L1;
      _L5= activeSignal;
      _L6= _L5 and _L15;
      _L7= Main::ZERO_REAL;
      _L10= setpointValue;
      _L12= _L10 + _L2;
      _L14= not _L6;
      _L15= _L7 = _L10;
    tel
    
    function dampingTermHC(Ks : real; speedValue : real)
      returns (dampingValue : real)
    var
      _L3 : real;
      _L2 : real;
      _L1 : real;
    let
      _L1= speedValue;
      _L2= Ks;
      dampingValue= _L3;
      _L3= _L1 * _L2;
    tel
    
    function proportionalTermHC(Kp : real; differenceValue : real)
      returns (pValue : real)
    var
      _L1 : real;
      _L2 : real;
      _L3 : real;
    let
      _L1= _L2 * _L3;
      _L2= differenceValue;
      pValue= _L1;
      _L3= Kp;
    tel
    
    node integralTermHC(
        Ki : real;
        setpointValue : real;
        differenceValue : real;
        integralStartValue : real;
        activeSignal : bool)
      returns (iValue : real)
    var
      _L3 : real;
      _L13 : real;
      _L12 : real;
      _L11 : real;
      _L10 : real;
      _L9 : real;
      _L14 : real;
      _L15 : bool;
      _L16 : real;
      _L17 : real;
      _L18 : real;
      _L20 : real;
      _L22 : real;
      _L21 : bool;
      _L26 : real;
      _L25 : real;
      _L27 : real;
      _L28 : bool;
      _L19 : real;
    let
      iValue= _L3;
      _L3= #1 Functions::minMaxLimitation(_L26, _L25, _L10);
      _L9= if _L28 then _L12 else _L27;
      _L10= _L18 + _L9;
      _L11= _L17 * _L16;
      _L12= fby(_L3; 1; 0.0);
      _L13= if _L28 then _L11 else _L14;
      _L14= integralStartValue;
      _L15= activeSignal;
      _L16= Ki;
      _L17= differenceValue;
      _L18= if _L21 then _L19 else _L13;
      _L20= setpointValue;
      _L21= _L20 <> _L22;
      _L22= fby(_L20; 1; _L20);
      _L25= Main::I_LIMITATION_MAX_HC;
      _L26= Main::I_LIMITATION_MIN_HC;
      _L27= Main::ZERO_REAL;
      _L28= fby(_L15; 1; false);
      _L19= Main::ZERO_REAL;
    tel
    
    node derivativeTermHC(Kd : real; differenceValue : real)
      returns (dValue : real)
    var
      _L4 : real;
      _L2 : real;
      _L6 : real;
      _L7 : real;
      _L8 : real;
    let
      _L2= fby(_L6; 1; 0.0);
      _L4= _L6 - _L2;
      _L6= differenceValue;
      _L7= _L8 * _L4;
      _L8= Kd;
      dValue= _L7;
    tel
    
  end;
  
  package AttitudeController
    node attitudeController(
        rcFlags : Main::rcFlags;
        setpointValues : Main::rcValuesReal;
        angleValues : Main::angleValues;
        angleSpeedValues : Main::angleValues)
      returns (
        psi : real;
        theta : real;
        phi : real;
        attitudeControllerValues : Main::attitudeController)
    var
      _L1 : Main::angleValues;
      _L2 : Main::angleValues;
      _L3 : Main::rcValuesReal;
      _L4 : Main::rcFlags;
      _L5 : real;
      _L7 : real;
      _L10 : real;
      _L9 : real;
      _L8 : real;
      _L14 : bool;
      _L13 : bool;
      _L11 : bool;
      _L18 : real;
      _L17 : real;
      _L16 : real;
      _L22 : real;
      _L21 : real;
      _L20 : real;
      _L19 : real;
      _L33 : Main::controllerSettings;
      _L34 : Main::controllerSettings;
      _L36 : real;
      _L38 : real;
      _L47 : Main::controllerSettings;
      _L49 : Main::controllerSettings;
      _L50 : Main::attitudeController;
      _L58 : Main::rcValuesReal;
      _L59 : Main::rcValuesReal;
      _L63 : real;
      _L62 : real;
      _L61 : real;
      _L60 : real;
      _L64 : real;
      _L66 : Main::controllerSettings;
      _L65 : real;
    let
      _L1= angleValues;
      _L2= angleSpeedValues;
      _L3= setpointValues;
      _L4= rcFlags;
      psi= _L5;
      theta= _L65;
      phi= _L7;
      _L5, _L49= #3 PIDControllerPhiPsi(_L38, _L16, _L33, _L8, _L36, _L14);
      _L7, _L47= #2 PIDControllerPhiPsi(_L19, _L17, _L34, _L9, _L36, _L14);
      _L10, _L9, _L8= (flatten Main::angleValues)(_L2);
      _L14, _L13, _L11= (flatten Main::rcFlags)(_L4);
      _= _L13;
      _L18, _L17, _L16= (flatten Main::angleValues)(_L1);
      _L22, _L21, _L20, _L19= (flatten Main::rcValuesReal)(_L58);
      _L33= Main::CONTROLLER_PSI_SETTINGS;
      _L34= Main::CONTROLLER_THETA_PHI_SETTINGS;
      _L36= Main::ZERO_REAL;
      _L38= #1 getPsiSetpoint(_L22, _L21, _L16, _L14);
      attitudeControllerValues= _L50;
      _L50= (make Main::attitudeController)(_L66, _L65, _L47, _L7, _L49, _L5);
      _L58= if _L11 then _L59 else _L3;
      _L63, _L62, _L61, _L60= (flatten Main::rcValuesReal)(_L3);
      _L59= (make Main::rcValuesReal)(_L63, _L64, _L64, _L64);
      _= _L62;
      _= _L61;
      _= _L60;
      _L64= Main::ZERO_REAL;
      _L65, _L66= #1 PIDControllerTheta(_L20, _L18, _L34, _L10, _L36, _L14);
    tel
    
    node PIDControllerPhiPsi(
        setpointValue : real;
        actualValue : real;
        settingValues : Main::controllerSettings;
        angleSpeedValue : real;
        integralStartValue : real;
        motorsOnSignal : bool)
      returns (motorValue : real; controllerParts : Main::controllerSettings)
    var
      _L1 : real;
      _L2 : real;
      _L3 : real;
      _L4 : Main::controllerSettings;
      _L5 : real;
      _L6 : real;
      _L7 : real;
      _L16 : real;
      _L15 : real;
      _L14 : real;
      _L13 : real;
      _L17 : real;
      _L20 : real;
      _L21 : bool;
      _L35 : real;
      _L36 : Main::controllerSettings;
      _L37 : real;
      _L38 : real;
      _L39 : real;
      _L40 : real;
    let
      _L1= setpointValue;
      _L2= actualValue;
      _L3= _L1 - _L2;
      _L4= settingValues;
      _L5= _L37 + _L38;
      _L6= _L5 + _L39;
      _L7= _L6 - _L40;
      motorValue= _L7;
      _L16, _L15, _L14, _L13= (flatten Main::controllerSettings)(_L4);
      _L17= angleSpeedValue;
      _L20= integralStartValue;
      _L21= motorsOnSignal;
      _L35= #1 Functions::angleLimitation180(_L3);
      controllerParts= _L36;
      _L36= (make Main::controllerSettings)(_L37, _L38, _L39, _L40);
      _L37= #1 proportionalTerm(_L16, _L35);
      _L38= #1 integralTerm(_L15, _L35, _L20, _L21);
      _L39= #1 derivativeTerm(_L14, _L35);
      _L40= #1 dampingTerm(_L13, _L17);
    tel
    
    node getPsiSetpoint(
        setpointThrust : real;
        setpointYaw : real;
        anglePsi : real;
        motorsOn : bool)
      returns (psiSetpointValue : real)
    var
      _L3 : real;
      _L2 : real;
      _L1 : real;
      _L6 : real;
      _L8 : bool;
      _L9 : real;
      _L11 : real;
      _L12 : real;
      _L13 : bool;
      _L14 : real;
      _L15 : real;
      _L16 : bool;
      _L17 : real;
      _L20 : bool;
      _L21 : bool;
    let
      psiSetpointValue= _L9;
      _L1= fby(_L3; 1; 0.0);
      _L2= anglePsi;
      _L3= if _L20 then _L17 else _L1;
      _L6= setpointYaw;
      _L8= _L16 and _L21;
      _L9= #1 Functions::angleLimitation180(_L3);
      _L11= Main::ZERO_REAL;
      _L12= setpointThrust;
      _L13= _L12 < _L15;
      _L14= if _L13 then _L11 else _L6;
      _L15= Main::STOP_GIER;
      _L16= motorsOn;
      _L17= _L14 + _L2;
      _L20= not _L8;
      _L21= _L11 = _L14;
    tel
    
    function proportionalTerm(Kp : real; differenceValue : real)
      returns (pValue : real)
    var
      _L1 : real;
      _L2 : real;
      _L3 : real;
    let
      _L1= _L2 * _L3;
      _L2= differenceValue;
      pValue= _L1;
      _L3= Kp;
    tel
    
    node integralTerm(
        Ki : real;
        differenceValue : real;
        integralStartValue : real;
        motorsOnSignal : bool)
      returns (iValue : real)
    var
      _L3 : real;
      _L2 : real;
      _L1 : real;
      _L13 : real;
      _L12 : real;
      _L11 : real;
      _L10 : real;
      _L9 : real;
      _L14 : real;
      _L15 : bool;
      _L16 : real;
      _L17 : real;
    let
      iValue= _L3;
      _L1= Main::I_LIMITATION_MAX;
      _L2= Main::I_LIMITATION_MIN;
      _L3= #1 Functions::minMaxLimitation(_L2, _L1, _L10);
      _L9= if _L15 then _L12 else _L14;
      _L10= _L13 + _L9;
      _L11= _L17 * _L16;
      _L12= fby(_L3; 1; 0.0);
      _L13= if _L15 then _L11 else _L14;
      _L14= integralStartValue;
      _L15= motorsOnSignal;
      _L16= Ki;
      _L17= differenceValue;
    tel
    
    node derivativeTerm(Kd : real; differenceValue : real)
      returns (dValue : real)
    var
      _L4 : real;
      _L2 : real;
      _L6 : real;
      _L7 : real;
      _L8 : real;
    let
      _L2= fby(_L6; 1; 0.0);
      _L4= _L6 - _L2;
      _L6= differenceValue;
      _L7= _L8 * _L4;
      _L8= Kd;
      dValue= _L7;
    tel
    
    function dampingTerm(Ks : real; angleSpeedValue : real)
      returns (dampingValue : real)
    var
      _L3 : real;
      _L2 : real;
      _L1 : real;
    let
      _L1= angleSpeedValue;
      _L2= Ks;
      dampingValue= _L3;
      _L3= _L1 * _L2;
    tel
    
    node PIDControllerTheta(
        setpointValue : real;
        actualValue : real;
        settingValues : Main::controllerSettings;
        angleSpeedValue : real;
        integralStartValue : real;
        motorsOnSignal : bool)
      returns (motorValue : real; controllerParts : Main::controllerSettings)
    var
      _L1 : real;
      _L2 : real;
      _L3 : real;
      _L4 : Main::controllerSettings;
      _L5 : real;
      _L6 : real;
      _L7 : real;
      _L16 : real;
      _L15 : real;
      _L14 : real;
      _L13 : real;
      _L17 : real;
      _L20 : real;
      _L21 : bool;
      _L36 : Main::controllerSettings;
      _L37 : real;
      _L38 : real;
      _L39 : real;
      _L40 : real;
      _L41 : real;
    let
      _L1= setpointValue;
      _L2= actualValue;
      _L3= _L1 - _L2;
      _L4= settingValues;
      _L5= _L37 + _L38;
      _L6= _L5 + _L39;
      _L7= _L6 - _L40;
      motorValue= _L7;
      _L16, _L15, _L14, _L13= (flatten Main::controllerSettings)(_L4);
      _L17= angleSpeedValue;
      _L20= integralStartValue;
      _L21= motorsOnSignal;
      controllerParts= _L36;
      _L36= (make Main::controllerSettings)(_L37, _L38, _L39, _L40);
      _L37= #1 proportionalTerm(_L16, _L41);
      _L38= #1 integralTerm(_L15, _L41, _L20, _L21);
      _L39= #1 derivativeTerm(_L14, _L41);
      _L40= #1 dampingTerm(_L13, _L17);
      _L41= #1 Functions::angleLimitation90(_L3);
    tel
    
  end;
  
  package CalculateMotorSpeed
    function calculateMotorSpeed(
        rcFlags : Main::rcFlags;
        psi : real;
        theta : real;
        phi : real;
        thrust : real)
      returns (motorValues : Main::motorValues)
    var
      _L1 : Main::rcFlags;
      _L2 : Main::motorValues;
      _L3 : real;
      _L4 : real;
      _L5 : real;
      _L6 : real;
      _L7 : real;
      _L8 : real;
      _L10 : real;
      _L11 : real;
      _L12 : real;
      _L13 : real;
      _L14 : real;
      _L15 : real;
      _L19 : bool;
      _L18 : bool;
      _L16 : bool;
      _L20 : int;
      _L21 : int;
      _L22 : int;
      _L23 : int;
      _L26 : int;
      _L27 : int;
      _L28 : int;
      _L29 : int;
      _L35 : int;
      _L36 : int;
      _L37 : int;
      _L38 : int;
      _L39 : int;
      _L40 : int;
      _L41 : int;
      _L44 : real;
      _L45 : real;
      _L46 : real;
      _L47 : real;
      _L50 : real;
      _L52 : real;
      _L53 : real;
      _L54 : real;
    let
      _L1= rcFlags;
      motorValues= _L2;
      _L2= (make Main::motorValues)(_L20, _L21, _L22, _L23);
      _L3= psi;
      _L4= theta;
      _L5= phi;
      _L6= thrust;
      _L7= _L53 - _L54;
      _L8= _L53 - _L54;
      _L10= _L53 + _L54;
      _L11= _L53 + _L54;
      _L12= _L8 + _L50;
      _L13= _L7 - _L50;
      _L14= _L10 + _L52;
      _L15= _L11 - _L52;
      _L19, _L18, _L16= (flatten Main::rcFlags)(_L1);
      _= _L16;
      _= _L18;
      _L20= if _L19 then _L26 else _L37;
      _L21= if _L19 then _L27 else _L37;
      _L22= if _L19 then _L28 else _L37;
      _L23= if _L19 then _L29 else _L37;
      _L26= #1 Functions::motorLimitation(_L38, _L35, _L36);
      _L27= #2 Functions::motorLimitation(_L39, _L35, _L36);
      _L28= #3 Functions::motorLimitation(_L40, _L35, _L36);
      _L29= #4 Functions::motorLimitation(_L41, _L35, _L36);
      _L35= Main::MAX_GAS;
      _L36= Main::MIN_GAS;
      _L37= Main::ZERO;
      _L38= int  _L13;
      _L39= int  _L12;
      _L40= int  _L14;
      _L41= int  _L15;
      _L44= Main::MAX_HC_GAS;
      _L45= Main::MIN_HC_GAS;
      _L46= Main::MAX_AC_GAS;
      _L47= Main::MIN_AC_GAS;
      _L50= #1 Functions::minMaxLimitation(_L47, _L46, _L4);
      _L52= #3 Functions::minMaxLimitation(_L47, _L46, _L5);
      _L53= #4 Functions::minMaxLimitation(_L45, _L44, _L6);
      _L54= #5 Functions::minMaxLimitation(_L47, _L46, _L3);
    tel
    
  end;
  
  package Setpoint
    node setpoints(
        rcFlags : Main::rcFlags;
        rcValues : Main::rcValues;
        angleValues : Main::angleValues)
      returns (setpointValues : Main::rcValuesReal)
    var
      _L1 : Main::rcValues;
      _L10 : Main::angleValues;
      _L13 : real;
      _L12 : real;
      _L11 : real;
      _L14 : Main::rcValues;
      _L15 : Main::rcValuesReal;
      _L16 : real;
      _L17 : Main::rcFlags;
      _L19 : Main::rcValuesReal;
      _L20 : Main::rcValuesReal;
      _L21 : bool;
      _L22 : bool;
      _L24 : bool;
      _L30 : Main::rcValues;
    let
      _L1= rcValues;
      _L14= #1 setOffsets(_L1, _L30);
      _L15= #1 rotationMatrix(_L11, _L16, _L14);
      _L20= #1 limitationBlock(_L19);
      _L10= angleValues;
      _L13, _L12, _L11= (flatten Main::angleValues)(_L10);
      _= _L13;
      _= _L12;
      _L16= #1 getPsiStartValue(_L11, _L21);
      _L17= rcFlags;
      _L19= #1 calcSetpoints(_L15);
      setpointValues= _L20;
      _= _L22;
      _L21, _L22, _L24= (flatten Main::rcFlags)(_L17);
      _L30= Main::RC_OFFSET_VALUES;
      _= _L24;
    tel
    
    function setOffsets(
        rcValues : Main::rcValues;
        rcOffsetValues : Main::rcValues)
      returns (rcAdjustedValues : Main::rcValues)
    var
      _L1 : Main::rcValues;
      _L2 : Main::rcValues;
      _L9 : int;
      _L8 : int;
      _L7 : int;
      _L6 : int;
      _L17 : int;
      _L16 : int;
      _L15 : int;
      _L14 : int;
      _L18 : int;
      _L19 : int;
      _L20 : int;
      _L21 : int;
      _L22 : Main::rcValues;
      _L25 : int;
      _L28 : int;
      _L29 : int;
      _L31 : int;
      _L32 : int;
      _L33 : int;
    let
      _L1= rcValues;
      _L2= rcOffsetValues;
      _L9, _L8, _L7, _L6= (flatten Main::rcValues)(_L1);
      _L17, _L16, _L15, _L14= (flatten Main::rcValues)(_L2);
      _L18= _L9 - _L17;
      _L19= _L8 - _L16;
      _L20= _L7 - _L15;
      _L21= _L6 - _L14;
      rcAdjustedValues= _L22;
      _L22= (make Main::rcValues)(_L18, _L32, _L28, _L31);
      _L25= #1 Functions::rcAdjusting(_L19, _L33);
      _L28= #2 Functions::rcAdjusting(_L20, _L33);
      _L29= #3 Functions::rcAdjusting(_L21, _L33);
      _L31= - _L29;
      _L32= - _L25;
      _L33= Main::SENSITIVITY_STICKS_SP;
    tel
    
    function rotationMatrix(
        anglePsi : real;
        psiStartValue : real;
        rcAdjustedValues : Main::rcValues)
      returns (rcTransformedValues : Main::rcValuesReal)
    var
      _L1 : real;
      _L2 : Main::rcValuesReal;
      _L3 : Main::rcValues;
      _L7 : int;
      _L6 : int;
      _L5 : int;
      _L4 : int;
      _L11 : real;
      _L12 : real;
      _L15 : real;
      _L16 : real;
      _L17 : real;
      _L18 : real;
      _L19 : real;
      _L20 : real;
      _L21 : real;
      _L22 : real;
      _L24 : real;
      _L25 : real;
      _L26 : real;
      _L27 : real;
      _L28 : real;
      _L29 : real;
    let
      _L1= anglePsi;
      rcTransformedValues= _L2;
      _L2= (make Main::rcValuesReal)(_L18, _L19, _L17, _L20);
      _L3= rcAdjustedValues;
      _L7, _L6, _L5, _L4= (flatten Main::rcValues)(_L3);
      _L11= #1 mathext::CosR(_L29);
      _L12= #1 mathext::SinR(_L29);
      _L15= _L26 * _L11;
      _L16= _L27 * _L12;
      _L17= _L15 - _L16;
      _L18= real  _L7;
      _L19= real  _L6;
      _L20= _L21 + _L22;
      _L21= _L27 * _L11;
      _L22= _L26 * _L12;
      _L24= _L25 - _L1;
      _L25= psiStartValue;
      _L26= real  _L5;
      _L27= real  _L4;
      _L28= #1 Functions::angleLimitation180(_L24);
      _L29= #1 Functions::degree2radian(_L28);
    tel
    
    function limitationBlock(rcNormalizedValues : Main::rcValuesReal)
      returns (setpointValues : Main::rcValuesReal)
    var
      _L1 : Main::rcValuesReal;
      _L5 : real;
      _L4 : real;
      _L3 : real;
      _L2 : real;
      _L6 : Main::rcValuesReal;
      _L9 : real;
      _L10 : real;
      _L11 : real;
      _L12 : real;
      _L13 : Main::rcValuesReal;
      _L17 : real;
      _L16 : real;
      _L15 : real;
      _L14 : real;
      _L18 : real;
      _L20 : real;
      _L21 : real;
      _L22 : real;
    let
      _L1= rcNormalizedValues;
      _L5, _L4, _L3, _L2= (flatten Main::rcValuesReal)(_L1);
      setpointValues= _L6;
      _L6= (make Main::rcValuesReal)(_L9, _L10, _L11, _L12);
      _L9= #1 Functions::minMaxLimitation(_L18, _L17, _L5);
      _L10= #2 Functions::minMaxLimitation(_L20, _L16, _L4);
      _L11= #3 Functions::minMaxLimitation(_L21, _L15, _L3);
      _L12= #4 Functions::minMaxLimitation(_L22, _L14, _L2);
      _L13= Main::RC_MAX_VALUES;
      _L17, _L16, _L15, _L14= (flatten Main::rcValuesReal)(_L13);
      _L18= Main::MIN_GAS_REAL;
      _L20= - _L16;
      _L21= - _L15;
      _L22= - _L14;
    tel
    
    node getPsiStartValue(anglePsi : real; motorsOn : bool)
      returns (psiStartValue : real)
    var
      _L2 : real;
      _L8 : bool;
      _L9 : real;
      _L10 : real;
      _L1 : bool;
    let
      psiStartValue= _L9;
      _L2= anglePsi;
      _L8= not _L1;
      _L9= if _L8 then _L2 else _L10;
      _L10= fby(_L9; 1; 0.0);
      _L1= motorsOn;
    tel
    
    function calcSetpoints(rcTransformedValues : Main::rcValuesReal)
      returns (rcNormalizedValues : Main::rcValuesReal)
    var
      _L1 : Main::rcValuesReal;
      _L5 : real;
      _L4 : real;
      _L3 : real;
      _L2 : real;
      _L11 : real;
      _L12 : real;
      _L13 : real;
      _L14 : real;
      _L16 : real;
      _L17 : Main::rcValuesReal;
      _L19 : Main::rcNormalizingValues;
      _L24 : real;
      _L25 : real;
      _L26 : real;
      _L27 : real;
      _L28 : Main::rcValuesReal;
      _L32 : real;
      _L31 : real;
      _L30 : real;
      _L29 : real;
      _L33 : real;
      _L34 : real;
      _L35 : real;
      _L36 : real;
      _L37 : real;
    let
      _L1= rcTransformedValues;
      _L5, _L4, _L3, _L2= (flatten Main::rcValuesReal)(_L1);
      _L33, _L34, _L35, _L36, _L37= (flatten Main::rcNormalizingValues)(_L19);
      _L11= _L5 * _L34;
      _L12= _L4 * _L35;
      _L13= _L3 * _L36;
      _L14= _L2 * _L37;
      _L16= _L33 + _L11;
      rcNormalizedValues= _L17;
      _L17= (make Main::rcValuesReal)(_L24, _L25, _L26, _L27);
      _L19= Main::RC_NORMALIZING;
      _L24= _L32 * _L16;
      _L25= _L31 * _L12;
      _L26= _L30 * _L13;
      _L27= _L29 * _L14;
      _L28= Main::RC_MAX_VALUES;
      _L32, _L31, _L30, _L29= (flatten Main::rcValuesReal)(_L28);
    tel
    
  end;
  
  package Signalprocessing
    node signalprocessing(
        analogValues : Main::analogValues;
        analogOffsetValues : Main::analogOffsetValues)
      returns (
        angleValues : Main::angleValues;
        angleSpeedValues : Main::angleValues;
        heightValue : real;
        heightSpeedValue : real;
        analogCorrectedOffsetValues : Main::analogOffsetValues;
        accelertionAngles : Main::accelerationAngles)
    var
      _L1 : Main::analogValues;
      _L18 : Main::analogOffsetValues;
      _L20 : Main::analogValuesReal;
      _L25 : Main::sinCosValues;
      _L27 : Main::analogValuesReal;
      _L30 : real;
      _L49 : Main::angleValues;
      _L50 : Main::angleValues;
      _L28 : Main::angleValues;
      _L31 : real;
      _L29 : Main::accelerations;
      _L53 : real;
      _L54 : real;
      _L55 : Main::accelerationAngles;
      _L56 : Main::analogOffsetValues;
      _L58 : Main::angleValues;
    let
      _L1= analogValues;
      _L18= analogOffsetValues;
      _L20= #1 meanSquareFilterBlock(_L27);
      _L25= #1 sinCosValues(_L49);
      _L27= #1 setOffsets(_L1, _L18);
      _L30, _L29, _L31, _L28= #1 calcUnitsFromAnalog(_L20);
      angleValues= _L58;
      angleSpeedValues= _L28;
      heightValue= _L54;
      heightSpeedValue= _L53;
      _L49= fby(_L58; 1; _L50);
      _L50= Main::ANGLES_INIT;
      analogCorrectedOffsetValues= _L56;
      accelertionAngles= _L55;
      _L53, _L54= #1 calcHeightValues(_L25, _L30, _L29);
      _L55, _L56, _L58= #1 calcAngleValues(_L49, _L25, _L29, _L31, _L28, _L18);
    tel
    
    node meanSquareFilterBlock(analogAdjustedValues : Main::analogValuesReal)
      returns (analogValuesFiltered : Main::analogValuesReal)
    var
      _L1 : Main::analogValuesReal;
      _L9 : real;
      _L8 : real;
      _L7 : real;
      _L6 : real;
      _L5 : real;
      _L4 : real;
      _L3 : real;
      _L2 : real;
      _L10 : real;
      _L11 : Main::analogValuesReal;
      _L12 : real;
      _L13 : real;
      _L14 : real;
      _L15 : real;
      _L16 : real;
      _L17 : real;
      _L21 : real;
    let
      _L1= analogAdjustedValues;
      _L9, _L8, _L7, _L6, _L5, _L4, _L3, _L2=
        (flatten Main::analogValuesReal)(_L1);
      _L10= #1 Functions::meanSquareFilter(_L9, _L21);
      analogValuesFiltered= _L11;
      _L11=
        (make Main::analogValuesReal)(_L10, _L12, _L13, _L14, _L15, _L16, _L17,
          _L2);
      _L12= #2 Functions::meanSquareFilter(_L8, _L21);
      _L13= #3 Functions::meanSquareFilter(_L7, _L21);
      _L14= #4 Functions::meanSquareFilter(_L6, _L21);
      _L15= #5 Functions::meanSquareFilter(_L5, _L21);
      _L16= #6 Functions::meanSquareFilter(_L4, _L21);
      _L17= #7 Functions::meanSquareFilter(_L3, _L21);
      _L21= Main::WEIGHT_NEW_VALUE;
    tel
    
    function sinCosValues(angleValues : Main::angleValues)
      returns (sinCosValues : Main::sinCosValues)
    var
      _L1 : Main::angleValues;
      _L5 : real;
      _L6 : real;
      _L7 : real;
      _L15 : real;
      _L14 : real;
      _L17 : real;
      _L16 : real;
      _L19 : real;
      _L18 : real;
      _L20 : Main::sinCosValues;
      _L21 : real;
      _L22 : real;
      _L23 : real;
    let
      _L1= angleValues;
      _L21, _L22, _L23= (flatten Main::angleValues)(_L1);
      _L5= #1 Functions::degree2radian(_L21);
      _L6= #2 Functions::degree2radian(_L22);
      _L7= #3 Functions::degree2radian(_L23);
      _L14= #1 mathext::CosR(_L5);
      _L15= #1 mathext::SinR(_L5);
      _L16= #2 mathext::SinR(_L6);
      _L17= #2 mathext::CosR(_L6);
      _L18= #3 mathext::CosR(_L7);
      _L19= #3 mathext::SinR(_L7);
      _L20= (make Main::sinCosValues)(_L15, _L14, _L16, _L17, _L19, _L18);
      sinCosValues= _L20;
    tel
    
    function angleTransformation(
        angleSteps : Main::angleValues;
        sinCosValues : Main::sinCosValues)
      returns (angleStepsTransformed : Main::angleValues)
    var
      _L1 : Main::angleValues;
      _L2 : Main::sinCosValues;
      _L5 : real;
      _L4 : real;
      _L3 : real;
      _L11 : real;
      _L10 : real;
      _L9 : real;
      _L8 : real;
      _L7 : real;
      _L6 : real;
      _L12 : real;
      _L13 : Main::angleValues;
      _L14 : real;
      _L15 : real;
      _L16 : bool;
      _L18 : Main::angleValues;
      _L23 : real;
      _L22 : real;
      _L21 : real;
      _L24 : real;
    let
      _L1= angleSteps;
      _L2= sinCosValues;
      _L5, _L4, _L3= (flatten Main::angleValues)(_L1);
      angleStepsTransformed= _L13;
      _L11, _L10, _L9, _L8, _L7, _L6= (flatten Main::sinCosValues)(_L2);
      _= _L7;
      _= _L6;
      _L12= _L5 * _L8;
      _L13= (make Main::angleValues)(_L14, _L22, _L21);
      _L14= _L12 - _L15;
      _L15= _L3 * _L9;
      _L16= _L10 <> _L24;
      _L18=
        (activate #1 angleTransformationPhiPsi every _L16 default _L1)(_L1,
          _L2);
      _L23, _L22, _L21= (flatten Main::angleValues)(_L18);
      _= _L23;
      _= _L11;
      _= _L4;
      _L24= Main::ZERO_REAL;
    tel
    
    function setOffsets(
        analogValues : Main::analogValues;
        analogOffsetValues : Main::analogOffsetValues)
      returns (analogAdjustedValues : Main::analogValuesReal)
    var
      _L15 : real;
      _L14 : real;
      _L13 : real;
      _L12 : real;
      _L11 : real;
      _L10 : real;
      _L9 : real;
      _L1 : int;
      _L2 : int;
      _L3 : int;
      _L4 : int;
      _L5 : int;
      _L6 : int;
      _L7 : int;
      _L8 : real;
      _L16 : Main::analogValues;
      _L17 : Main::analogValuesReal;
      _L18 : Main::analogOffsetValues;
      _L25 : real;
      _L24 : real;
      _L23 : real;
      _L22 : real;
      _L21 : real;
      _L20 : real;
      _L19 : real;
      _L30 : real;
      _L31 : real;
      _L32 : real;
      _L33 : real;
      _L34 : real;
      _L35 : real;
      _L36 : real;
    let
      _L1, _L2, _L3, _L4, _L5, _L6, _L7, _L8=
        (flatten Main::analogValues)(_L16);
      _L9= _L30 - _L22;
      _L10= _L36 - _L25;
      _L11= _L35 - _L24;
      _L12= _L33 - _L19;
      _L13= _L34 - _L23;
      _L14= _L31 - _L21;
      _L15= _L32 - _L20;
      _L16= analogValues;
      analogAdjustedValues= _L17;
      _L17=
        (make Main::analogValuesReal)(_L10, _L11, _L13, _L9, _L14, _L15, _L12,
          _L8);
      _L18= analogOffsetValues;
      _L25, _L24, _L23, _L22, _L21, _L20, _L19=
        (flatten Main::analogOffsetValues)(_L18);
      _L30= real  _L4;
      _L31= real  _L5;
      _L32= real  _L6;
      _L33= real  _L7;
      _L34= real  _L3;
      _L35= real  _L2;
      _L36= real  _L1;
    tel
    
    function calcUnitsFromAnalog(analogValuesFIltered : Main::analogValuesReal)
      returns (
        heightBarometer : real;
        accelerations : Main::accelerations;
        compass : real;
        angleSpeeds : Main::angleValues)
    var
      _L1 : Main::analogValuesReal;
      _L9 : real;
      _L8 : real;
      _L7 : real;
      _L6 : real;
      _L5 : real;
      _L4 : real;
      _L3 : real;
      _L2 : real;
      _L11 : Main::accelerations;
      _L12 : Main::angleValues;
      _L38 : real;
      _L39 : real;
      _L40 : real;
      _L41 : real;
      _L42 : real;
      _L43 : real;
      _L44 : real;
      _L45 : real;
      _L46 : real;
      _L47 : real;
      _L48 : real;
      _L49 : real;
      _L50 : real;
      _L52 : real;
      _L53 : real;
      _L54 : real;
    let
      _L1= analogValuesFIltered;
      _L9, _L8, _L7, _L6, _L5, _L4, _L3, _L2=
        (flatten Main::analogValuesReal)(_L1);
      _L11= (make Main::accelerations)(_L44, _L45, _L46);
      angleSpeeds= _L12;
      _L12= (make Main::angleValues)(_L42, _L41, _L43);
      accelerations= _L11;
      heightBarometer= _L54;
      compass= _L2;
      _L38= Main::ACC_CONSTANT;
      _L39= Main::GYRO_CONSTANT;
      _L40= Main::BAROMETER_CONSTANT;
      _L41= _L48 * _L39;
      _L42= _L49 * _L39;
      _L43= _L50 * _L39;
      _L44= _L53 * _L38;
      _L45= _L8 * _L38;
      _L46= _L52 * _L38;
      _L47= _L3 * _L40;
      _L48= - _L5;
      _L49= - _L6;
      _L50= - _L4;
      _L52= - _L7;
      _L53= - _L9;
      _L54= - _L47;
    tel
    
    function calcDiscreteAngleChanges(angleSpeeds : Main::angleValues)
      returns (angleSteps : Main::angleValues)
    var
      _L1 : Main::angleValues;
      _L5 : real;
      _L6 : real;
      _L7 : real;
      _L9 : real;
      _L10 : real;
      _L11 : real;
      _L12 : real;
      _L20 : Main::angleValues;
    let
      _L1= angleSpeeds;
      _L5, _L6, _L7= (flatten Main::angleValues)(_L1);
      _L9= _L5 * _L12;
      _L10= _L6 * _L12;
      _L11= _L7 * _L12;
      _L12= Main::TIMERPERIOD;
      angleSteps= _L20;
      _L20= (make Main::angleValues)(_L9, _L10, _L11);
    tel
    
    function angleIntegration(
        angleStepsTransformed : Main::angleValues;
        angleValues : Main::angleValues)
      returns (angleValuesNew : Main::angleValues)
    var
      _L1 : Main::angleValues;
      _L2 : Main::angleValues;
      _L3 : real;
      _L4 : real;
      _L5 : real;
      _L6 : Main::angleValues;
      _L9 : real;
      _L8 : real;
      _L7 : real;
      _L10 : real;
      _L11 : real;
      _L12 : real;
    let
      _L1= angleStepsTransformed;
      _L2= angleValues;
      _L3= _L9 + _L10;
      _L4= _L8 + _L11;
      _L5= _L7 + _L12;
      angleValuesNew= _L6;
      _L6= (make Main::angleValues)(_L3, _L4, _L5);
      _L9, _L8, _L7= (flatten Main::angleValues)(_L1);
      _L10, _L11, _L12= (flatten Main::angleValues)(_L2);
    tel
    
    function angleLimitationBlock(angleValues : Main::angleValues)
      returns (angleValuesLimited : Main::angleValues)
    var
      _L1 : Main::angleValues;
      _L4 : real;
      _L3 : real;
      _L2 : real;
      _L9 : real;
      _L10 : real;
      _L11 : Main::angleValues;
      _L12 : real;
    let
      _L1= angleValues;
      _L4, _L3, _L2= (flatten Main::angleValues)(_L1);
      _L9= #2 Functions::angleLimitation180(_L3);
      _L10= #3 Functions::angleLimitation180(_L2);
      angleValuesLimited= _L11;
      _L11= (make Main::angleValues)(_L12, _L9, _L10);
      _L12= #1 Functions::angleLimitation90(_L4);
    tel
    
    node driftCorrectionAngles(
        accelerationAngles : Main::accelerationAngles;
        compassValue : real;
        angleValues : Main::angleValues)
      returns (
        angleValuesFiltered : Main::angleValues;
        diffValues : Main::angleValues)
    var
      _L1 : Main::accelerationAngles;
      _L2 : Main::angleValues;
      _L3 : real;
      _L8 : real;
      _L7 : real;
      _L11 : real;
      _L10 : real;
      _L14 : real;
      _L13 : real;
      _L17 : real;
      _L16 : real;
      _L15 : real;
      _L18 : real;
      _L19 : real;
      _L22 : real;
      _L23 : real;
      _L24 : real;
      _L25 : real;
      _L26 : real;
      _L27 : real;
      _L29 : Main::angleValues;
      _L30 : Main::angleValues;
      _L33 : real;
      _L34 : real;
      _L39 : real;
      _L40 : real;
      _L41 : real;
      _L42 : real;
      _L45 : real;
      _L44 : real;
    let
      _L1= accelerationAngles;
      _L2= angleValues;
      _L3= compassValue;
      _L7, _L8= #2 Functions::kalmanFilter180(_L13, _L16, _L26);
      _L10, _L11= #3 Functions::kalmanFilter180(_L3, _L39, _L27);
      _L14, _L13= (flatten Main::accelerationAngles)(_L1);
      _L17, _L16, _L15= (flatten Main::angleValues)(_L2);
      _L18= #1 math::Abs(_L17);
      _L19= #2 math::Abs(_L16);
      _L22= _L33 * _L18;
      _L23= _L33 * _L19;
      _L24= _L40 * _L42;
      _L25= _L34 - _L22;
      _L26= _L34 - _L23;
      _L27= _L41 - _L24;
      angleValuesFiltered= _L29;
      _L29= (make Main::angleValues)(_L44, _L7, _L10);
      diffValues= _L30;
      _L30= (make Main::angleValues)(_L45, _L8, _L11);
      _L33= Main::KALMAN_THETA_PHI_CONSTANT;
      _L34= Main::KALMAN_THETA_PHI_MAX;
      _L39= _L3 -> _L15;
      _L40= Main::KALMAN_PSI_CONSTANT;
      _L41= Main::KALMAN_PSI_MAX;
      _L42= _L18 + _L19;
      _L44, _L45= #1 Functions::kalmanFilter90(_L14, _L17, _L25);
    tel
    
    function offsetCorrectionBlock(
        angleValues : Main::angleValues;
        diffValues : Main::angleValues;
        analogOffsetValues : Main::analogOffsetValues)
      returns (analogCorrectedOffsetValues : Main::analogOffsetValues)
    var
      _L1 : Main::analogOffsetValues;
      _L8 : real;
      _L7 : real;
      _L6 : real;
      _L5 : real;
      _L4 : real;
      _L3 : real;
      _L2 : real;
      _L9 : Main::analogOffsetValues;
      _L10 : Main::angleValues;
      _L13 : real;
      _L12 : real;
      _L11 : real;
      _L18 : real;
      _L19 : real;
      _L20 : real;
      _L26 : Main::angleValues;
      _L29 : real;
      _L28 : real;
      _L27 : real;
      _L33 : real;
      _L34 : bool;
      _L35 : Main::analogOffsetValues;
      _L36 : real;
      _L38 : real;
      _L39 : bool;
      _L40 : bool;
      _L25 : real;
    let
      _L1= analogOffsetValues;
      _L8, _L7, _L6, _L5, _L4, _L3, _L2=
        (flatten Main::analogOffsetValues)(_L1);
      analogCorrectedOffsetValues= _L35;
      _L9=
        (make Main::analogOffsetValues)(_L8, _L7, _L6, _L18, _L19, _L20, _L2);
      _L10= diffValues;
      _L13, _L12, _L11= (flatten Main::angleValues)(_L10);
      _L18= #1 Functions::offsetCorrection(_L5, _L13, _L25);
      _L19= #2 Functions::offsetCorrection(_L4, _L12, _L25);
      _L20= #3 Functions::offsetCorrection(_L3, _L11, _L25);
      _L26= angleValues;
      _L29, _L28, _L27= (flatten Main::angleValues)(_L26);
      _= _L27;
      _L33= Main::DEACTIVATE_OFFSET_CORRECTION;
      _L34= _L38 > _L33;
      _L35= if _L40 then _L1 else _L9;
      _L36= #1 math::Abs(_L29);
      _L38= #2 math::Abs(_L28);
      _L39= _L36 > _L33;
      _L40= _L39 or _L34;
      _L25= Main::GYRO_CORRECTION;
    tel
    
    function angleTransformationPhiPsi(
        angleSteps : Main::angleValues;
        sinCosValues : Main::sinCosValues)
      returns (angleStepsTransformedPhiPsi : Main::angleValues)
    var
      _L1 : Main::angleValues;
      _L2 : Main::sinCosValues;
      _L5 : real;
      _L4 : real;
      _L3 : real;
      _L11 : real;
      _L10 : real;
      _L9 : real;
      _L8 : real;
      _L7 : real;
      _L6 : real;
      _L12 : real;
      _L13 : real;
      _L14 : real;
      _L15 : Main::angleValues;
      _L16 : real;
      _L17 : real;
      _L18 : real;
      _L19 : real;
    let
      _L1= angleSteps;
      _L2= sinCosValues;
      _L5, _L4, _L3= (flatten Main::angleValues)(_L1);
      _L11, _L10, _L9, _L8, _L7, _L6= (flatten Main::sinCosValues)(_L2);
      angleStepsTransformedPhiPsi= _L15;
      _L12= _L5 * _L9;
      _L13= _L3 * _L8;
      _L14= _L12 + _L13;
      _L15= (make Main::angleValues)(_L5, _L18, _L19);
      _L16= _L11 / _L10;
      _L17= _L14 * _L16;
      _L18= _L4 + _L17;
      _L19= _L14 / _L10;
      _= _L7;
      _= _L6;
    tel
    
    function accelerationAngles(accelerations : Main::accelerations)
      returns (accelerationAngles : Main::accelerationAngles)
    var
      _L8 : Main::accelerationAngles;
      _L23 : Main::accelerations;
      _L26 : real;
      _L25 : real;
      _L24 : real;
      _L49 : real;
      _L50 : real;
      _L51 : real;
      _L52 : real;
      _L53 : real;
    let
      accelerationAngles= _L8;
      _L8= (make Main::accelerationAngles)(_L49, _L53);
      _L23= accelerations;
      _L26, _L25, _L24= (flatten Main::accelerations)(_L23);
      _L49= #1 Functions::radian2degree(_L50);
      _L50= #1 accelerationAngleTheta(_L26);
      _L51= #1 accelerationAnglePhi(_L50, _L25);
      _L52= #2 Functions::radian2degree(_L51);
      _L53= #1 Functions::accAnglePhiCorrection(_L52, _L24);
    tel
    
    function accelerationGeoZ(
        accelerations : Main::accelerations;
        sincosValues : Main::sinCosValues)
      returns (accelerationGeoZ : real)
    var
      _L1 : Main::accelerations;
      _L4 : real;
      _L3 : real;
      _L2 : real;
      _L5 : Main::sinCosValues;
      _L11 : real;
      _L10 : real;
      _L9 : real;
      _L8 : real;
      _L7 : real;
      _L6 : real;
      _L12 : real;
      _L13 : real;
      _L14 : real;
      _L15 : real;
      _L16 : real;
      _L17 : real;
      _L18 : real;
    let
      _L1= accelerations;
      _L4, _L3, _L2= (flatten Main::accelerations)(_L1);
      _L5= sincosValues;
      _L11, _L10, _L9, _L8, _L7, _L6= (flatten Main::sinCosValues)(_L5);
      _= _L7;
      _= _L6;
      _L12= _L3 * _L9;
      _L13= _L2 * _L8;
      _L14= _L12 + _L13;
      _L15= _L18 * _L11;
      _L16= _L14 * _L10;
      _L17= _L15 + _L16;
      _L18= - _L4;
      accelerationGeoZ= _L17;
    tel
    
    function accelerationIntegrationZ(
        accelerationGeoZ : real;
        oldHeightGeoZ : real;
        oldSpeedGeoZ : real)
      returns (speedGeoZ : real; heightGeoZ : real)
    var
      _L1 : real;
      _L2 : real;
      _L3 : real;
      _L4 : real;
      _L5 : real;
      _L6 : real;
      _L8 : real;
      _L9 : real;
      _L11 : real;
      _L12 : real;
    let
      _L1= accelerationGeoZ;
      _L2= _L1 - _L3;
      _L3= Main::GRAVITY;
      _L4= _L2 * _L5;
      _L5= Main::TIMERPERIOD;
      _L6= _L4 + _L11;
      speedGeoZ= _L6;
      _L8= _L6 * _L5;
      _L9= _L8 + _L12;
      heightGeoZ= _L9;
      _L11= oldSpeedGeoZ;
      _L12= oldHeightGeoZ;
    tel
    
    node driftCorrectionHeight(
        heightBarometer : real;
        speedGeoZ : real;
        heightGeoZ : real)
      returns (heightValue : real; heightSpeedValue : real)
    var
      _L1 : real;
      _L2 : real;
      _L3 : real;
      _L10 : real;
      _L11 : real;
      _L14 : real;
      _L15 : real;
      _L16 : real;
      _L17 : real;
      _L18 : real;
      _L20 : real;
    let
      _L1= heightBarometer;
      _L2= speedGeoZ;
      _L3= heightGeoZ;
      heightSpeedValue= _L20;
      heightValue= _L18;
      _L10= _L18 - _L11;
      _L11= fby(_L18; 1; 0.0);
      _L14= _L10 * _L15;
      _L15= Main::TIMERCYCLES;
      _L16= Main::KALMAN_HEIGHT;
      _L17= Main::KALMAN_HEIGHT_SPEED;
      _L18= #1 Functions::kalmanFilterHeight(_L1, _L3, _L16);
      _L20= #2 Functions::kalmanFilterHeight(_L14, _L2, _L17);
    tel
    
    node calcHeightValues(
        sinCosValues : Main::sinCosValues;
        heightBarometer : real;
        accelerations : Main::accelerations)
      returns (heightSpeedValue : real; heightValue : real)
    var
      _L7 : real;
      _L6 : real;
      _L4 : real;
      _L5 : real;
      _L3 : real;
      _L1 : real;
      _L2 : real;
      _L8 : Main::sinCosValues;
      _L9 : Main::accelerations;
      _L10 : real;
    let
      heightValue= _L1;
      heightSpeedValue= _L2;
      _L1, _L2= #1 driftCorrectionHeight(_L10, _L4, _L5);
      _L3= fby(_L1; 1; 0.0);
      _L4, _L5= #1 accelerationIntegrationZ(_L6, _L3, _L7);
      _L6= #1 accelerationGeoZ(_L9, _L8);
      _L7= fby(_L2; 1; 0.0);
      _L8= sinCosValues;
      _L9= accelerations;
      _L10= heightBarometer;
    tel
    
    node calcAngleValues(
        oldAngleValues : Main::angleValues;
        sinCosValues : Main::sinCosValues;
        accelerations : Main::accelerations;
        compassValue : real;
        angleSpeeds : Main::angleValues;
        analogOffsetValues : Main::analogOffsetValues)
      returns (
        accelertionAngles : Main::accelerationAngles;
        analogCorrectedOffsetValues : Main::analogOffsetValues;
        angleValues : Main::angleValues)
    var
      _L9 : Main::angleValues;
      _L8 : Main::angleValues;
      _L7 : Main::angleValues;
      _L5 : Main::analogOffsetValues;
      _L3 : Main::angleValues;
      _L4 : Main::angleValues;
      _L2 : Main::angleValues;
      _L1 : Main::accelerationAngles;
      _L11 : Main::analogOffsetValues;
      _L12 : Main::angleValues;
      _L13 : Main::sinCosValues;
      _L14 : real;
      _L15 : Main::angleValues;
      _L16 : Main::accelerations;
    let
      _L1= #1 accelerationAngles(_L16);
      _L2= #1 angleTransformation(_L9, _L13);
      _L3, _L4= #1 driftCorrectionAngles(_L1, _L14, _L7);
      _L5= #1 offsetCorrectionBlock(_L3, _L4, _L11);
      _L7= #1 angleLimitationBlock(_L8);
      accelertionAngles= _L1;
      _L8= #1 angleIntegration(_L2, _L12);
      _L9= #1 calcDiscreteAngleChanges(_L15);
      angleValues= _L3;
      analogCorrectedOffsetValues= _L5;
      _L11= analogOffsetValues;
      _L12= oldAngleValues;
      _L13= sinCosValues;
      _L14= compassValue;
      _L15= angleSpeeds;
      _L16= accelerations;
    tel
    
    function accelerationAngleTheta(accX : real) returns (thetaRadian : real)
    var
      _L4 : real;
      _L3 : real;
      _L2 : real;
      _L1 : real;
      _L5 : real;
    let
      _L1= Main::GRAVITY;
      _L2= #1 mathext::AsinR(_L3);
      _L3= #1 Functions::accLimitation(_L4);
      _L4= _L5 / _L1;
      _L5= accX;
      thetaRadian= _L2;
    tel
    
    function accelerationAnglePhi(thetaRadian : real; accY : real)
      returns (phiRadian : real)
    var
      _L14 : real;
      _L13 : bool;
      _L12 : real;
      _L11 : real;
      _L10 : real;
      _L9 : real;
      _L8 : bool;
      _L7 : real;
      _L6 : real;
      _L5 : real;
      _L4 : real;
      _L2 : real;
      _L1 : real;
      _L15 : real;
      _L16 : real;
      _L17 : real;
    let
      _L1= Main::ONE_N_REAL;
      _L2= Main::ZERO_REAL;
      _L4= #1 mathext::CosR(_L17);
      _L5= Main::ONE_REAL;
      _L6= #1 Functions::accLimitation(_L11);
      _L7= if _L13 then _L5 else _L1;
      _L8= _L2 <> _L4;
      _L9= Main::ZERO_REAL;
      _L10= #1 mathext::AsinR(_L6);
      _L11= (activate #1 $/$ every _L8 default _L7)(_L14, _L4);
      _L12= _L16 / _L15;
      _L13= _L14 > _L9;
      _L14= #2 Functions::accLimitation(_L12);
      _L15= Main::GRAVITY;
      _L16= accY;
      _L17= thetaRadian;
      phiRadian= _L10;
    tel
    
  end;
  
  node controller(
      rcFlags : Main::rcFlags;
      rcValues : Main::rcValues;
      analogValues : Main::analogValues;
      analogOffsetValues : Main::analogOffsetValues)
    returns (
      motorValues : Main::motorValues;
      analogCorrectedOffsetValues : Main::analogOffsetValues;
      anlgeValues : Main::angleValues;
      angleSpeedValues : Main::angleValues;
      heightValue : real;
      heightSpeedValue : real;
      setpointValues : Main::rcValuesReal;
      attitudeControllerValues : Main::attitudeController;
      heightControllerValues : Main::heightController;
      accelerationAngleValues : Main::accelerationAngles)
  var
    _L1 : Main::angleValues;
    _L2 : Main::angleValues;
    _L3 : real;
    _L4 : real;
    _L5 : Main::rcValuesReal;
    _L6 : Main::rcFlags;
    _L7 : Main::rcValues;
    _L8 : Main::analogValues;
    _L9 : Main::analogOffsetValues;
    _L10 : Main::motorValues;
    _L11 : real;
    _L12 : real;
    _L13 : real;
    _L14 : real;
    _L15 : Main::analogOffsetValues;
    _L16 : Main::attitudeController;
    _L17 : Main::heightController;
    _L18 : Main::accelerationAngles;
  let
    _L1, _L2, _L3, _L4, _L15, _L18=
      #1 Signalprocessing::signalprocessing(_L8, _L9);
    _L5= #1 Setpoint::setpoints(_L6, _L7, _L1);
    _L11, _L17= #1 HeightController::heightController(_L6, _L5, _L3, _L4);
    _L12, _L13, _L14, _L16=
      #1 AttitudeController::attitudeController(_L6, _L5, _L1, _L2);
    _L10=
      #1 CalculateMotorSpeed::calculateMotorSpeed(_L6, _L12, _L13, _L14, _L11);
    _L6= rcFlags;
    _L7= rcValues;
    _L8= analogValues;
    _L9= analogOffsetValues;
    motorValues= _L10;
    anlgeValues= _L1;
    angleSpeedValues= _L2;
    heightValue= _L3;
    heightSpeedValue= _L4;
    analogCorrectedOffsetValues= _L15;
    setpointValues= _L5;
    attitudeControllerValues= _L16;
    heightControllerValues= _L17;
    accelerationAngleValues= _L18;
  tel
  
end;

/* $*************** KCG Version 6.1.2 (build i5) ****************
** -
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */
/* $*************** KCG Version 6.1.2 (build i5) ****************
** Command: x2s612 D:/Bachelor-SVN/Programmcode/scade/Package32.xscade
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */

/* xscade source: D:/Bachelor-SVN/Programmcode/scade/Package32.xscade */
package Functions
  node meanSquareFilter(newValue : real; weightNewValue : real)
    returns (filterValue : real)
  var
    _L1 : real;
    _L2 : real;
    _L4 : real;
    _L5 : real;
    _L6 : real;
    _L8 : real;
    _L9 : real;
    _L10 : real;
  let
    _L1= newValue;
    filterValue= _L6;
    _L2= weightNewValue;
    _L4= _L1 * _L2;
    _L5= _L9 * _L8;
    _L6= _L4 + _L5;
    _L8= fby(_L6; 1; 0.0);
    _L9= _L10 - _L2;
    _L10= Main::ONE_REAL;
  tel
  
  function kalmanFilter180(refValue : real; value : real; kalmanValue : real)
    returns (filterValue : real; diffValue : real)
  var
    _L1 : real;
    _L2 : real;
    _L3 : real;
    _L4 : real;
    _L5 : real;
    _L6 : real;
    _L7 : real;
  let
    _L1= _L4 - _L5;
    _L2= _L7 * _L6;
    _L3= _L2 + _L5;
    _L4= refValue;
    filterValue= _L3;
    _L5= value;
    _L6= kalmanValue;
    diffValue= _L7;
    _L7= #1 angleLimitation180(_L1);
  tel
  
  function degree2radian(degree : real) returns (radian : real)
  var
    _L1 : real;
    _L2 : real;
    _L3 : real;
  let
    _L1= degree;
    radian= _L2;
    _L2= _L1 * _L3;
    _L3= Main::PI180;
  tel
  
  function angleLimitation180(angle : real) returns (angleLimited : real)
  var
    _L1 : real;
    _L4 : bool;
    _L5 : bool;
    _L6 : real;
    _L7 : real;
    _L10 : real;
    _L11 : real;
    _L13 : real;
    _L14 : real;
    _L15 : real;
  let
    _L1= angle;
    _L4= _L1 >= _L15;
    _L5= _L1 < _L14;
    _L6= if _L5 then _L7 else _L1;
    _L7= _L1 + _L13;
    _L10= if _L4 then _L11 else _L6;
    _L11= _L1 - _L13;
    angleLimited= _L10;
    _L13= Main::ANGLE_360_REAL;
    _L14= Main::ANGLE_N180_Real;
    _L15= Main::ANGLE_180_REAL;
  tel
  
  function accLimitation(value : real) returns (valueLimited : real)
  var
    _L1 : real;
    _L2 : bool;
    _L4 : real;
    _L5 : bool;
    _L7 : real;
    _L8 : real;
    _L9 : real;
  let
    _L1= value;
    valueLimited= _L7;
    _L2= _L1 > _L9;
    _L4= if _L2 then _L9 else _L1;
    _L5= _L1 < _L8;
    _L7= if _L5 then _L8 else _L4;
    _L8= Main::ONE_N_REAL;
    _L9= Main::ONE_REAL;
  tel
  
  function rcAdjusting(rcValue : int; adjustingValue : int)
    returns (rcValueAdjusted : int)
  var
    _L2 : int;
    _L1 : int;
    _L3 : int;
    _L4 : bool;
    _L6 : bool;
    _L8 : int;
    _L9 : int;
    _L10 : int;
    _L12 : int;
    _L13 : int;
  let
    _L1= if _L4 then _L10 else _L8;
    _L2= if _L6 then _L13 else _L1;
    _L3= rcValue;
    _L4= _L3 < _L12;
    _L6= _L3 > _L9;
    _L8= 0;
    _L9= adjustingValue;
    _L10= _L3 + _L9;
    _L12= - _L9;
    _L13= _L3 - _L9;
    rcValueAdjusted= _L2;
  tel
  
  function minMaxLimitation(min : real; max : real; value : real)
    returns (valueLimited : real)
  var
    _L1 : real;
    _L2 : real;
    _L3 : real;
    _L5 : real;
    _L6 : real;
    _L7 : bool;
    _L8 : bool;
  let
    _L1= min;
    _L2= max;
    _L3= value;
    valueLimited= _L6;
    _L5= if _L8 then _L1 else _L3;
    _L6= if _L7 then _L2 else _L5;
    _L7= _L3 > _L2;
    _L8= _L3 < _L1;
  tel
  
  function offsetCorrection(
      analogOffsetValue : real;
      diffValue : real;
      influence : real)
    returns (analogCorrectedOffsetValue : real)
  var
    _L1 : real;
    _L2 : real;
    _L4 : bool;
    _L6 : bool;
    _L8 : real;
    _L9 : real;
    _L14 : real;
    _L15 : real;
    _L18 : real;
    _L19 : real;
    _L3 : real;
  let
    _L1= analogOffsetValue;
    analogCorrectedOffsetValue= _L9;
    _L2= diffValue;
    _L4= _L2 < _L19;
    _L6= _L2 > _L18;
    _L8= if _L4 then _L15 else _L1;
    _L9= if _L6 then _L14 else _L8;
    _L14= _L3 + _L8;
    _L15= _L1 - _L3;
    _L18= Main::GYRO_CORRECTION_DIFF;
    _L19= - _L18;
    _L3= influence;
  tel
  
  function motorLimitation(value : int; max : int; min : int)
    returns (valueLimited : int)
  var
    _L7 : bool;
    _L6 : int;
    _L5 : int;
    _L4 : int;
    _L3 : int;
    _L2 : int;
    _L1 : bool;
  let
    _L1= _L2 < _L4;
    _L2= value;
    _L3= max;
    valueLimited= _L6;
    _L4= min;
    _L5= if _L1 then _L4 else _L2;
    _L6= if _L7 then _L3 else _L5;
    _L7= _L2 > _L3;
  tel
  
  function rcAdjustingReal(rcValue : real; adjustingValue : real)
    returns (rcValueAdjusted : real)
  var
    _L2 : real;
    _L1 : real;
    _L3 : real;
    _L4 : bool;
    _L6 : bool;
    _L9 : real;
    _L10 : real;
    _L12 : real;
    _L13 : real;
    _L14 : real;
  let
    _L1= if _L4 then _L10 else _L14;
    _L2= if _L6 then _L13 else _L1;
    _L3= rcValue;
    _L4= _L3 < _L12;
    _L6= _L3 > _L9;
    _L9= adjustingValue;
    _L10= _L3 + _L9;
    _L12= - _L9;
    _L13= _L3 - _L9;
    rcValueAdjusted= _L2;
    _L14= Main::ZERO_REAL;
  tel
  
  function kalmanFilterHeight(refValue : real; value : real; kalmanValue : real)
    returns (filterValue : real)
  var
    _L1 : real;
    _L2 : real;
    _L3 : real;
    _L4 : real;
    _L5 : real;
    _L6 : real;
  let
    _L1= _L4 - _L5;
    _L2= _L1 * _L6;
    _L3= _L2 + _L5;
    _L4= refValue;
    filterValue= _L3;
    _L5= value;
    _L6= kalmanValue;
  tel
  
  function radian2degree(radian : real) returns (degree : real)
  var
    _L3 : real;
    _L1 : real;
    _L4 : real;
  let
    _L1= Main::PI180;
    degree= _L4;
    _L3= radian;
    _L4= _L3 / _L1;
  tel
  
  function accAnglePhiCorrection(accPhi : real; accZ : real)
    returns (accPhiCorrected : real)
  var
    _L9 : real;
    _L8 : bool;
    _L7 : real;
    _L6 : real;
    _L5 : real;
    _L4 : real;
    _L3 : bool;
    _L2 : real;
    _L1 : real;
    _L10 : real;
    _L11 : real;
  let
    _L1= Main::ANGLE_N180_Real;
    _L2= _L1 - _L11;
    _L3= _L11 > _L4;
    _L4= Main::ZERO_REAL;
    _L5= Main::ANGLE_180_REAL;
    _L6= if _L3 then _L9 else _L2;
    _L7= if _L8 then _L6 else _L11;
    _L8= _L10 < _L4;
    _L9= _L5 - _L11;
    _L10= accZ;
    _L11= accPhi;
    accPhiCorrected= _L7;
  tel
  
  function angleLimitation90(angle : real) returns (angleLimited : real)
  var
    _L1 : real;
    _L5 : bool;
    _L6 : real;
    _L10 : real;
    _L11 : real;
    _L15 : real;
    _L16 : real;
    _L17 : real;
    _L18 : bool;
    _L19 : real;
    _L20 : real;
  let
    _L1= angle;
    _L5= _L1 < _L17;
    _L6= if _L5 then _L20 else _L1;
    _L10= if _L18 then _L11 else _L6;
    _L11= _L15 - _L1;
    angleLimited= _L10;
    _L15= Main::ANGLE_180_REAL;
    _L16= Main::ANGLE_90_REAL;
    _L17= Main::ANGLE_N90_REAL;
    _L18= _L1 > _L16;
    _L19= Main::ANGLE_N180_Real;
    _L20= _L19 - _L1;
  tel
  
  function kalmanFilter90(refValue : real; value : real; kalmanValue : real)
    returns (filterValue : real; diffValue : real)
  var
    _L1 : real;
    _L2 : real;
    _L3 : real;
    _L4 : real;
    _L5 : real;
    _L6 : real;
    _L8 : real;
  let
    _L1= _L4 - _L5;
    _L2= _L8 * _L6;
    _L3= _L2 + _L5;
    _L4= refValue;
    filterValue= _L3;
    _L5= value;
    _L6= kalmanValue;
    diffValue= _L8;
    _L8= #1 angleLimitation90(_L1);
  tel
  
end;

/* $*************** KCG Version 6.1.2 (build i5) ****************
** -
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */
/* $*************** KCG Version 6.1.2 (build i5) ****************
** Command: x2s612 D:/Bachelor-SVN/Programmcode/scade/Package41.xscade
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */

/* xscade source: D:/Bachelor-SVN/Programmcode/scade/Package41.xscade */
package Proofs
  const
    TEST_OFFSET_VALUES : Main::analogOffsetValues
      = {
          accX:500.0,
          accY:500.0,
          accZ:500.0,
          gyroPitch:512.0,
          gyroRoll:512.0,
          gyroYaw:512.0,
          barometer:35000.0 };
  
  node mainProof(
      motorsOn : bool;
      heightControl : bool;
      lostConnection : bool;
      thrust : int;
      yaw : int;
      pitch : int;
      roll : int;
      accX : int;
      accY : int;
      accZ : int;
      gyroPitch : int;
      gyroRoll : int;
      gyroYaw : int;
      barometer : int;
      compass : real)
    returns (
      motorsOnProof : bool;
      setpointProof : bool;
      motorsOffProof : bool;
      angleProof : bool;
      motorValuesProof : bool;
      accAnglesProof : bool)
  var
    _L10 : Main::accelerationAngles;
    _L9 : Main::heightController;
    _L8 : Main::attitudeController;
    _L7 : Main::rcValuesReal;
    _L6 : Main::analogOffsetValues;
    _L5 : real;
    _L4 : real;
    _L3 : Main::angleValues;
    _L2 : Main::angleValues;
    _L1 : Main::motorValues;
    _L11 : Main::analogOffsetValues;
    _L13 : Main::rcFlags;
    _L14 : Main::rcValues;
    _L15 : Main::analogValues;
    _L16 : Main::analogOffsetValues;
    _L17 : bool;
    _L18 : bool;
    _L20 : bool;
    _L21 : int;
    _L22 : int;
    _L23 : int;
    _L24 : int;
    _L25 : int;
    _L26 : int;
    _L27 : int;
    _L28 : int;
    _L29 : int;
    _L30 : int;
    _L31 : int;
    _L32 : real;
    _L33 : bool;
    _L37 : bool;
    _L38 : bool;
    _L40 : bool;
    _L41 : bool;
    _L42 : bool;
  let
    _L1, _L2, _L3, _L4, _L5, _L6, _L7, _L8, _L9, _L10=
      #1 Main::main(_L13, _L14, _L15, _L11);
    _L11= fby(_L6; 1; _L16);
    _L13= (make Main::rcFlags)(_L17, _L18, _L20);
    _L14= (make Main::rcValues)(_L21, _L22, _L23, _L24);
    _L15=
      (make Main::analogValues)(_L25, _L26, _L27, _L28, _L29, _L30, _L31, _L32);
    _= _L9;
    _= _L8;
    _= _L5;
    _= _L4;
    _= _L3;
    _L16= TEST_OFFSET_VALUES;
    _L17= motorsOn;
    _L18= heightControl;
    _L20= lostConnection;
    _L21= thrust;
    _L22= yaw;
    _L23= pitch;
    _L24= roll;
    _L25= accX;
    _L26= accY;
    _L27= accZ;
    _L28= gyroPitch;
    _L29= gyroRoll;
    _L30= gyroYaw;
    _L31= barometer;
    _L32= compass;
    motorsOnProof= _L40;
    setpointProof= _L37;
    _L33= #1 Proofs::motorsOffProof(_L1);
    motorsOffProof= _L33;
    assume A1 : motorsOn = false;
    _L38= #1 Proofs::angleProof(_L2);
    _L37= #1 Proofs::setpointProof(_L7);
    angleProof= _L38;
    assume A2 : compass < 180.0;
    assume A3 : compass >= -180.0;
    _L40= #1 Proofs::motorsOnProof(_L1);
    _L41= #1 Proofs::motorValuesProof(_L1);
    motorValuesProof= _L41;
    _L42= #1 Proofs::accAnglesProof(_L10);
    accAnglesProof= _L42;
    assume A14 : gyroYaw <= 1023;
    assume A15 : gyroYaw >= 0;
    assume A12 : gyroRoll <= 1023;
    assume A13 : gyroRoll >= 0;
    assume A10 : gyroPitch <= 1023;
    assume A11 : gyroPitch >= 0;
    assume A8 : accZ <= 1023;
    assume A9 : accZ >= 0;
    assume A6 : accY <= 1023;
    assume A7 : accY >= 0;
    assume A5 : accX >= 0;
    assume A4 : accX <= 1023;
  tel
  
  function motorsOffProof(motorValues : Main::motorValues)
    returns (motorsOffProof : bool)
  var
    _L1 : Main::motorValues;
    _L5 : int;
    _L4 : int;
    _L3 : int;
    _L2 : int;
    _L6 : bool;
    _L7 : bool;
    _L8 : bool;
    _L9 : bool;
    _L10 : bool;
    _L11 : int;
  let
    _L1= motorValues;
    _L5, _L4, _L3, _L2= (flatten Main::motorValues)(_L1);
    _L6= _L7 and _L8 and _L9 and _L10;
    _L7= _L5 = _L11;
    _L8= _L4 = _L11;
    _L9= _L3 = _L11;
    _L10= _L2 = _L11;
    _L11= Main::ZERO;
    motorsOffProof= _L6;
  tel
  
  function setpointProof(setpointValues : Main::rcValuesReal)
    returns (setpointProof : bool)
  var
    _L1 : Main::rcValuesReal;
    _L2 : bool;
    _L3 : bool;
    _L4 : bool;
    _L6 : bool;
    _L5 : bool;
    _L10 : bool;
    _L9 : bool;
    _L8 : bool;
    _L7 : bool;
    _L14 : real;
    _L13 : real;
    _L12 : real;
    _L11 : real;
    _L15 : Main::rcValuesReal;
    _L19 : real;
    _L18 : real;
    _L17 : real;
    _L16 : real;
    _L20 : real;
    _L21 : real;
    _L22 : real;
    _L23 : real;
  let
    setpointProof= _L2;
    _L1= setpointValues;
    _L2= _L4 and _L3 and _L5 and _L6 and _L7 and _L10 and _L8 and _L9;
    _L3= _L14 >= _L20;
    _L4= _L14 <= _L19;
    _L5= _L13 <= _L18;
    _L6= _L13 >= _L21;
    _L7= _L12 <= _L17;
    _L8= _L11 <= _L16;
    _L9= _L11 >= _L23;
    _L10= _L12 >= _L22;
    _L14, _L13, _L12, _L11= (flatten Main::rcValuesReal)(_L1);
    _L15= Main::RC_MAX_VALUES;
    _L19, _L18, _L17, _L16= (flatten Main::rcValuesReal)(_L15);
    _L20= Main::MIN_GAS_REAL;
    _L21= - _L18;
    _L22= - _L17;
    _L23= - _L16;
  tel
  
  function angleProof(angleValues : Main::angleValues)
    returns (angleProof : bool)
  var
    _L1 : Main::angleValues;
    _L27 : bool;
    _L26 : bool;
    _L23 : bool;
    _L21 : bool;
    _L20 : real;
    _L19 : bool;
    _L17 : real;
    _L16 : real;
    _L30 : real;
    _L29 : real;
    _L28 : real;
    _L31 : real;
    _L32 : real;
    _L33 : bool;
    _L34 : bool;
  let
    _L1= angleValues;
    angleProof= _L27;
    _L16= - _L32;
    _L17= - _L31;
    _L19= _L29 >= _L17;
    _L20= - _L31;
    _L21= _L30 >= _L16;
    _L23= _L30 <= _L32;
    _L26= _L28 >= _L20;
    _L27= _L23 and _L21 and _L33 and _L19 and _L34 and _L26;
    _L30, _L29, _L28= (flatten Main::angleValues)(_L1);
    _L31= Main::ANGLE_180_REAL;
    _L32= Main::ANGLE_90_REAL;
    _L33= _L29 < _L31;
    _L34= _L28 < _L31;
  tel
  
  function motorsOnProof(motorValues : Main::motorValues)
    returns (motorsOnProof : bool)
  var
    _L10 : Main::motorValues;
    _L31 : int;
    _L30 : bool;
    _L29 : bool;
    _L28 : bool;
    _L27 : bool;
    _L26 : bool;
    _L25 : bool;
    _L24 : int;
    _L23 : bool;
    _L22 : bool;
    _L21 : bool;
    _L17 : int;
    _L18 : int;
    _L19 : int;
    _L20 : int;
  let
    _L10= motorValues;
    _L17, _L18, _L19, _L20= (flatten Main::motorValues)(_L10);
    _L21= _L23 and _L26 and _L28 and _L29 and _L30 and _L22 and _L27 and _L25;
    _L22= _L19 >= _L31;
    _L23= _L17 <= _L24;
    _L24= Main::MAX_GAS;
    _L25= _L20 >= _L31;
    _L26= _L17 >= _L31;
    _L27= _L20 <= _L24;
    motorsOnProof= _L21;
    _L28= _L18 <= _L24;
    _L29= _L18 >= _L31;
    _L30= _L19 <= _L24;
    _L31= Main::MIN_GAS;
  tel
  
  function motorValuesProof(motorValues : Main::motorValues)
    returns (motorsValuesProof : bool)
  var
    _L10 : Main::motorValues;
    _L31 : int;
    _L30 : bool;
    _L29 : bool;
    _L28 : bool;
    _L27 : bool;
    _L26 : bool;
    _L25 : bool;
    _L24 : int;
    _L23 : bool;
    _L22 : bool;
    _L21 : bool;
    _L17 : int;
    _L18 : int;
    _L19 : int;
    _L20 : int;
  let
    _L10= motorValues;
    _L17, _L18, _L19, _L20= (flatten Main::motorValues)(_L10);
    _L21= _L23 and _L26 and _L28 and _L29 and _L30 and _L22 and _L27 and _L25;
    _L22= _L19 >= _L31;
    _L23= _L17 <= _L24;
    _L24= Main::MAX_GAS;
    _L25= _L20 >= _L31;
    _L26= _L17 >= _L31;
    _L27= _L20 <= _L24;
    motorsValuesProof= _L21;
    _L28= _L18 <= _L24;
    _L29= _L18 >= _L31;
    _L30= _L19 <= _L24;
    _L31= Main::ZERO;
  tel
  
  function accAnglesProof(accAngleValues : Main::accelerationAngles)
    returns (accAngleProof : bool)
  var
    _L16 : Main::accelerationAngles;
    _L14 : bool;
    _L10 : real;
    _L11 : real;
    _L8 : bool;
    _L7 : bool;
    _L5 : real;
    _L4 : bool;
    _L3 : real;
    _L2 : real;
    _L15 : real;
    _L17 : bool;
  let
    accAngleProof= _L14;
    _L2= - _L15;
    _L3= Main::ANGLE_90_REAL;
    _L4= _L10 <= _L3;
    _L5= - _L3;
    _L7= _L10 >= _L5;
    _L8= _L11 >= _L2;
    _L10, _L11= (flatten Main::accelerationAngles)(_L16);
    _L14= _L4 and _L7 and _L17 and _L8;
    _L16= accAngleValues;
    _L15= Main::ANGLE_180_REAL;
    _L17= _L11 < _L15;
  tel
  
  function calcAngleValuesProof(accX : real; accY : real; accZ : real)
    returns (accelerationAnglesProof : bool)
  var
    _L4 : Main::accelerationAngles;
    _L6 : Main::accelerations;
    _L7 : real;
    _L8 : real;
    _L9 : real;
    _L10 : bool;
  let
    _L4= #1 Controller::Signalprocessing::accelerationAngles(_L6);
    _L6= (make Main::accelerations)(_L7, _L8, _L9);
    _L7= accX;
    _L8= accY;
    _L9= accZ;
    accelerationAnglesProof= _L10;
    _L10= #1 accAnglesProof(_L4);
  tel
  
end;

/* $*************** KCG Version 6.1.2 (build i5) ****************
** -
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */
/* $*************** KCG Version 6.1.2 (build i5) ****************
** Command: x2s612 C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/libdigital/digital.xscade
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */

/* xscade source: C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/libdigital/digital.xscade */
package digital
  node FallingEdge(FE_Input : bool) returns (FE_Output : bool)
  var
    _L1 : bool;
    _L3 : bool;
    _L4 : bool;
    _L5 : bool;
  let
    _L1= FE_Input;
    FE_Output= _L3;
    _L3= _L4 and _L5;
    _L4= fby(_L1; 1; _L1);
    _L5= not _L1;
  tel
  
  node FallingEdgeNoRetrigger(FENR_Input : bool; NumberOfCycle : int)
    returns (FENR_Output : bool)
  var
    _L10 : bool;
    _L11 : bool;
    _L12 : bool;
    _L22 : int;
    _L23 : bool;
    _L26 : int;
    _L36 : bool;
    _L37 : bool;
    _L9 : bool;
    _L40 : bool;
    _L47 : bool;
    _L50 : bool;
    _L61 : bool;
    _L63 : bool;
    _L64 : bool;
    _L65 : int;
    _L68 : int;
  let
    _L9= FENR_Input;
    FENR_Output= _L40;
    _L10= pre _L9;
    _L11= not _L9;
    _L12= _L11 and _L10;
    _L22= 0;
    _L23= _L22 < _L65;
    _L26= NumberOfCycle;
    _L36= _L37 and _L63;
    _L37= not _L50;
    _L40= _L47 and _L23;
    _L47= _L50 or _L63;
    _L50= fby(_L40; 1; _L61);
    _L61= false;
    _L63= _L64 -> _L12;
    _L64= false;
    _L65= (activate #13 count_down every _L47 initial default _L68)(_L36, _L26);
    _L68= 0;
  tel
  
  node FallingEdgeRetrigger(FER_Input : bool; NumberOfCycle : int)
    returns (FER_Output : bool)
  var
    _L1 : bool;
    _L76 : bool;
    _L74 : bool;
    _L73 : bool;
    _L71 : int;
    _L70 : bool;
    _L68 : bool;
    _L65 : bool;
    _L64 : bool;
    _L63 : int;
    _L62 : bool;
    _L61 : bool;
    _L59 : bool;
    _L77 : int;
    _L79 : int;
  let
    _L1= FER_Input;
    FER_Output= _L62;
    _L76= _L63 < _L77;
    _L74= false;
    _L73= fby(_L62; 1; _L74);
    _L71= NumberOfCycle;
    _L70= false;
    _L68= _L61 and _L59;
    _L65= _L73 or _L64;
    _L64= _L70 -> _L68;
    _L63= 0;
    _L62= _L65 and _L76;
    _L61= not _L1;
    _L59= pre _L1;
    _L77= (activate #11 count_down every _L65 initial default _L79)(_L64, _L71);
    _L79= 0;
  tel
  
  node FlipFlopJK(Set : bool; Reset : bool; Init : bool)
    returns (FFJK_Output : bool)
  var
    _L10 : bool;
    _L11 : bool;
    _L12 : bool;
    _L2 : bool;
    _L4 : bool;
    _L5 : bool;
    _L6 : bool;
    _L9 : bool;
    _L18 : bool;
    _L20 : bool;
    _L21 : bool;
  let
    _L2= _L9 -> _L10;
    _L4= pre _L2;
    _L5= Set;
    _L6= Reset;
    _L9= Init;
    FFJK_Output= _L2;
    _L10= if _L12 then _L11 else _L18;
    _L11= not _L4;
    _L12= _L5 and _L6;
    _L18= _L5 or _L21;
    _L20= not _L6;
    _L21= _L20 and _L4;
  tel
  
  node #pragma kcg expand #end FlipFlopReset(
      Set : bool;
      Reset : bool;
      Init : bool)
    returns (FFR_Output : bool)
  var
    _L10 : bool;
    _L2 : bool;
    _L4 : bool;
    _L7 : bool;
    _L8 : bool;
    _L11 : bool;
    _L12 : bool;
    _L14 : bool;
  let
    _L2= _L10 -> _L14;
    _L4= pre _L2;
    _L7= Set;
    _L8= Reset;
    FFR_Output= _L2;
    _L10= Init;
    _L11= _L7 or _L4;
    _L12= not _L8;
    _L14= _L12 and _L11;
  tel
  
  node #pragma kcg expand #end FlipFlopSet(
      Set : bool;
      Reset : bool;
      Init : bool)
    returns (FFS_Output : bool)
  var
    _L10 : bool;
    _L2 : bool;
    _L4 : bool;
    _L5 : bool;
    _L6 : bool;
    _L11 : bool;
    _L12 : bool;
    _L13 : bool;
  let
    _L2= _L10 -> _L13;
    _L4= pre _L2;
    FFS_Output= _L2;
    _L5= Set;
    _L6= Reset;
    _L10= Init;
    _L11= not _L6;
    _L12= _L11 and _L4;
    _L13= _L5 or _L12;
  tel
  
  node RisingEdge(RE_Input : bool) returns (RE_Output : bool)
  var
    _L1 : bool;
    _L6 : bool;
    _L3 : bool;
    _L8 : bool;
  let
    _L1= RE_Input;
    RE_Output= _L6;
    _L3= fby(_L1; 1; _L1);
    _L6= _L8 and _L1;
    _L8= not _L3;
  tel
  
  node RisingEdgeRetrigger(RER_Input : bool; NumberOfCycle : int)
    returns (RER_Output : bool)
  var
    _L13 : bool;
    _L14 : bool;
    _L16 : bool;
    _L31 : bool;
    _L44 : int;
    _L43 : bool;
    _L41 : int;
    _L39 : bool;
    _L38 : bool;
    _L36 : bool;
    _L35 : bool;
    _L46 : bool;
    _L47 : bool;
    _L48 : int;
    _L50 : int;
  let
    RER_Output= _L43;
    _L13= RER_Input;
    _L14= pre _L31;
    _L16= _L13 and _L14;
    _L31= not _L13;
    _L44= 0;
    _L43= _L38 and _L35;
    _L41= NumberOfCycle;
    _L39= fby(_L43; 1; _L36);
    _L38= _L39 or _L46;
    _L36= false;
    _L35= _L44 < _L48;
    _L46= _L47 -> _L16;
    _L47= false;
    _L48= (activate #11 count_down every _L38 initial default _L50)(_L46, _L41);
    _L50= 0;
  tel
  
  function #pragma kcg expand #end Toggle(T_Input : bool)
    returns (T_On : bool; T_Off : bool)
  var
    _L3 : bool;
    _L9 : bool;
  let
    _L3= T_Input;
    T_On= _L3;
    T_Off= _L9;
    _L9= not _L3;
  tel
  
  node RisingEdgeNoRetrigger(RENR_Input : bool; NumberOfCycle : int)
    returns (RENR_Output : bool)
  var
    _L90 : bool;
    _L87 : bool;
    _L86 : int;
    _L85 : bool;
    _L84 : bool;
    _L82 : bool;
    _L81 : bool;
    _L80 : int;
    _L79 : bool;
    _L78 : bool;
    _L77 : bool;
    _L76 : bool;
    _L75 : bool;
    _L91 : bool;
    _L92 : bool;
    _L93 : int;
    _L95 : int;
  let
    RENR_Output= _L78;
    _L90= _L80 < _L93;
    _L87= fby(_L78; 1; _L92);
    _L86= NumberOfCycle;
    _L85= _L91 and _L76;
    _L84= false;
    _L82= _L87 or _L79;
    _L81= _L75 and _L79;
    _L80= 0;
    _L79= _L84 -> _L85;
    _L78= _L82 and _L90;
    _L77= not _L91;
    _L76= pre _L77;
    _L75= not _L87;
    _L91= RENR_Input;
    _L92= false;
    _L93= (activate #13 count_down every _L82 initial default _L95)(_L81, _L86);
    _L95= 0;
  tel
  
  node count_down(Reset : bool; N : int) returns (cpt : int)
  var
    _L1 : bool;
    _L2 : int;
    _L3 : int;
    _L4 : int;
    _L7 : int;
    _L8 : int;
    _L13 : int;
  let
    _L1= Reset;
    _L2= N;
    cpt= _L3;
    _L3= if _L1 then _L2 else _L8;
    _L4= _L3 - _L7;
    _L7= 1;
    _L8= _L2 -> _L13;
    _L13= pre _L4;
  tel
  
  node EitherEdge(EE_Input : bool) returns (EE_Output : bool)
  var
    _L1 : bool;
    _L3 : bool;
    _L4 : bool;
  let
    _L1= EE_Input;
    EE_Output= _L3;
    _L3= _L4 xor _L1;
    _L4= fby(_L1; 1; _L1);
  tel
  
  function #pragma kcg expand #end BoolVect2IntElt(Acc : int; bi : bool)
    returns (AccOut : int)
  var
    _L1 : int;
    _L2 : bool;
    _L4 : int;
    _L5 : int;
    _L6 : int;
    _L7 : int;
    _L8 : int;
    _L9 : int;
  let
    AccOut= _L8;
    _L1= Acc;
    _L2= bi;
    _L4= _L1 * _L9;
    _L5= if _L2 then _L6 else _L7;
    _L6= 1;
    _L7= 0;
    _L8= _L5 + _L4;
    _L9= 2;
  tel
  
  function Int2BoolVectElt(Acc : int) returns (AccOut : int; bi : bool)
  var
    _L1 : int;
    _L9 : int;
    _L10 : int;
    _L11 : int;
    _L12 : bool;
    _L13 : int;
  let
    AccOut= _L10;
    _L1= Acc;
    _L9= 2;
    _L10= _L1 div _L9;
    bi= _L12;
    _L11= _L1 mod _L9;
    _L12= _L11 = _L13;
    _L13= 1;
  tel
  
  function BoolVect2Int<<Nbool>>(BV : bool^Nbool) returns (Out : int)
  var
    _L2 : int;
    _L3 : int;
    _L4 : bool^Nbool;
  let
    _L2= (fold #1 BoolVect2IntElt <<Nbool>>)(_L3, _L4);
    _L3= 0;
    _L4= BV;
    Out= _L2;
  tel
  
  function Int2BoolVect<<Nbool>>(In : int) returns (BV : bool^Nbool)
  var
    #pragma kcg keep #end Acc : int;
    _L1 : int;
    _L4 : bool^Nbool;
    _L5 : bool^Nbool;
  let
    _L1= In;
    BV= _L5;
    Acc, _L4= (mapfold #1 Int2BoolVectElt <<Nbool>>)(_L1);
    _L5= reverse _L4;
    _= Acc;
  tel
  
end;

/* $*************** KCG Version 6.1.2 (build i5) ****************
** -
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */
/* $*************** KCG Version 6.1.2 (build i5) ****************
** Command: x2s612 C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/libdigital/TruthTables.xscade
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */

/* xscade source: C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/libdigital/TruthTables.xscade */
package truthtables
  open digital;
  type TruthTableValues = enum { T, F, X };
  
  function TruthTableElt(AccIn : bool; Cond : bool; TTelt : TruthTableValues)
    returns (AccOut : bool)
  var
    _L1 : bool;
    _L2 : bool;
    _L13 : bool;
    _L15 : bool;
    _L14 : bool;
    _L16 : bool;
    _L17 : TruthTableValues;
  let
    _L1= _L2 and _L13;
    _L2= AccIn;
    AccOut= _L1;
    _L13= (case _L17 of | T: _L14 | F: _L15 | _: _L16);
    _L14= Cond;
    _L15= not _L14;
    _L16= true;
    _L17= TTelt;
  tel
  
  function TruthTableLineIdx<<Ncond>>(
      Idx : int;
      AccIn : int;
      Conditions : bool^Ncond;
      TTline : TruthTableValues^Ncond)
    returns (AccOut : int)
  var
    _L2 : bool;
    _L3 : int;
    _L4 : int;
    _L8 : int;
    _L10 : bool^Ncond;
    _L11 : bool;
    _L12 : TruthTableValues^Ncond;
  let
    _L2= (fold #1 TruthTableElt <<Ncond>>)(_L11, _L10, _L12);
    _L3= if _L2 then _L8 else _L4;
    AccOut= _L3;
    _L4= AccIn;
    _L8= Idx;
    _L10= Conditions;
    _L11= true;
    _L12= TTline;
  tel
  
  function TruthTableIdx<<Ncond, Nlines>>(
      Conditions : bool^Ncond;
      Ttable : TruthTableValues^Ncond^Nlines)
    returns (LineIdx : int)
  var
    _L1 : bool^Ncond;
    _L2 : TruthTableValues^Ncond^Nlines;
    _L6 : int;
    _L8 : bool^Ncond^Nlines;
    _L9 : TruthTableValues^Ncond^Nlines;
    _L10 : int;
    _L11 : int;
    _L12 : int;
  let
    _L1= Conditions;
    _L2= Ttable;
    LineIdx= _L10;
    _L6= -1;
    _L8= _L1^Nlines;
    _L9= reverse _L2;
    _L10= _L11 - _L12;
    _L11= Nlines - 1;
    _L12= (foldi (#2 TruthTableLineIdx <<Ncond>>) <<Nlines>>)(_L6, _L8, _L9);
  tel
  
  function TruthTableExh<<Nbool, Nres>>(BV : bool^Nbool; ResultValues : 'T^Nres)
    returns (Result : 'T)
  var
    _L1 : bool^Nbool;
    _L3 : 'T;
    _L4 : 'T^Nres;
    _L5 : int;
  let
    _L1= BV;
    _L3= (_L4.[_L5] default ResultValues[0]);
    _L4= ResultValues;
    Result= _L3;
    _L5= (#3 BoolVect2Int <<Nbool>>)(_L1);
    assume A1 : Nres = (fold #2 $*$ <<Nbool>>)(1, 2^Nbool);
  tel
  
  function TruthTableLine<<Ncond>>(
      AccIn : 'T;
      Conditions : bool^Ncond;
      ResultValue : 'T;
      TTline : TruthTableValues^Ncond)
    returns (Continue : bool; AccOut : 'T)
  var
    _L2 : bool;
    _L3 : 'T;
    _L4 : 'T;
    _L10 : bool^Ncond;
    _L11 : bool;
    _L12 : TruthTableValues^Ncond;
    _L14 : 'T;
    _L15 : bool;
  let
    _L2= (fold #1 TruthTableElt <<Ncond>>)(_L11, _L10, _L12);
    _L3= if _L2 then _L14 else _L4;
    AccOut= _L3;
    _L4= AccIn;
    _L10= Conditions;
    _L11= true;
    _L12= TTline;
    _L14= ResultValue;
    Continue= _L15;
    _L15= not _L2;
  tel
  
  function TruthTable<<Ncond, Nlines>>(
      Conditions : bool^Ncond;
      ResultValues : 'T^(Nlines + 1);
      Ttable : TruthTableValues^Ncond^Nlines)
    returns (Result : 'T)
  var
    _L1 : bool^Ncond;
    _L2 : TruthTableValues^Ncond^Nlines;
    _L7 : 'T^(Nlines + 1);
    _L9 : bool^Ncond^Nlines;
    _L12 : 'T;
    _L16 : 'T^(Nlines + 1);
    _L17 : bool;
    _L19 : 'T;
    _L18 : int;
    _L21 : 'T^(Nlines - 1 - 0 + 1);
  let
    _L1= Conditions;
    _L2= Ttable;
    Result= _L19;
    _L7= ResultValues;
    _L9= _L1^Nlines;
    _L12= _L16[Nlines];
    _L16= ResultValues;
    _L17= true;
    _L18, _L19=
      (foldw (#4 TruthTableLine <<Ncond>>) <<Nlines>> if _L17)(_L12, _L9, _L21,
        _L2);
    _= _L18;
    _L21= _L7 [0 .. Nlines - 1];
  tel
  
end;

/* $*************** KCG Version 6.1.2 (build i5) ****************
** -
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */
/* $*************** KCG Version 6.1.2 (build i5) ****************
** Command: x2s612 C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/liblinear/linear.xscade
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */

/* xscade source: C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/liblinear/linear.xscade */
package linear
  function #pragma kcg expand #end Gain(G_Input : 'T; Gain : 'T)
    returns (G_Output : 'T)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
  let
    _L1= G_Input;
    _L2= Gain;
    G_Output= _L3;
    _L3= _L1 * _L2;
  tel
  
  node MeanCycle2(U : 'T) returns (MeanOn2Steps : real) where 'T numeric
  var
    _L1 : 'T;
    _L13 : 'T;
    _L14 : 'T;
    _L8 : real;
    _L9 : 'T;
  let
    _L1= U;
    MeanOn2Steps= _L8;
    _L8= _L14 / _L9;
    _L9= (2 : 'T);
    _L13= fby(_L1; 1; _L1);
    _L14= _L1 + _L13;
  tel
  
  node MeanCycle3(U : 'T) returns (MeanOn3Step : real) where 'T numeric
  var
    _L10 : 'T;
    _L11 : 'T;
    _L12 : real;
    _L6 : 'T;
    _L7 : 'T;
    _L9 : 'T;
  let
    MeanOn3Step= _L12;
    _L6= U;
    _L7= fby(_L6; 1; _L6);
    _L9= fby(_L7; 1; _L6);
    _L10= (3 : 'T);
    _L11= _L6 + _L7 + _L9;
    _L12= _L11 / _L10;
  tel
  
  node Derivative(u : real; TimeCycle : real) returns (Derivative : real)
  var
    _L1 : real;
    _L2 : real;
    _L3 : real;
    _L6 : real;
    _L7 : real;
    _L8 : real;
    _L9 : real;
  let
    _L1= _L3 - _L2;
    _L2= pre _L3;
    _L3= u;
    Derivative= _L6;
    _L6= _L7 -> _L8;
    _L7= 0.0;
    _L8= _L1 / _L9;
    _L9= TimeCycle;
  tel
  
  node #pragma kcg expand #end Filter1stOrderLoop(
      F1OL_Input : real;
      K1 : real;
      K2 : real;
      Init : real)
    returns (F1OL_Output : real)
  var
    _L9 : real;
    _L8 : real;
    _L7 : real;
    _L6 : real;
    _L5 : real;
    _L4 : real;
    _L3 : real;
    _L2 : real;
    _L1 : real;
  let
    _L9= Init;
    _L8= _L9 -> _L7;
    _L7= _L4 - _L6;
    _L6= _L5 * _L2;
    _L5= pre _L8;
    _L4= _L3 * _L1;
    F1OL_Output= _L8;
    _L3= F1OL_Input;
    _L2= K2;
    _L1= K1;
  tel
  
  node IntegrTrapez(
      U : real;
      Reset : bool;
      TimeCycle : real;
      LowLimit : real;
      HiLimit : real)
    returns (Y : real)
  var
    _L1 : real;
    _L10 : real;
    _L11 : real;
    _L12 : real;
    _L2 : real;
    _L3 : real;
    _L4 : real;
    _L6 : real;
    _L7 : real;
    _L8 : real;
    _L9 : real;
    _L13 : real;
    _L14 : real;
    _L15 : real;
    _L16 : real;
    _L17 : bool;
    _L18 : bool;
    _L20 : real;
    _L21 : real;
    _L22 : bool;
  let
    _L2= TimeCycle;
    _L3= pre _L1;
    _L4= pre _L20;
    _L6= _L4 + _L7;
    _L7= _L12 * _L8;
    _L8= _L2 / _L11;
    _L9= _L10 -> _L6;
    Y= _L20;
    _L10= 0.0;
    _L11= 2.0;
    _L12= _L1 + _L3;
    _L1= U;
    _L13= LowLimit;
    _L14= HiLimit;
    _L15= if _L17 then _L13 else _L9;
    _L16= if _L18 then _L14 else _L15;
    _L17= _L9 <= _L13;
    _L18= _L15 >= _L14;
    _L20= if _L22 then _L21 else _L16;
    _L21= 0.0;
    _L22= Reset;
  tel
  
  node IntegrFwd(
      U : real;
      Reset : bool;
      TimeCycle : real;
      LowLimit : real;
      HiLimit : real)
    returns (Y : real)
  var
    _L17 : bool;
    _L16 : bool;
    _L15 : real;
    _L14 : real;
    _L13 : real;
    _L12 : real;
    _L11 : real;
    _L8 : real;
    _L7 : real;
    _L5 : real;
    _L4 : real;
    _L3 : real;
    _L1 : real;
    _L19 : real;
    _L21 : real;
    _L22 : bool;
  let
    _L17= _L14 >= _L13;
    _L16= _L7 <= _L12;
    _L15= if _L17 then _L13 else _L14;
    _L14= if _L16 then _L12 else _L7;
    _L13= HiLimit;
    _L12= LowLimit;
    _L11= U;
    _L8= 0.0;
    Y= _L19;
    _L7= _L8 -> _L4;
    _L5= _L11 * _L1;
    _L4= _L3 + _L5;
    _L3= pre _L19;
    _L1= TimeCycle;
    _L19= if _L22 then _L21 else _L15;
    _L21= 0.0;
    _L22= Reset;
  tel
  
  node #pragma kcg expand #end Memory(
      M_Input : 'T;
      Reset : bool;
      MemCond : bool;
      InitVal : 'T)
    returns (Out : 'T)
  var
    _L8 : 'T;
    _L7 : 'T;
    _L6 : 'T;
    _L5 : 'T;
    _L3 : bool;
    _L2 : 'T;
    _L1 : bool;
    _L9 : 'T;
  let
    Out= _L8;
    _L8= if _L1 then _L2 else _L7;
    _L7= if _L3 then _L6 else _L5;
    _L6= M_Input;
    _L5= fby(_L8; 1; _L9);
    _L3= MemCond;
    _L2= InitVal;
    _L1= Reset;
    _L9= InitVal;
  tel
  
  node HitCrossingEither(HCE_Input : 'T; Offset : 'T)
    returns (HCE_Output : bool)
    where 'T numeric
  var
    _L1 : 'T;
    _L5 : 'T;
    _L24 : bool;
    _L25 : bool;
    _L26 : bool;
    _L28 : bool;
    _L29 : bool;
    _L30 : bool;
    _L31 : bool;
    _L43 : 'T;
  let
    _L1= HCE_Input;
    _L5= Offset;
    _L24= _L43 <= _L5;
    _L25= _L1 >= _L5;
    _L26= _L24 and _L25;
    _L28= _L43 >= _L5;
    _L29= _L1 <= _L5;
    _L30= _L28 and _L29;
    _L31= _L26 or _L30;
    HCE_Output= _L31;
    _L43= fby(_L1; 1; _L1);
  tel
  
  node HitCrossingFalling(HCF_Input : 'T; Offset : 'T)
    returns (HCF_Output : bool)
    where 'T numeric
  var
    _L1 : 'T;
    _L5 : 'T;
    _L10 : bool;
    _L18 : bool;
    _L22 : 'T;
    _L24 : bool;
    _L25 : bool;
    _L26 : bool;
    _L27 : bool;
    _L28 : bool;
    _L29 : bool;
    _L30 : bool;
  let
    _L1= HCF_Input;
    _L5= Offset;
    _L10= _L18 -> _L30;
    _L18= false;
    _L22= pre _L1;
    _L24= _L22 >= _L5;
    _L25= _L1 < _L5;
    _L26= _L24 and _L25;
    HCF_Output= _L10;
    _L27= _L22 > _L5;
    _L28= _L1 = _L5;
    _L29= _L27 and _L28;
    _L30= _L26 or _L29;
  tel
  
  node HitCrossingRising(HCR_Input : 'T; Offset : 'T)
    returns (HCR_Output : bool)
    where 'T numeric
  var
    _L1 : 'T;
    _L5 : 'T;
    _L10 : bool;
    _L18 : bool;
    _L22 : 'T;
    _L24 : bool;
    _L25 : bool;
    _L26 : bool;
    _L27 : bool;
    _L28 : bool;
    _L29 : bool;
    _L30 : bool;
  let
    _L1= HCR_Input;
    _L5= Offset;
    _L10= _L18 -> _L30;
    _L18= false;
    _L22= pre _L1;
    _L24= _L22 <= _L5;
    _L25= _L1 > _L5;
    _L26= _L24 and _L25;
    HCR_Output= _L10;
    _L27= _L22 < _L5;
    _L28= _L1 = _L5;
    _L29= _L27 and _L28;
    _L30= _L26 or _L29;
  tel
  
  node #pragma kcg expand #end MemoryBasic(
      BM_Input : 'T;
      Init : 'T;
      Write : bool)
    returns (Memorized : 'T)
  var
    _L2 : 'T;
    _L4 : 'T;
    _L5 : bool;
    _L6 : 'T;
    _L7 : 'T;
  let
    _L2= BM_Input;
    Memorized= _L4;
    _L4= if _L5 then _L2 else _L6;
    _L5= Write;
    _L6= fby(_L4; 1; _L7);
    _L7= Init;
  tel
  
end;

/* $*************** KCG Version 6.1.2 (build i5) ****************
** -
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */
/* $*************** KCG Version 6.1.2 (build i5) ****************
** Command: x2s612 C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/liblinear/filters.xscade
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */

/* xscade source: C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/liblinear/filters.xscade */
package filters
  node TransferFcn01(In : real; Num : real; Den : real^2) returns (Out : real)
  var
    _L44 : real;
    _L40 : real;
    _L29 : real;
    _L65 : real;
    _L66 : real;
    _L69 : real;
    _L72 : real;
    _L77 : real;
    _L78 : real;
  let
    Out= _L65;
    _L44= _L72 * _L65;
    _L40= _L29 * _L69;
    _L29= In;
    _L65= _L77 / _L78;
    _L66= _L40 - _L44;
    _L69= Num;
    _L72= Den[1];
    _L77= fby(_L66; 1; 0.0);
    _L78= Den[0];
  tel
  
  node private SumDelay(Delay : real; Val : real) returns (Out : real)
  var
    _L2 : real;
    _L3 : real;
    _L15 : real;
    _L21 : real;
  let
    _L2= Delay;
    _L3= Val;
    Out= _L15;
    _L15= _L21 + _L3;
    _L21= fby(_L2; 1; 0.0);
  tel
  
  node Filter01(In : real; Num : real; Den : real^2) returns (Out : real)
  var
    _L46 : real;
    _L66 : real;
    _L69 : real;
    _L71 : real;
    _L72 : real;
    _L73 : real;
    _L74 : real;
    _L76 : real;
    _L77 : real;
  let
    _L46= _L73 / _L66;
    Out= _L46;
    _L66= Den[0];
    _L69= In;
    _L71= _L69 * _L72;
    _L72= Num;
    _L73= _L71 - _L77;
    _L74= _L76 * _L46;
    _L76= Den[1];
    _L77= fby(_L74; 1; 0.0);
  tel
  
  node Filter11(In : real; Num : real^2; Den : real^2) returns (Out : real)
  var
    _L200 : real;
    _L203 : real;
    _L229 : real;
    _L230 : real;
    _L231 : real;
    _L232 : real;
    _L233 : real;
    _L234 : real;
    _L235 : real;
    _L243 : real;
    _L244 : real;
    _L245 : real;
  let
    _L203= In;
    _L200= _L230 * _L203;
    _L229= _L231 / _L245;
    Out= _L229;
    _L230= Num[0];
    _L231= _L200 + _L244;
    _L232= Den[1];
    _L233= Num[1];
    _L234= _L203 * _L233;
    _L235= _L232 * _L229;
    _L243= _L234 - _L235;
    _L244= fby(_L243; 1; 0.0);
    _L245= Den[0];
  tel
  
  node Filter0D<<Ds>>(In : real; Num : real; Den : real^Ds) returns (Out : real)
  var
    _L3 : real;
    _L14 : real^(Ds - 1);
    _L68 : real;
    _L73 : real^(Ds - 1);
    _L16 : real^(Ds - 1);
    _L116 : real;
    _L126 : real;
    _L129 : real;
    _L132 : real^(Ds - 1 - 1 + 1);
    _L134 : real^Ds;
    _L135 : real;
    _L136 : real;
    _L137 : real;
    _L138 : real;
  let
    _L3= In;
    _L14= reverse _L16;
    _L68= (fold #2 SumDelay <<Ds - 1>>)(_L126, _L14);
    Out= _L116;
    _L73= _L116^(Ds - 1);
    _L116= _L138 / _L136;
    _L126= 0.0;
    _L129= _L3 * _L135;
    _L132= _L134 [1 .. Ds - 1];
    _L134= Den;
    _L135= Num;
    _L136= Den[0];
    _L137= fby(_L68; 1; 0.0);
    _L138= _L129 - _L137;
    _L16= (map #14 $*$ <<Ds - 1>>)(_L132, _L73);
  tel
  
  node FilterNN<<Ns>>(In : real; Num : real^Ns; Den : real^Ns)
    returns (Out : real)
  var
    _L3 : real;
    _L7 : real^(Ns - 1);
    _L68 : real;
    _L71 : real^(Ns - 1);
    _L73 : real^(Ns - 1);
    _L10 : real^(Ns - 1);
    _L16 : real^(Ns - 1);
    _L116 : real;
    _L126 : real;
    _L128 : real^(Ns - 1);
    _L129 : real^Ns;
    _L132 : real^Ns;
    _L133 : real;
    _L134 : real^(Ns - 1 - 1 + 1);
    _L135 : real;
    _L141 : real;
    _L140 : real;
    _L142 : real;
    _L143 : real;
    _L144 : real^(Ns - 1 - 1 + 1);
  let
    _L3= In;
    _L7= _L3^(Ns - 1);
    _L68= (fold #3 SumDelay <<Ns - 1>>)(_L126, _L128);
    Out= _L116;
    _L73= _L116^(Ns - 1);
    _L116= _L143 / _L133;
    _L126= 0.0;
    _L128= reverse _L71;
    _L129= Num;
    _L132= Den;
    _L133= Den[0];
    _L134= _L129 [1 .. Ns - 1];
    _L135= fby(_L68; 1; 0.0);
    _L140= Num[0];
    _L141= In;
    _L142= _L141 * _L140;
    _L143= _L142 + _L135;
    _L144= _L132 [1 .. Ns - 1];
    _L10= (map #19 $*$ <<Ns - 1>>)(_L7, _L134);
    _L16= (map #22 $*$ <<Ns - 1>>)(_L144, _L73);
    _L71= (map #25 $-$ <<Ns - 1>>)(_L10, _L16);
  tel
  
  node FilterND<<Ns, Ds>>(In : real; Num : real^Ns; Den : real^Ds)
    returns (Out : real)
  var
    _L7 : real^(Ns - 1);
    _L68 : real;
    _L71 : real^(Ds - 1);
    _L73 : real^(Ds - 1);
    _L10 : real^(Ns - 1);
    _L16 : real^(Ds - 1);
    _L116 : real;
    _L118 : real;
    _L120 : real^(Ns - 1 + (Ds - Ns));
    _L124 : real^(Ds - Ns);
    _L126 : real;
    _L128 : real;
    _L129 : real^(Ds - 1);
    _L130 : real^Ns;
    _L133 : real^Ds;
    _L134 : real;
    _L135 : real^(Ds - 1 - 1 + 1);
    _L136 : real^(Ns - 1 - 1 + 1);
    _L137 : real;
    _L139 : real;
    _L138 : real;
    _L140 : real;
    _L143 : real;
  let
    _L7= _L128^(Ns - 1);
    _L68= (fold #3 SumDelay <<Ds - 1>>)(_L126, _L129);
    Out= _L116;
    _L73= _L116^(Ds - 1);
    _L116= _L137 / _L134;
    _L118= 0.0;
    _L120= _L10 @ _L124;
    _L124= _L118^(Ds - Ns);
    _L126= 0.0;
    _L128= In;
    _L129= reverse _L71;
    _L130= Num;
    _L133= Den;
    _L134= Den[0];
    _L135= _L133 [1 .. Ds - 1];
    _L136= _L130 [1 .. Ns - 1];
    _L137= _L140 + _L143;
    _L138= In;
    _L139= Num[0];
    _L140= _L138 * _L139;
    _L143= fby(_L68; 1; 0.0);
    _L10= (map #22 $*$ <<Ns - 1>>)(_L7, _L136);
    _L16= (map #25 $*$ <<Ds - 1>>)(_L135, _L73);
    _L71= (map #28 $-$ <<Ds - 1>>)(_L120, _L16);
  tel
  
  node TransferFcn02(In : real; Num : real; Den : real^3) returns (Out : real)
  var
    _L29 : real;
    _L65 : real;
    _L75 : real;
    _L76 : real;
    _L77 : real;
    _L78 : real;
    _L79 : real;
    _L80 : real;
    _L81 : real;
    _L85 : real;
    _L86 : real;
    _L87 : real;
    _L107 : real;
  let
    Out= _L65;
    _L29= In;
    _L65= _L107 / _L87;
    _L75= Den[2];
    _L76= _L75 * _L65;
    _L77= _L29 * _L78;
    _L78= Num;
    _L80= fby(_L79; 1; 0.0);
    _L81= _L85 * _L65;
    _L85= Den[1];
    _L86= _L80 - _L81;
    _L87= Den[0];
    _L79= _L77 - _L76;
    _L107= fby(_L86; 1; 0.0);
  tel
  
  node Filter02(In : real; Num : real; Den : real^3) returns (Out : real)
  var
    _L29 : real;
    _L40 : real;
    _L46 : real;
    _L63 : real;
    _L64 : real;
    _L65 : real;
    _L66 : real;
    _L67 : real;
    _L68 : real;
    _L69 : real;
    _L70 : real;
    _L74 : real;
    _L75 : real;
  let
    _L29= In;
    _L40= _L29 * _L63;
    _L46= _L74 / _L69;
    Out= _L46;
    _L63= Num;
    _L65= Den[1];
    _L66= _L65 * _L46;
    _L67= _L68 * _L46;
    _L68= Den[2];
    _L69= Den[0];
    _L70= fby(_L66; 1; 0.0);
    _L74= _L64 - _L75;
    _L75= fby(_L67; 2; 0.0);
    _L64= _L40 - _L70;
  tel
  
  node TransferFcn0D<<Ds>>(In : real; Num : real; Den : real^Ds)
    returns (Out : real)
  var
    _L4 : real^(Ds - 2 - 1 + 1);
    _L5 : real^Ds;
    _L6 : real;
    _L7 : real;
    _L8 : real;
    _L9 : real;
    _L10 : real;
    _L11 : real;
    _L18 : real;
    _L19 : real^(Ds - 2);
    _L20 : real;
    _L21 : real;
    _L22 : real;
    _L23 : real^(Ds - 2);
    _L26 : real^(Ds - 2);
  let
    _L4= _L5 [1 .. Ds - 2];
    _L5= Den;
    _L6= In;
    _L7= Num;
    _L8= _L6 * _L7;
    _L9= Den[Ds - 1];
    _L10= _L9 * _L21;
    _L19= reverse _L23;
    _L20= fby(_L18; 1; 0.0);
    _L21= _L20 / _L22;
    _L22= Den[0];
    Out= _L21;
    _L26= _L21^(Ds - 2);
    _L11= _L8 - _L10;
    _L18= (fold #14 SumDelay <<Ds - 2>>)(_L11, _L19);
    _L23= (map #17 $*$ <<Ds - 2>>)(_L4, _L26);
  tel
  
  node Filter01Norm(In : real; Num : real; Den : real) returns (Out : real)
  var
    _L69 : real;
    _L71 : real;
    _L72 : real;
    _L73 : real;
    _L74 : real;
    _L76 : real;
    _L77 : real;
  let
    Out= _L73;
    _L69= In;
    _L71= _L69 * _L72;
    _L72= Num;
    _L73= _L71 - _L77;
    _L74= _L76 * _L73;
    _L76= Den;
    _L77= fby(_L74; 1; 0.0);
  tel
  
  node Filter12(In : real; Num : real^2; Den : real^3) returns (Out : real)
  var
    _L200 : real;
    _L203 : real;
    _L229 : real;
    _L230 : real;
    _L231 : real;
    _L232 : real;
    _L233 : real;
    _L234 : real;
    _L235 : real;
    _L243 : real;
    _L244 : real;
    _L245 : real;
    _L248 : real;
    _L249 : real;
    _L250 : real;
    _L253 : real;
  let
    _L203= In;
    _L200= _L230 * _L203;
    _L229= _L248 / _L245;
    Out= _L229;
    _L230= Num[0];
    _L231= _L200 + _L244;
    _L232= Den[1];
    _L233= Num[1];
    _L234= _L203 * _L233;
    _L235= _L232 * _L229;
    _L243= _L234 - _L235;
    _L244= fby(_L243; 1; 0.0);
    _L245= Den[0];
    _L248= _L231 - _L250;
    _L249= _L253 * _L229;
    _L250= fby(_L249; 2; 0.0);
    _L253= Den[2];
  tel
  
  node TransferFcn12(In : real; Num : real^2; Den : real^3) returns (Out : real)
  var
    _L29 : real;
    _L65 : real;
    _L75 : real;
    _L76 : real;
    _L77 : real;
    _L78 : real;
    _L79 : real;
    _L80 : real;
    _L81 : real;
    _L85 : real;
    _L86 : real;
    _L87 : real;
    _L93 : real;
    _L94 : real;
    _L97 : real;
    _L98 : real;
    _L104 : real;
  let
    Out= _L65;
    _L29= In;
    _L65= _L98 / _L87;
    _L75= Den[2];
    _L76= _L75 * _L65;
    _L77= _L78 * _L29;
    _L78= Num[1];
    _L80= fby(_L79; 1; 0.0);
    _L81= _L85 * _L65;
    _L85= Den[1];
    _L87= Den[0];
    _L93= _L94 - _L81;
    _L86= _L80 + _L93;
    _L94= _L97 * _L104;
    _L97= Num[0];
    _L98= fby(_L86; 1; 0.0);
    _L79= _L77 - _L76;
    _L104= In;
  tel
  
  node TransferFcnND<<Ns, Ds>>(In : real; Num : real^Ns; Den : real^Ds)
    returns (Out : real)
  var
    _L4 : real^(Ds - 1 - 1 + 1);
    _L5 : real^Ds;
    _L6 : real;
    _L7 : real^Ns;
    _L18 : real;
    _L19 : real^(Ds - 1);
    _L20 : real;
    _L21 : real;
    _L22 : real;
    _L23 : real^(Ds - 1);
    _L26 : real^(Ds - 1);
    _L31 : real^Ns;
    _L32 : real^Ns;
    _L36 : real^(Ns + (Ds - Ns - 1));
    _L38 : real;
    _L41 : real^(Ds - 1);
    _L47 : real;
    _L48 : real^(Ds - Ns - 1);
  let
    _L4= _L5 [1 .. Ds - 1];
    _L5= Den;
    _L6= In;
    _L7= Num;
    _L18= (fold #3 SumDelay <<Ds - 1>>)(_L47, _L19);
    _L19= reverse _L41;
    _L20= fby(_L18; 1; 0.0);
    _L21= _L20 / _L22;
    _L22= Den[0];
    Out= _L21;
    _L26= _L21^(Ds - 1);
    _L31= _L6^Ns;
    _L36= _L48 @ _L32;
    _L48= _L38^(Ds - Ns - 1);
    _L38= 0.0;
    _L47= 0.0;
    _L32= (map #17 $*$ <<Ns>>)(_L31, _L7);
    _L23= (map #19 $*$ <<Ds - 1>>)(_L4, _L26);
    _L41= (map #22 $-$ <<Ds - 1>>)(_L36, _L23);
  tel
  
  node Filter02Norm(In : real; Num : real; Den : real^2) returns (Out : real)
  var
    _L29 : real;
    _L40 : real;
    _L63 : real;
    _L64 : real;
    _L65 : real;
    _L66 : real;
    _L67 : real;
    _L68 : real;
    _L70 : real;
    _L74 : real;
    _L75 : real;
  let
    _L29= In;
    _L40= _L29 * _L63;
    Out= _L74;
    _L63= Num;
    _L65= Den[0];
    _L66= _L65 * _L74;
    _L67= _L68 * _L74;
    _L68= Den[1];
    _L70= fby(_L66; 1; 0.0);
    _L74= _L64 - _L75;
    _L75= fby(_L67; 2; 0.0);
    _L64= _L40 - _L70;
  tel
  
  node Filter11Norm(In : real; Num : real^2; Den : real) returns (Out : real)
  var
    _L200 : real;
    _L203 : real;
    _L230 : real;
    _L231 : real;
    _L232 : real;
    _L233 : real;
    _L234 : real;
    _L235 : real;
    _L243 : real;
    _L244 : real;
  let
    _L203= In;
    _L200= _L230 * _L203;
    Out= _L231;
    _L230= Num[0];
    _L231= _L200 + _L244;
    _L232= Den;
    _L233= Num[1];
    _L234= _L203 * _L233;
    _L235= _L232 * _L231;
    _L243= _L234 - _L235;
    _L244= fby(_L243; 1; 0.0);
  tel
  
  node Filter12Norm(In : real; Num : real^2; Den : real^2) returns (Out : real)
  var
    _L200 : real;
    _L203 : real;
    _L230 : real;
    _L231 : real;
    _L232 : real;
    _L233 : real;
    _L234 : real;
    _L235 : real;
    _L243 : real;
    _L244 : real;
    _L248 : real;
    _L249 : real;
    _L250 : real;
    _L253 : real;
  let
    _L203= In;
    _L200= _L230 * _L203;
    Out= _L248;
    _L230= Num[0];
    _L231= _L200 + _L244;
    _L232= Den[0];
    _L233= Num[1];
    _L234= _L203 * _L233;
    _L235= _L232 * _L248;
    _L243= _L234 - _L235;
    _L244= fby(_L243; 1; 0.0);
    _L248= _L231 - _L250;
    _L249= _L253 * _L248;
    _L250= fby(_L249; 2; 0.0);
    _L253= Den[1];
  tel
  
  node Filter0DNorm<<Ds>>(In : real; Num : real; Den : real^Ds)
    returns (Out : real)
  var
    _L3 : real;
    _L14 : real^Ds;
    _L68 : real;
    _L73 : real^Ds;
    _L16 : real^Ds;
    _L126 : real;
    _L129 : real;
    _L134 : real^Ds;
    _L135 : real;
    _L137 : real;
    _L138 : real;
  let
    _L3= In;
    _L14= reverse _L16;
    _L68= (fold #2 SumDelay <<Ds>>)(_L126, _L14);
    Out= _L138;
    _L73= _L138^Ds;
    _L126= 0.0;
    _L129= _L3 * _L135;
    _L134= Den;
    _L135= Num;
    _L137= fby(_L68; 1; 0.0);
    _L138= _L129 - _L137;
    _L16= (map #8 $*$ <<Ds>>)(_L134, _L73);
  tel
  
  node FilterNDNorm<<Ns, Ds>>(In : real; Num : real^Ns; Den : real^Ds)
    returns (Out : real)
  var
    _L7 : real^(Ns - 1);
    _L68 : real;
    _L71 : real^Ds;
    _L73 : real^Ds;
    _L10 : real^(Ns - 1);
    _L16 : real^Ds;
    _L118 : real;
    _L120 : real^(Ns - 1 + (Ds - Ns + 1));
    _L124 : real^(Ds - Ns + 1);
    _L126 : real;
    _L128 : real;
    _L129 : real^Ds;
    _L130 : real^Ns;
    _L133 : real^Ds;
    _L136 : real^(Ns - 1 - 1 + 1);
    _L137 : real;
    _L139 : real;
    _L138 : real;
    _L140 : real;
    _L143 : real;
  let
    _L7= _L128^(Ns - 1);
    _L68= (fold #3 SumDelay <<Ds>>)(_L126, _L129);
    Out= _L137;
    _L73= _L137^Ds;
    _L118= 0.0;
    _L120= _L10 @ _L124;
    _L124= _L118^(Ds - Ns + 1);
    _L126= 0.0;
    _L128= In;
    _L129= reverse _L71;
    _L130= Num;
    _L133= Den;
    _L136= _L130 [1 .. Ns - 1];
    _L137= _L140 + _L143;
    _L138= In;
    _L139= Num[0];
    _L140= _L138 * _L139;
    _L143= fby(_L68; 1; 0.0);
    _L10= (map #17 $*$ <<Ns - 1>>)(_L7, _L136);
    _L16= (map #20 $*$ <<Ds>>)(_L133, _L73);
    _L71= (map #22 $-$ <<Ds>>)(_L120, _L16);
  tel
  
  node FilterNNNorm<<Ns>>(In : real; Num : real^Ns; Den : real^(Ns - 1))
    returns (Out : real)
  var
    _L3 : real;
    _L7 : real^(Ns - 1);
    _L68 : real;
    _L71 : real^(Ns - 1);
    _L73 : real^(Ns - 1);
    _L10 : real^(Ns - 1);
    _L16 : real^(Ns - 1);
    _L126 : real;
    _L128 : real^(Ns - 1);
    _L129 : real^Ns;
    _L132 : real^(Ns - 1);
    _L134 : real^(Ns - 1 - 1 + 1);
    _L135 : real;
    _L141 : real;
    _L140 : real;
    _L142 : real;
    _L143 : real;
  let
    _L3= In;
    _L7= _L3^(Ns - 1);
    _L68= (fold #3 SumDelay <<Ns - 1>>)(_L126, _L128);
    Out= _L143;
    _L73= _L143^(Ns - 1);
    _L126= 0.0;
    _L128= reverse _L71;
    _L129= Num;
    _L132= Den;
    _L134= _L129 [1 .. Ns - 1];
    _L135= fby(_L68; 1; 0.0);
    _L140= Num[0];
    _L141= In;
    _L142= _L141 * _L140;
    _L143= _L142 + _L135;
    _L10= (map #15 $*$ <<Ns - 1>>)(_L7, _L134);
    _L16= (map #18 $*$ <<Ns - 1>>)(_L132, _L73);
    _L71= (map #21 $-$ <<Ns - 1>>)(_L10, _L16);
  tel
  
end;

/* $*************** KCG Version 6.1.2 (build i5) ****************
** -
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */
/* $*************** KCG Version 6.1.2 (build i5) ****************
** Command: x2s612 C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/libmath/vect.xscade
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */

/* xscade source: C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/libmath/vect.xscade */
package vect
  function #pragma kcg expand #end ScalProd<<n>>(V : 'T^n; W : 'T^n)
    returns (SP : 'T)
    where 'T numeric
  var
    _L2 : 'T^n;
    _L3 : 'T^n;
    _L4 : 'T;
    _L6 : 'T;
    _L7 : 'T^n;
  let
    _L2= V;
    _L3= W;
    SP= _L6;
    _L4= (0 : 'T);
    _L6= (fold #2 $+$ <<n>>)(_L4, _L7);
    _L7= (map #1 $*$ <<n>>)(_L2, _L3);
  tel
  
  function MatVectProd<<m, n>>(A : 'T^n^m; V : 'T^n)
    returns (R : 'T^m)
    where 'T numeric
  var
    _L1 : 'T^n^m;
    _L2 : 'T^n;
    _L4 : 'T^n^m;
    _L7 : 'T^m;
  let
    _L1= A;
    _L2= V;
    R= _L7;
    _L7= (map (#1 ScalProd <<n>>) <<m>>)(_L1, _L4);
    _L4= _L2^m;
  tel
  
  function MatProd<<m, n, p>>(A : 'T^n^m; B : 'T^p^n)
    returns (C : 'T^p^m)
    where 'T numeric
  var
    _L1 : 'T^n^m;
    _L2 : 'T^p^n;
    _L4 : 'T^p^n^m;
    _L7 : 'T^p^m;
  let
    _L1= A;
    _L2= B;
    C= _L7;
    _L4= _L2^m;
    _L7= (map (#1 VectMatProd <<n, p>>) <<m>>)(_L1, _L4);
  tel
  
  function VectMatProd<<m, n>>(V : 'T^m; A : 'T^n^m)
    returns (R : 'T^n)
    where 'T numeric
  var
    _L1 : 'T^n^m;
    _L2 : 'T^m;
    _L4 : 'T^m^n;
    _L5 : 'T^m^n;
    _L8 : 'T^n;
  let
    _L1= A;
    _L2= V;
    R= _L8;
    _L8= (map (#1 ScalProd <<m>>) <<n>>)(_L5, _L4);
    _L4= _L2^n;
    _L5= transpose (_L1; 1; 2);
  tel
  
end;

/* $*************** KCG Version 6.1.2 (build i5) ****************
** -
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */
/* $*************** KCG Version 6.1.2 (build i5) ****************
** Command: x2s612 C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/libmath/math.xscade
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */

/* xscade source: C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/libmath/math.xscade */
package math
  function #pragma kcg expand #end Abs(A_Input : 'T)
    returns (A_Output : 'T)
    where 'T numeric
  var
    _L1 : bool;
    _L2 : 'T;
    _L3 : 'T;
    _L5 : 'T;
    _L8 : 'T;
  let
    _L1= _L8 <= _L5;
    _L2= if _L1 then _L5 else _L3;
    _L3= - _L5;
    _L5= A_Input;
    A_Output= _L2;
    _L8= (0 : 'T);
  tel
  
  function #pragma kcg expand #end BoolToInt(BTI_Input : bool)
    returns (BTI_Output : int)
  var
    _L1 : bool;
    _L2 : int;
    _L3 : int;
    _L4 : int;
  let
    _L1= BTI_Input;
    BTI_Output= _L2;
    _L2= if _L1 then _L3 else _L4;
    _L3= 1;
    _L4= 0;
  tel
  
  function #pragma kcg expand #end BoolToReal(BTR_Input : bool)
    returns (BTR_Output : real)
  var
    _L10 : real;
    _L5 : bool;
    _L6 : real;
    _L9 : real;
  let
    _L5= BTR_Input;
    BTR_Output= _L6;
    _L6= if _L5 then _L10 else _L9;
    _L9= 0.0;
    _L10= 1.0;
  tel
  
  function #pragma kcg expand #end InRangeInIn(IRII_Input : 'T; A : 'T; B : 'T)
    returns (IRII_Output : bool)
    where 'T numeric
  var
    _L10 : 'T;
    _L12 : bool;
    _L13 : 'T;
    _L2 : bool;
    _L4 : bool;
    _L8 : 'T;
  let
    _L2= _L12 and _L4;
    _L4= _L8 >= _L10;
    _L8= IRII_Input;
    IRII_Output= _L2;
    _L10= A;
    _L12= _L13 >= _L8;
    _L13= B;
    assume A1 : A <= B;
  tel
  
  function #pragma kcg expand #end InRangeInOut(IRIO_Input : 'T; A : 'T; B : 'T)
    returns (IRIO_Output : bool)
    where 'T numeric
  var
    _L3 : 'T;
    _L14 : bool;
    _L13 : 'T;
    _L12 : 'T;
    _L10 : bool;
    _L17 : bool;
  let
    _L3= IRIO_Input;
    _L14= _L3 >= _L12;
    _L13= B;
    _L12= A;
    _L10= _L17 and _L14;
    IRIO_Output= _L10;
    _L17= _L13 > _L3;
    assume A1 : A <= B;
  tel
  
  function #pragma kcg expand #end InRangeOutIn(IROI_Input : 'T; A : 'T; B : 'T)
    returns (IROI_Output : bool)
    where 'T numeric
  var
    _L3 : 'T;
    _L7 : bool;
    _L29 : bool;
    _L24 : 'T;
    _L23 : 'T;
    _L30 : bool;
  let
    _L3= IROI_Input;
    IROI_Output= _L29;
    _L7= _L3 > _L23;
    _L29= _L30 and _L7;
    _L24= B;
    _L23= A;
    _L30= _L24 >= _L3;
    assume A1 : A <= B;
  tel
  
  function #pragma kcg expand #end InRangeOutOut(
      IROO_Input : 'T;
      A : 'T;
      B : 'T)
    returns (IROO_Output : bool)
    where 'T numeric
  var
    _L3 : 'T;
    _L29 : bool;
    _L28 : bool;
    _L24 : 'T;
    _L23 : 'T;
    _L30 : bool;
  let
    _L3= IROO_Input;
    IROO_Output= _L29;
    _L29= _L28 and _L30;
    _L28= _L24 > _L3;
    _L24= B;
    _L23= A;
    _L30= _L3 > _L23;
    assume A1 : A <= B;
  tel
  
  function #pragma kcg expand #end Max(I1 : 'T; I2 : 'T)
    returns (Ma_Output : 'T)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : bool;
    _L4 : 'T;
  let
    _L1= I1;
    _L2= I2;
    _L3= _L1 >= _L2;
    _L4= if _L3 then _L1 else _L2;
    Ma_Output= _L4;
  tel
  
  function Max3(I1 : 'T; I2 : 'T; I3 : 'T)
    returns (Ma3_Output : 'T)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : bool;
    _L5 : bool;
    _L6 : bool;
    _L7 : bool;
    _L8 : 'T;
    _L9 : 'T;
  let
    _L1= I1;
    _L2= I2;
    _L3= I3;
    _L4= _L1 >= _L2;
    _L5= _L1 >= _L3;
    _L6= _L2 >= _L3;
    _L7= _L4 and _L5;
    _L8= if _L7 then _L1 else _L9;
    _L9= if _L6 then _L2 else _L3;
    Ma3_Output= _L8;
  tel
  
  function #pragma kcg expand #end Mean3(I1 : 'T; I2 : 'T; I3 : 'T)
    returns (Me3_Output : real)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : 'T;
    _L5 : real;
    _L6 : 'T;
  let
    _L1= I1;
    _L2= I2;
    _L3= I3;
    _L4= _L1 + _L2 + _L3;
    _L5= _L4 / _L6;
    _L6= (3 : 'T);
    Me3_Output= _L5;
  tel
  
  function #pragma kcg expand #end Min(I1 : 'T; I2 : 'T)
    returns (Mi_Output : 'T)
    where 'T numeric
  var
    _L21 : 'T;
    _L22 : 'T;
    _L24 : 'T;
    _L25 : bool;
  let
    _L21= I1;
    _L22= I2;
    _L24= if _L25 then _L21 else _L22;
    _L25= _L21 <= _L22;
    Mi_Output= _L24;
  tel
  
  function Min3(I1 : 'T; I2 : 'T; I3 : 'T)
    returns (Mi3_Output : 'T)
    where 'T numeric
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : 'T;
    _L5 : 'T;
    _L6 : 'T;
    _L7 : bool;
    _L8 : 'T;
    _L9 : 'T;
  let
    _L1= _L4 <= _L5;
    _L2= _L4 <= _L6;
    _L3= _L5 <= _L6;
    _L4= I1;
    _L5= I2;
    _L6= I3;
    _L7= _L1 and _L2;
    _L8= if _L7 then _L4 else _L9;
    _L9= if _L3 then _L5 else _L6;
    Mi3_Output= _L8;
  tel
  
  function Sign(S_Input : real) returns (S_Ouput : real)
  var
    _L1 : real;
    _L15 : real;
    _L16 : real;
    _L4 : bool;
    _L5 : bool;
    _L7 : real;
    _L8 : real;
    _L20 : real;
    _L21 : real;
  let
    _L1= S_Input;
    _L4= _L1 > _L15;
    _L5= _L15 = _L1;
    S_Ouput= _L7;
    _L7= if _L4 then _L16 else _L8;
    _L8= if _L5 then _L21 else _L20;
    _L15= 0.0;
    _L16= 1.0;
    _L20= -1.0;
    _L21= 0.0;
  tel
  
  function #pragma kcg expand #end Mean(I1 : 'T; I2 : 'T)
    returns (Me_output : real)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : real;
    _L4 : 'T;
    _L5 : 'T;
  let
    _L1= I1;
    _L2= I2;
    _L3= _L4 / _L5;
    _L4= _L1 + _L2;
    _L5= (2 : 'T);
    Me_output= _L3;
  tel
  
  function Round(R_Input : real) returns (R_Output : int)
  var
    _L2 : bool;
    _L4 : real;
    _L5 : real;
    _L7 : real;
    _L8 : int;
    _L9 : real;
    _L10 : int;
    _L12 : real;
    _L17 : real;
    _L22 : real;
    _L21 : real;
    _L20 : real;
    _L19 : real;
    _L18 : bool;
    _L25 : real;
    _L26 : real;
    _L27 : bool;
    _L34 : real;
  let
    _L2= _L12 >= _L17;
    _L4= if _L2 then _L5 else _L34;
    _L5= _L34 + _L7;
    _L7= 1.0;
    _L8= int  _L25;
    R_Output= _L8;
    _L9= R_Input;
    _L10= int  _L9;
    _L12= _L9 - _L34;
    _L17= 0.5;
    _L22= _L34 - _L21;
    _L21= 1.0;
    _L20= -0.5;
    _L19= if _L18 then _L22 else _L34;
    _L18= _L12 <= _L20;
    _L25= if _L27 then _L19 else _L4;
    _L26= 0.0;
    _L27= _L12 < _L26;
    _L34= real  _L10;
  tel
  
  function OctetToInt(
      b1 : bool;
      b2 : bool;
      b3 : bool;
      b4 : bool;
      b5 : bool;
      b6 : bool;
      b7 : bool;
      b8 : bool)
    returns (OTI_Output : int)
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : bool;
    _L5 : int;
    _L6 : int;
    _L7 : int;
    _L10 : int;
    _L9 : int;
    _L8 : int;
    _L13 : int;
    _L12 : int;
    _L11 : int;
    _L16 : int;
    _L15 : int;
    _L14 : int;
    _L17 : int;
    _L18 : int;
    _L19 : int;
    _L23 : int;
    _L22 : int;
    _L21 : int;
    _L20 : int;
    _L31 : int;
    _L30 : int;
    _L29 : int;
    _L28 : int;
    _L32 : int;
    _L33 : bool;
    _L34 : bool;
    _L35 : bool;
    _L36 : bool;
    _L40 : int;
    _L39 : int;
    _L38 : int;
    _L37 : int;
    _L43 : int;
    _L42 : int;
    _L41 : int;
  let
    _L1= b1;
    _L2= b2;
    _L3= b3;
    _L4= b4;
    _L5= if _L1 then _L6 else _L7;
    _L6= 1;
    _L7= 0;
    _L10= 2;
    _L9= 0;
    _L8= if _L2 then _L10 else _L9;
    _L13= 4;
    _L12= 0;
    _L11= if _L3 then _L13 else _L12;
    _L16= 8;
    _L15= 0;
    _L14= if _L4 then _L16 else _L15;
    _L17= _L11 + _L32;
    _L18= _L8 + _L17;
    _L19= _L5 + _L18;
    OTI_Output= _L19;
    _L23= 0;
    _L22= 16;
    _L21= _L20 + _L29;
    _L20= if _L33 then _L22 else _L23;
    _L31= 0;
    _L30= 32;
    _L29= _L28 + _L40;
    _L28= if _L34 then _L30 else _L31;
    _L32= _L14 + _L21;
    _L33= b5;
    _L34= b6;
    _L35= b7;
    _L36= b8;
    _L40= _L37 + _L43;
    _L39= 64;
    _L38= 0;
    _L37= if _L35 then _L39 else _L38;
    _L43= if _L36 then _L42 else _L41;
    _L42= 128;
    _L41= 0;
  tel
  
  function RoundCeil(RC_Input : real) returns (RC_Output : int)
  var
    _L1 : real;
    _L2 : bool;
    _L3 : real;
    _L4 : int;
    _L6 : int;
    _L7 : real;
    _L9 : int;
    _L10 : real;
    _L11 : int;
    _L12 : real;
    _L14 : bool;
  let
    _L1= RC_Input;
    _L2= _L1 <= _L3;
    _L3= 0.0;
    _L4= if _L2 then _L6 else _L9;
    _L6= int  _L1;
    _L7= real  _L6;
    _L9= if _L14 then _L6 else _L11;
    _L10= _L1 + _L12;
    _L11= int  _L10;
    _L12= 1.0;
    RC_Output= _L4;
    _L14= _L7 = _L1;
  tel
  
  function RoundFloor(RF_Input : real) returns (RF_Output : int)
  var
    _L1 : real;
    _L24 : bool;
    _L25 : real;
    _L26 : int;
    _L30 : real;
    _L31 : real;
    _L32 : int;
    _L33 : int;
    _L38 : int;
    _L41 : real;
    _L43 : bool;
  let
    _L1= RF_Input;
    RF_Output= _L26;
    _L24= _L1 >= _L25;
    _L25= 0.0;
    _L26= if _L24 then _L33 else _L38;
    _L30= _L1 - _L31;
    _L31= 1.0;
    _L32= int  _L30;
    _L33= int  _L1;
    _L38= if _L43 then _L33 else _L32;
    _L41= real  _L33;
    _L43= _L41 = _L1;
  tel
  
  function #pragma kcg expand #end IntToBool(ITB_Input : int)
    returns (ITB_Output : bool)
  var
    _L1 : int;
    _L2 : bool;
    _L3 : int;
  let
    _L1= ITB_Input;
    _L2= _L1 <> _L3;
    ITB_Output= _L2;
    _L3= 0;
  tel
  
  function #pragma kcg expand #end RealToBool(RTB_Input : real)
    returns (RTB_Output : bool)
  var
    _L3 : bool;
    _L2 : real;
    _L1 : real;
  let
    _L3= _L2 <> _L1;
    _L2= RTB_Input;
    _L1= 0.0;
    RTB_Output= _L3;
  tel
  
end;

/* $*************** KCG Version 6.1.2 (build i5) ****************
** -
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */
/* $*************** KCG Version 6.1.2 (build i5) ****************
** Command: x2s612 C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/libmathext/mathext.xscade
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */

/* xscade source: C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/libmathext/mathext.xscade */
package mathext
  function imported #pragma kcg name AcosR_mathext #end AcosR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name AcoshR_mathext #end AcoshR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name AsinR_mathext #end AsinR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name AsinhR_mathext #end AsinhR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name Atan2R_mathext #end Atan2R(
      Input1 : real;
      Input2 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name AtanR_mathext #end AtanR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name AtanhR_mathext #end AtanhR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name CosR_mathext #end CosR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name CoshR_mathext #end CoshR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name ExpR_mathext #end ExpR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name LnR_mathext #end LnR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name LogR_mathext #end LogR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name PowerRR_mathext #end PowerRR(
      P_Input : real;
      Power : real)
    returns (P_Output : real);
  
  function imported #pragma kcg name SinR_mathext #end SinR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name SinhR_mathext #end SinhR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name SqrtR_mathext #end SqrtR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name TanR_mathext #end TanR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name TanhR_mathext #end TanhR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name TenPowR_mathext #end TenPowR(Input1 : real)
    returns (Output1 : real);
  
  function Square(Square_In : 'T) returns (Square_Out : 'T) where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
  let
    _L1= Square_In;
    _L2= _L1 * _L1;
    Square_Out= _L2;
  tel
  
  function Inv(Inv_In : 'T) returns (Inv_Out : real) where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : real;
  let
    _L1= Inv_In;
    _L2= (1 : 'T);
    _L3= _L2 / _L1;
    Inv_Out= _L3;
  tel
  
  function HypotR(HypotR_I1 : real; HypotR_I2 : real) returns (HypotR_O : real)
  var
    _L1 : real;
    _L2 : real;
    _L3 : real;
    _L4 : real;
    _L5 : real;
    _L6 : real;
  let
    _L1= HypotR_I2;
    _L2= HypotR_I1;
    _L3= _L2 * _L2;
    _L4= _L1 * _L1;
    _L5= _L3 + _L4;
    _L6= #4 SqrtR(_L5);
    HypotR_O= _L6;
  tel
  
  function imported #pragma kcg name PowerI_mathext #end PowerI(
      P_Input : int;
      Power : int)
    returns (P_Output : int);
  
  function imported #pragma kcg name PowerR_mathext #end PowerR(
      P_Input : real;
      Power : int)
    returns (P_Output : real);
  
  function #pragma kcg expand #end SinCosR(Input1 : real)
    returns (Output1 : real; Output2 : real)
  var
    _L1 : real;
    _L2 : real;
    _L3 : real;
  let
    _L1= Input1;
    _L2= #1 SinR(_L1);
    _L3= #1 CosR(_L1);
    Output1= _L2;
    Output2= _L3;
  tel
  
end;

/* $*************** KCG Version 6.1.2 (build i5) ****************
** -
** Generation date: 2011-03-07T21:45:04
*************************************************************$ */
/* $*************** KCG Version 6.1.2 (build i5) ****************
** Command: x2s612 C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/libpwlinear/pwlinear.xscade
** Generation date: 2011-03-07T21:45:05
*************************************************************$ */

/* xscade source: C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/libpwlinear/pwlinear.xscade */
package pwlinear
  function DeadBandSymmetrical(DBS_Input : 'T; Tolerance : 'T)
    returns (DBS_Output : 'T)
    where 'T numeric
  var
    _L26 : 'T;
    _L25 : bool;
    _L22 : 'T;
    _L20 : 'T;
    _L19 : 'T;
    _L18 : bool;
    _L17 : 'T;
    _L30 : 'T;
    _L31 : 'T;
    _L34 : 'T;
  let
    _L17= if _L25 then _L20 else _L26;
    _L18= _L34 >= _L30;
    _L19= _L34 - _L30;
    _L20= _L30 + _L34;
    _L22= (0 : 'T);
    _L25= _L31 >= _L34;
    _L26= if _L18 then _L19 else _L22;
    _L30= Tolerance;
    _L31= - _L30;
    DBS_Output= _L17;
    _L34= DBS_Input;
  tel
  
  function DeadBandUnSymmetrical(DBUS_Input : 'T; LowTol : 'T; HiTol : 'T)
    returns (DBUS_Output : 'T)
    where 'T numeric
  var
    _L10 : 'T;
    _L8 : 'T;
    _L7 : 'T;
    _L5 : 'T;
    _L3 : bool;
    _L2 : bool;
    _L1 : 'T;
    _L11 : 'T;
    _L13 : 'T;
    _L15 : 'T;
  let
    _L10= DBUS_Input;
    _L8= (0 : 'T);
    _L7= HiTol;
    DBUS_Output= _L1;
    _L5= if _L3 then _L13 else _L8;
    _L3= _L10 >= _L7;
    _L2= _L11 >= _L10;
    _L1= if _L2 then _L15 else _L5;
    _L11= LowTol;
    _L13= _L10 - _L7;
    _L15= _L10 - _L11;
    assume A1 : LowTol <= HiTol;
  tel
  
  function #pragma kcg expand #end LimiterUnSymmetrical(
      LUS_Input : 'T;
      LowLimit : 'T;
      HighLimit : 'T)
    returns (LUS_Output : 'T)
    where 'T numeric
  var
    _L1 : bool;
    _L11 : 'T;
    _L13 : 'T;
    _L15 : 'T;
    _L2 : bool;
    _L3 : 'T;
    _L9 : 'T;
  let
    _L1= _L3 >= _L15;
    _L2= _L3 <= _L13;
    _L3= LUS_Input;
    _L9= if _L1 then _L15 else _L11;
    _L11= if _L2 then _L13 else _L3;
    _L13= LowLimit;
    _L15= HighLimit;
    LUS_Output= _L9;
    assume A1 : LowLimit <= HighLimit;
  tel
  
  function PreLoadSymmetrical(PLS_Input : 'T; Offset : 'T; Slope : 'T)
    returns (PLS_Output : 'T)
    where 'T numeric
  var
    _L1 : bool;
    _L10 : 'T;
    _L2 : 'T;
    _L4 : 'T;
    _L5 : 'T;
    _L6 : 'T;
    _L8 : 'T;
    _L9 : 'T;
    _L12 : 'T;
  let
    _L1= _L6 > _L12;
    _L2= if _L1 then _L10 else _L5;
    _L4= _L8 + _L2;
    _L5= - _L10;
    _L6= PLS_Input;
    _L8= _L6 * _L9;
    _L9= Slope;
    _L10= Offset;
    PLS_Output= _L4;
    _L12= (0 : 'T);
  tel
  
  function #pragma kcg expand #end PreLoadUnSymmetrical(
      PLUS_Input : 'T;
      NegOffset : 'T;
      PosOffset : 'T;
      Slope : 'T)
    returns (PLUS_Output : 'T)
    where 'T numeric
  var
    _L1 : 'T;
    _L12 : 'T;
    _L14 : 'T;
    _L15 : 'T;
    _L4 : bool;
    _L5 : 'T;
    _L7 : 'T;
    _L9 : 'T;
    _L16 : 'T;
  let
    _L1= PLUS_Input;
    PLUS_Output= _L7;
    _L4= _L1 < _L16;
    _L5= if _L4 then _L12 else _L15;
    _L7= _L9 + _L5;
    _L9= _L1 * _L14;
    _L12= NegOffset;
    _L14= Slope;
    _L15= PosOffset;
    _L16= (0 : 'T);
  tel
  
  node ClockCounter(Reset : bool) returns (Count : int)
  var
    _L1 : int;
    _L2 : int;
    _L6 : int;
    _L7 : int;
    _L8 : int;
    _L11 : int;
    _L13 : bool;
    _L16 : int;
  let
    _L2= if _L13 then _L16 else _L7;
    Count= _L1;
    _L6= pre _L1;
    _L7= _L8 + _L6;
    _L8= 1;
    _L1= _L11 -> _L2;
    _L11= 0;
    _L13= Reset;
    _L16= 0;
  tel
  
  function Quantizer(Q_Input : real; Interval : real) returns (Q_Output : real)
  var
    _L8 : real;
    _L11 : real;
    _L12 : real;
    _L13 : real;
    _L142 : real;
    _L140 : bool;
    _L139 : real;
    _L138 : real;
    _L137 : real;
    _L136 : real;
    _L135 : real;
    _L134 : real;
    _L133 : int;
    _L130 : real;
    _L129 : bool;
    _L128 : real;
    _L127 : real;
    _L126 : real;
    _L125 : bool;
    _L124 : real;
  let
    _L8= Q_Input;
    Q_Output= _L13;
    _L11= Interval;
    _L12= _L8 / _L11;
    _L13= _L136 * _L11;
    _L142= _L12 - _L124;
    _L140= _L142 <= _L137;
    _L139= _L124 - _L126;
    _L138= 1.0;
    _L137= -0.5;
    _L136= if _L125 then _L134 else _L127;
    _L135= _L124 + _L138;
    _L134= if _L140 then _L139 else _L124;
    _L133= int  _L12;
    _L130= 0.0;
    _L129= _L142 >= _L128;
    _L128= 0.5;
    _L127= if _L129 then _L135 else _L124;
    _L126= 1.0;
    _L125= _L142 < _L130;
    _L124= real  _L133;
    assume A1 : Interval <> 0.0;
  tel
  
  node RateLimiter(
      RL_Input : real;
      Rising : real;
      Falling : real;
      deltaT : real)
    returns (RL_Output : real)
  var
    _L1 : real;
    _L6 : real;
    _L7 : real;
    _L8 : bool;
    _L9 : real;
    _L10 : real;
    _L12 : bool;
    _L13 : real;
    _L14 : real;
    _L38 : real;
    _L40 : real;
    _L41 : real;
    _L42 : real;
    _L46 : real;
    _L47 : real;
  let
    _L1= RL_Input;
    RL_Output= _L9;
    _L6= Rising;
    _L7= Falling;
    _L8= _L38 < _L7;
    _L9= if _L8 then _L10 else _L13;
    _L12= _L38 > _L6;
    _L13= if _L12 then _L14 else _L1;
    _L10= _L46 + _L41;
    _L14= _L46 + _L42;
    _L38= _L47 / _L40;
    _L40= deltaT;
    _L41= _L7 * _L40;
    _L42= _L6 * _L40;
    _L46= fby(_L9; 1; _L1);
    _L47= _L1 - _L46;
    assume A1 : Falling <= Rising;
  tel
  
  node Counter(Incr : 'T; Reset : bool) returns (Count : 'T) where 'T numeric
  var
    _L2 : 'T;
    _L3 : bool;
    _L4 : 'T;
    _L9 : 'T;
    _L18 : 'T;
    _L46 : 'T;
  let
    _L2= Incr;
    _L3= Reset;
    Count= _L9;
    _L4= if _L3 then _L46 else _L18;
    _L9= _L4 + _L2;
    _L18= fby(_L9; 1; _L46);
    _L46= (0 : 'T);
  tel
  
  node FallingHysteresis(LL : 'T; FH_Input : 'T; UL : 'T; Init : bool)
    returns (FH_Output : bool)
    where 'T numeric
  var
    _L10 : bool;
    _L9 : bool;
    _L6 : bool;
    _L5 : bool;
    _L4 : bool;
    _L3 : 'T;
    _L2 : 'T;
    _L1 : 'T;
    _L16 : bool;
    _L17 : bool;
  let
    _L10= _L2 < _L3;
    _L9= _L2 <= _L1;
    _L6= pre _L17;
    _L5= _L4 -> _L6;
    _L4= Init;
    FH_Output= _L17;
    _L3= LL;
    _L2= FH_Input;
    _L1= UL;
    _L16= _L9 and _L5;
    _L17= _L10 or _L16;
    assume A1 : LL <= UL;
  tel
  
  node RisingHysteresis(UL : 'T; A : 'T; LL : 'T; Init : bool)
    returns (S : bool)
    where 'T numeric
  var
    _L6 : 'T;
    _L7 : 'T;
    _L8 : 'T;
    _L9 : bool;
    _L10 : bool;
    _L11 : bool;
    _L15 : bool;
    _L16 : bool;
    _L22 : bool;
    _L24 : bool;
  let
    _L6= UL;
    _L7= A;
    _L8= LL;
    S= _L24;
    _L9= Init;
    _L10= _L9 -> _L11;
    _L11= pre _L24;
    _L15= _L7 > _L6;
    _L16= _L7 >= _L8;
    _L22= _L16 and _L10;
    _L24= _L15 or _L22;
    assume A1 : UL <= LL;
  tel
  
  function #pragma kcg expand #end LimiterSymmetrical(
      LS_Input : 'T;
      BandOrigin : 'T;
      Tolerance : 'T)
    returns (LS_Output : 'T)
    where 'T numeric
  var
    Upper_limit : 'T;
    lower_limit : 'T;
    _L1 : bool;
    _L10 : 'T;
    _L2 : bool;
    _L5 : 'T;
    _L7 : 'T;
    _L8 : 'T;
    _L9 : 'T;
  let
    _L1= _L8 >= Upper_limit;
    _L2= _L8 <= lower_limit;
    lower_limit= _L9 - _L10;
    Upper_limit= _L10 + _L9;
    _L5= if _L1 then Upper_limit else _L7;
    _L7= if _L2 then lower_limit else _L8;
    _L8= LS_Input;
    LS_Output= _L5;
    _L9= BandOrigin;
    _L10= Tolerance;
  tel
  
end;

/* $*************** KCG Version 6.1.2 (build i5) ****************
** -
** Generation date: 2011-03-07T21:45:05
*************************************************************$ */
/* $*************** KCG Version 6.1.2 (build i5) ****************
** Command: x2s612 C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/libpwlinear/lut.xscade
** Generation date: 2011-03-07T21:45:05
*************************************************************$ */

/* xscade source: C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/libpwlinear/lut.xscade */
package lut
  type LutIndex = { k : int, f : real };
  
  function Interp1D<<Xs>>(IdxX : LutIndex; Y : real^Xs) returns (OutY : real)
  var
    Idx : int;
    _L23 : real;
    _L29 : int;
    _L28 : int;
    _L27 : int;
    _L26 : int;
    _L25 : real;
    _L21 : real^Xs;
    _L20 : real;
    _L16 : real;
    _L2 : LutIndex;
    _L15 : real;
    _L6 : real;
    _L5 : int;
  let
    _L23= (_L21.[_L28] default 0.0);
    _L29= 1;
    _L28= _L29 + _L27;
    _L27= Idx;
    _L26= Idx;
    _L25= (_L21.[_L26] default 0.0);
    _L21= Y;
    _L20= _L23 - _L25;
    Idx= _L5;
    _L16= _L15 + _L25;
    _L2= IdxX;
    OutY= _L16;
    _L15= _L6 * _L20;
    _L5, _L6= (flatten LutIndex)(_L2);
    assume A1 : 0 <= Idx and Idx < Xs - 1;
  tel
  
  function Interp2DFloor<<Xs, Ys>>(
      IdxX : LutIndex;
      IdxY : LutIndex;
      Z : real^Ys^Xs)
    returns (OutZ : real)
  var
    i : int;
    j : int;
    Fx : real;
    Fy : real;
    _L1 : LutIndex;
    _L2 : LutIndex;
    _L6 : real;
    _L5 : int;
    _L7 : int;
    _L8 : real;
    _L11 : real;
    _L16 : real;
    _L21 : real;
    _L18 : real;
    _L45 : real;
    _L47 : real;
    _L48 : real;
    _L49 : real;
    _L50 : real;
    _L53 : bool;
    _L54 : real;
    _L56 : real;
    _L55 : bool;
  let
    _L1= IdxX;
    _L2= IdxY;
    _L5, _L6= (flatten LutIndex)(_L1);
    i= _L5;
    j= _L7;
    _L7, _L8= (flatten LutIndex)(_L2);
    Fx= _L6;
    Fy= _L8;
    _L11= (Z.[i + 1][j] default 0.0);
    _L16= (Z.[i][j] default 0.0);
    _L18= (Z.[i + 1][j + 1] default 0.0);
    _L21= (Z.[i][j + 1] default 0.0);
    OutZ= _L48;
    _L45= Fx;
    _L47= Fy;
    _L48= if _L53 then _L49 else _L50;
    _L49= if _L55 then _L16 else _L11;
    _L50= if _L55 then _L21 else _L18;
    _L54= 1.0;
    _L56= 1.0;
    _L53= _L47 < _L54;
    _L55= _L45 < _L56;
    assume A2 : 0 <= j and j < Ys - 1;
    assume A1 : 0 <= i and i < Xs - 1;
  tel
  
  function PreLutDirect(
      InX : real;
      Orig : real;
      Step : real;
      NbElem : int;
      Extrapol : bool)
    returns (OutIndex : LutIndex)
  var
    bLow : bool;
    bHigh : bool;
    F0 : real;
    N : int;
    _L1 : real;
    _L17 : bool;
    _L45 : bool;
    _L48 : LutIndex;
    _L49 : int;
    _L56 : bool;
    _L71 : int;
    _L75 : LutIndex;
    _L86 : LutIndex;
    _L87 : int;
    _L88 : real;
    _L89 : bool;
    _L93 : int;
    _L92 : real;
    _L94 : LutIndex;
    _L98 : LutIndex;
    _L100 : LutIndex;
    _L103 : real;
    _L162 : LutIndex;
    _L163 : LutIndex;
    _L165 : real;
    _L164 : real;
    _L166 : real;
    _L167 : real;
    _L169 : real;
    _L171 : int;
    _L173 : int;
    _L174 : bool;
    _L175 : real;
    _L176 : real;
    _L177 : real;
    _L182 : LutIndex;
    _L180 : real;
    _L178 : real;
    _L181 : int;
    _L184 : int;
    _L185 : int;
    _L186 : real;
    _L187 : real;
    _L172 : int;
  let
    _L1= InX;
    bLow= _L17;
    _L45= bLow;
    _L48= (make LutIndex)(_L49, _L175);
    _L49= 0;
    _L56= bHigh;
    _L71= NbElem - 2;
    _L75= (make LutIndex)(_L71, _L177);
    _L86= (make LutIndex)(_L87, _L88);
    _L87= 0;
    _L88= 0.0;
    _L89= Extrapol;
    _L92= 1.0;
    _L93= NbElem - 2;
    OutIndex= _L98;
    _L94= (make LutIndex)(_L93, _L92);
    _L98= if _L45 then _L163 else _L100;
    _L100= if _L56 then _L162 else _L182;
    _L17= _L1 <= _L103;
    _L103= Orig;
    _L162= if _L89 then _L75 else _L94;
    _L163= if _L89 then _L48 else _L86;
    F0= _L167;
    _L164= InX;
    _L165= Orig;
    _L166= _L164 - _L165;
    _L167= _L166 / _L169;
    _L169= Step;
    _L171= int  _L167;
    N= _L171;
    _L173= NbElem;
    bHigh= _L174;
    _L175= F0;
    _L176= F0;
    _L182= (make LutIndex)(_L181, _L178);
    _L180= F0;
    _L178= _L180 - _L186;
    _L181= N;
    _L184= N;
    _L177= _L176 - _L187;
    _L185= NbElem - 2;
    _L186= real  _L184;
    _L187= real  _L185;
    _L174= _L172 > _L173;
    _L172= N;
  tel
  
  function private #pragma kcg expand #end CalculateFloor(
      Acc : real;
      InX : real;
      X : real;
      Y : real)
    returns (Out : real)
  var
    _L8 : real;
    _L40 : real;
    _L77 : bool;
    _L84 : real;
    _L85 : real;
    _L74 : real;
  let
    _L8= Acc;
    _L40= InX;
    Out= _L84;
    _L84= if _L77 then _L8 else _L85;
    _L85= Y;
    _L77= _L40 < _L74;
    _L74= X;
  tel
  
  function Lut1DCeil<<Xs>>(InX : real; X : real^Xs; Y : real^Xs)
    returns (OutY : real)
  var
    i : int;
    _L191 : real^Xs;
    _L190 : real^Xs;
    _L189 : real;
    _L186 : int;
    _L192 : real;
    _L193 : real^Xs;
    _L194 : real^Xs;
    _L198 : int;
    _L197 : int;
    _L199 : int;
    _L200 : int;
  let
    OutY= _L192;
    _L186= 0;
    i= (foldi #1 SearchIdxCeil <<Xs>>)(_L186, _L191, _L194);
    _L189= InX;
    _L190= X;
    _L191= _L189^Xs;
    _L192= (_L193.[_L199] default 0.0);
    _L193= Y;
    _L194= reverse _L190;
    _L197= _L198 - i;
    _L198= Xs;
    _L199= _L197 - _L200;
    _L200= 1;
  tel
  
  function private CalculateNearest(
      Acc : real;
      InX : real;
      Xi1 : real;
      Xi2 : real;
      Yi1 : real;
      Yi2 : real)
    returns (Out : real)
  var
    _L8 : real;
    _L40 : real;
    _L74 : real;
    _L77 : bool;
    _L84 : real;
    _L85 : real;
    _L87 : real;
    _L88 : real;
    _L89 : real;
    _L91 : real;
    _L98 : real;
    _L99 : real;
    _L100 : real;
    _L101 : bool;
  let
    _L8= Acc;
    _L40= InX;
    _L74= Xi1;
    Out= _L84;
    _L84= if _L77 then _L8 else _L98;
    _L85= Xi2;
    _L87= Xi1;
    _L88= Yi1;
    _L89= Yi2;
    _L91= InX;
    _L98= if _L101 then _L88 else _L89;
    _L100= _L91 - _L87;
    _L99= _L85 - _L91;
    _L101= _L99 > _L100;
    _L77= _L40 < _L74;
  tel
  
  function Lut1DNearest<<Xs>>(InX : real; X : real^Xs; Y : real^Xs)
    returns (OutY : real)
  var
    i : int;
    _L189 : real^(Xs - 2 - 0 + 1);
    _L188 : real^(Xs - 1 - 1 + 1);
    _L187 : real;
    _L185 : int;
    _L184 : real^(Xs - 1);
    _L191 : real^Xs;
    _L190 : real;
  let
    _L184= _L187^(Xs - 1);
    _L185= 0;
    i= (foldi #1 SearchNearest <<Xs - 1>>)(_L185, _L184, _L189, _L188);
    _L187= InX;
    _L188= X [1 .. Xs - 1];
    _L189= X [0 .. Xs - 2];
    OutY= _L190;
    _L190= (_L191.[i] default 0.0);
    _L191= Y;
  tel
  
  function private #pragma kcg expand #end CalculateCeil(
      Acc : real;
      InX : real;
      X : real;
      Y : real)
    returns (Out : real)
  var
    _L8 : real;
    _L40 : real;
    _L77 : bool;
    _L84 : real;
    _L85 : real;
    _L74 : real;
  let
    _L8= Acc;
    _L40= InX;
    Out= _L84;
    _L84= if _L77 then _L8 else _L85;
    _L85= Y;
    _L74= X;
    _L77= _L40 <= _L74;
  tel
  
  function Lut2DFloor<<Xs, Ys>>(
      InX : real;
      InY : real;
      X : real^Xs;
      Y : real^Ys;
      Z : real^Ys^Xs)
    returns (OutZ : real)
  var
    i : int;
    j : int;
    _L2 : real;
    _L6 : real;
    _L11 : int;
    _L12 : int;
    _L14 : real^Xs;
    _L15 : int;
    _L19 : int;
    _L18 : real^Ys;
    _L20 : real;
    _L22 : real^Xs;
    _L23 : real^Ys;
  let
    _L2= InX;
    _L6= InY;
    OutZ= _L20;
    _L12= 0;
    _L18= Y;
    _L19= 0;
    i= _L11;
    j= _L15;
    _L20= (Z.[i][j] default 0.0);
    _L22= _L2^Xs;
    _L23= _L6^Ys;
    _L11= (foldi #6 SearchIdxFloor <<Xs>>)(_L12, _L22, _L14);
    _L15= (foldi #8 SearchIdxFloor <<Ys>>)(_L19, _L23, _L18);
    _L14= X;
  tel
  
  function private #pragma kcg expand #end SearchIdxFloor(
      i : int;
      Acc : int;
      InX : real;
      Xi : real)
    returns (Out : int)
  var
    _L8 : int;
    _L40 : real;
    _L77 : bool;
    _L84 : int;
    _L74 : real;
    _L86 : int;
  let
    _L8= Acc;
    _L40= InX;
    Out= _L84;
    _L84= if _L77 then _L8 else _L86;
    _L74= Xi;
    _L86= i;
    _L77= _L40 < _L74;
  tel
  
  function Lut2DCeil<<Xs, Ys>>(
      InX : real;
      InY : real;
      X : real^Xs;
      Y : real^Ys;
      Z : real^Ys^Xs)
    returns (OutZ : real)
  var
    i : int;
    j : int;
    _L2 : real;
    _L6 : real;
    _L11 : int;
    _L13 : int;
    _L14 : real^Xs;
    _L15 : int;
    _L18 : real^Ys;
    _L17 : int;
    _L20 : real;
    _L22 : real^Xs;
    _L23 : real^Ys;
    _L24 : real^Xs;
    _L27 : real^Ys;
  let
    _L2= InX;
    _L6= InY;
    OutZ= _L20;
    _L13= 0;
    _L14= X;
    _L17= 0;
    _L18= Y;
    i= _L11;
    j= _L15;
    _L20= (Z.[Xs - i - 1][Ys - j - 1] default 0.0);
    _L22= _L2^Xs;
    _L23= _L6^Ys;
    _L11= (foldi #8 SearchIdxCeil <<Xs>>)(_L13, _L22, _L24);
    _L15= (foldi #10 SearchIdxCeil <<Ys>>)(_L17, _L23, _L27);
    _L24= reverse _L14;
    _L27= reverse _L18;
  tel
  
  function private #pragma kcg expand #end SearchIdxCeil(
      i : int;
      Acc : int;
      InX : real;
      Xi : real)
    returns (Out : int)
  var
    _L8 : int;
    _L40 : real;
    _L77 : bool;
    _L84 : int;
    _L74 : real;
    _L86 : int;
  let
    _L8= Acc;
    _L40= InX;
    Out= _L84;
    _L84= if _L77 then _L8 else _L86;
    _L74= Xi;
    _L86= i;
    _L77= _L40 > _L74;
  tel
  
  function private SearchNearest(
      i : int;
      Acc : int;
      InX : real;
      Xi1 : real;
      Xi2 : real)
    returns (Out : int)
  var
    _L8 : int;
    _L40 : real;
    _L74 : real;
    _L77 : bool;
    _L84 : int;
    _L85 : real;
    _L87 : real;
    _L91 : real;
    _L98 : int;
    _L99 : real;
    _L100 : real;
    _L101 : bool;
    _L102 : int;
    _L103 : int;
    _L104 : int;
  let
    _L8= Acc;
    _L40= InX;
    _L74= Xi1;
    Out= _L84;
    _L84= if _L77 then _L8 else _L98;
    _L85= Xi2;
    _L87= Xi1;
    _L91= InX;
    _L98= if _L101 then _L102 else _L103;
    _L100= _L91 - _L87;
    _L99= _L85 - _L91;
    _L101= _L99 > _L100;
    _L77= _L40 < _L74;
    _L102= i;
    _L103= _L102 + _L104;
    _L104= 1;
  tel
  
  function Lut2DNearest<<Xs, Ys>>(
      InX : real;
      InY : real;
      X : real^Xs;
      Y : real^Ys;
      Z : real^Ys^Xs)
    returns (OutZ : real)
  var
    i : int;
    j : int;
    _L2 : real;
    _L6 : real;
    _L11 : int;
    _L13 : int;
    _L14 : real^(Xs - 2 - 0 + 1);
    _L15 : int;
    _L18 : real^(Ys - 1 - 1 + 1);
    _L17 : int;
    _L20 : real;
    _L21 : real^(Xs - 1 - 1 + 1);
    _L26 : real^(Ys - 2 - 0 + 1);
    _L27 : real^(Xs - 1);
    _L28 : real^(Ys - 1);
  let
    _L2= InX;
    _L6= InY;
    OutZ= _L20;
    _L13= 0;
    _L14= X [0 .. Xs - 2];
    _L17= 0;
    _L18= Y [1 .. Ys - 1];
    i= _L11;
    j= _L15;
    _L20= (Z.[i][j] default 0.0);
    _L21= X [1 .. Xs - 1];
    _L26= Y [0 .. Ys - 2];
    _L27= _L2^(Xs - 1);
    _L28= _L6^(Ys - 1);
    _L11= (foldi #14 SearchNearest <<Xs - 1>>)(_L13, _L27, _L14, _L21);
    _L15= (foldi #17 SearchNearest <<Ys - 1>>)(_L17, _L28, _L26, _L18);
  tel
  
  function Interp1DFloor<<Xs>>(IdxX : LutIndex; Y : real^Xs)
    returns (OutY : real)
  var
    Idx : int;
    _L6 : real;
    _L5 : int;
    _L2 : LutIndex;
    _L21 : real^Xs;
    _L23 : real;
    _L25 : real;
    _L26 : int;
    _L27 : int;
    _L28 : int;
    _L29 : int;
    _L30 : real;
    _L32 : bool;
    _L33 : real;
  let
    _L5, _L6= (flatten LutIndex)(_L2);
    OutY= _L30;
    _L2= IdxX;
    Idx= _L5;
    _L21= Y;
    _L25= (_L21.[_L28] default 0.0);
    _L26= Idx;
    _L27= Idx;
    _L28= _L29 + _L27;
    _L29= 1;
    _L23= (_L21.[_L26] default 0.0);
    _L30= if _L32 then _L23 else _L25;
    _L32= _L6 < _L33;
    _L33= 1.0;
    assume A1 : 0 <= Idx and Idx < Xs - 1;
  tel
  
  function Interp2D<<Xs, Ys>>(IdxX : LutIndex; IdxY : LutIndex; Z : real^Ys^Xs)
    returns (OutZ : real)
  var
    i : int;
    j : int;
    Fx : real;
    Fy : real;
    _L1 : LutIndex;
    _L2 : LutIndex;
    _L6 : real;
    _L5 : int;
    _L7 : int;
    _L8 : real;
    _L11 : real;
    _L12 : real;
    _L13 : real;
    _L14 : real;
    _L15 : real;
    _L16 : real;
    _L21 : real;
    _L18 : real;
    _L37 : real;
    _L41 : real;
    _L40 : real;
    _L39 : real;
    _L38 : real;
    _L44 : real;
    _L43 : real;
    _L42 : real;
  let
    _L1= IdxX;
    _L2= IdxY;
    _L5, _L6= (flatten LutIndex)(_L1);
    i= _L5;
    j= _L7;
    _L7, _L8= (flatten LutIndex)(_L2);
    Fx= _L6;
    Fy= _L8;
    _L11= (Z.[i][j] default 0.0);
    _L12= _L14 + _L11;
    _L14= _L15 * _L13;
    _L15= Fx;
    _L16= (Z.[i + 1][j] default 0.0);
    _L18= (Z.[i][j + 1] default 0.0);
    _L21= (Z.[i + 1][j + 1] default 0.0);
    _L37= Fy;
    OutZ= _L43;
    _L13= _L16 - _L11;
    _L38= Fx;
    _L39= _L40 + _L18;
    _L40= _L38 * _L41;
    _L41= _L21 - _L18;
    _L42= _L39 - _L12;
    _L43= _L44 + _L12;
    _L44= _L37 * _L42;
    assume A1 : 0 <= i and i < Xs - 1;
    assume A2 : 0 <= j and j < Ys - 1;
  tel
  
  function #pragma kcg expand #end SearchIdx(
      i : int;
      AccIn : int;
      InX : real;
      X : real)
    returns (AccOut : int)
  var
    _L1 : real;
    _L2 : bool;
    _L7 : int;
    _L8 : real;
    _L9 : int;
    _L10 : int;
  let
    _L1= InX;
    _L2= _L1 >= _L8;
    _L7= i;
    AccOut= _L9;
    _L8= X;
    _L9= if _L2 then _L7 else _L10;
    _L10= AccIn;
  tel
  
  function #pragma kcg expand #end Proj<<N>>(
      Idx : int;
      Input1 : 'T^N;
      DefVal : 'T)
    returns (Output1 : 'T; Output2 : 'T)
  var
    _L1 : 'T^N;
    _L2 : int;
    _L6 : 'T;
    _L5 : 'T;
    _L4 : int;
    _L3 : int;
  let
    _L1= Input1;
    _L2= Idx;
    _L3= _L2 + _L4;
    _L4= 1;
    _L5= (_L1.[_L2] default DefVal);
    _L6= (_L1.[_L3] default DefVal);
    Output1= _L5;
    Output2= _L6;
  tel
  
  function #pragma kcg expand #end PreLutNoSat<<Xs>>(InX : real; X : real^Xs)
    returns (F : real; Idx : int)
  var
    idx : int;
    X2 : real;
    X1 : real;
    _L33 : int;
    _L39 : real^(Xs - 2 - 0 + 1);
    _L40 : real^(Xs - 1);
    _L42 : real;
    _L41 : real;
  let
    idx= (foldi #1 SearchIdx <<Xs - 1>>)(_L33, _L40, _L39);
    Idx= idx;
    _L33= 0;
    _L39= X [0 .. Xs - 2];
    _L40= InX^(Xs - 1);
    X1= _L41;
    X2= _L42;
    _L41= (X.[Idx] default 0.0);
    _L42= (X.[Idx + 1] default 0.0);
    activate IfBlock2 if X1 = X2
      then var
        _L4 : real;
      let
        F= _L4;
        _L4= 0.0;
      tel
      else var
        _L4 : real;
      let
        _L4= (InX - X1) / (X2 - X1);
        F= _L4;
      tel
    
    returns ..;
    assume A1 : (fold #2 $and$ <<Xs - 1>>)(true, (map
        #2 $<=$
        <<Xs - 1>>)(X [0 .. Xs - 2], X [1 .. Xs - 1]));
  tel
  
  function Lut2DNoSat<<Xs, Ys>>(
      InX : real;
      InY : real;
      X : real^Xs;
      Y : real^Ys;
      Z : real^Ys^Xs)
    returns (OutZ : real)
  var
    IdxX : int;
    F_X : real;
    X1Y : real^Ys;
    X2Y : real^Ys;
    X1InY : real;
    X2InY : real;
    _L22 : real;
    _L52 : real;
    _L73 : real^Ys^Xs;
    _L75 : real;
    _L78 : real;
  let
    F_X, IdxX= (#1 PreLutNoSat <<Xs>>)(_L52, X);
    _L22= #1 InterpolateLinear(F_X, X1InY, X2InY);
    OutZ= _L22;
    _L52= InX;
    _L73= Z;
    X1Y, X2Y= (#3 Proj <<Xs>>)(IdxX, _L73, 0.0^Ys);
    X1InY= (#1 Lut1DNoSat <<Ys>>)(_L75, Y, X1Y);
    _L75= InY;
    X2InY= (#3 Lut1DNoSat <<Ys>>)(_L78, Y, X2Y);
    _L78= InY;
  tel
  
  function #pragma kcg expand #end Lut2D<<Xs, Ys>>(
      InX : real;
      InY : real;
      X : real^Xs;
      Y : real^Ys;
      Z : real^Ys^Xs;
      Extrapol : bool)
    returns (OutZ : real)
  var
    Xsat : real;
    Ysat : real;
    _L52 : real;
    _L53 : real;
    _L54 : real;
  let
    activate IfBlock1 if Extrapol
      then var
        _L2 : real;
        _L3 : real;
      let
        Xsat= _L2;
        _L2= InX;
        _L3= InY;
        Ysat= _L3;
      tel
      else var
        _L1 : real;
        _L2 : real;
        _L3 : real;
        _L4 : real;
      let
        Xsat= _L2;
        _L1= InX;
        _L2= (#2 Limiter <<Xs>>)(_L1, X);
        _L3= (#3 Limiter <<Ys>>)(_L4, Y);
        _L4= InY;
        Ysat= _L3;
      tel
    
    returns ..;
    _L52= (#1 Lut2DNoSat <<Xs, Ys>>)(_L53, _L54, X, Y, Z);
    _L53= Xsat;
    _L54= Ysat;
    OutZ= _L52;
  tel
  
  function Lut1DNoSat<<Xs>>(InX : real; X : real^Xs; Y : real^Xs)
    returns (OutY : real)
  var
    Idx : int;
    _L16 : real;
    _L24 : real;
    _L25 : real;
    _L26 : real^Xs;
    _L27 : real^Xs;
    _L28 : real;
    _L29 : real;
  let
    _L25, Idx= (#1 PreLutNoSat <<Xs>>)(_L16, _L27);
    _L16= InX;
    _L24= #1 InterpolateLinear(_L25, _L29, _L28);
    OutY= _L24;
    _L26= Y;
    _L29, _L28= (#1 Proj <<Xs>>)(Idx, _L26, 0.0);
    _L27= X;
  tel
  
  function #pragma kcg expand #end Lut1D<<Xs>>(
      InX : real;
      X : real^Xs;
      Y : real^Xs;
      Extrapol : bool)
    returns (OutY : real)
  var
    Xsat : real;
    _L16 : real;
    _L18 : real;
  let
    activate IfBlock1 if Extrapol
      then var
        _L2 : real;
      let
        Xsat= _L2;
        _L2= InX;
      tel
      else var
        _L1 : real;
        _L2 : real;
      let
        Xsat= _L2;
        _L1= InX;
        _L2= (#1 Limiter <<Xs>>)(_L1, X);
      tel
    
    returns ..;
    _L16= (#1 Lut1DNoSat <<Xs>>)(_L18, X, Y);
    _L18= Xsat;
    OutY= _L16;
  tel
  
  function Limiter<<Xs>>(Val : real; Range : real^Xs)
    returns (LimitedVal : real)
  var
    _L1 : real;
    _L2 : real;
    _L3 : real;
    _L4 : bool;
    _L5 : real;
    _L6 : real;
    _L7 : bool;
  let
    _L1= Val;
    _L2= Range[0];
    _L3= Range[Xs - 1];
    _L4= _L1 < _L2;
    _L5= if _L4 then _L2 else _L6;
    _L6= if _L7 then _L3 else _L1;
    _L7= _L1 > _L3;
    LimitedVal= _L5;
  tel
  
  function #pragma kcg expand #end InterpolateLinear(
      F : real;
      Y1 : real;
      Y2 : real)
    returns (Y : real)
  var
    _L9 : real;
    _L8 : real;
    _L6 : real;
    _L11 : real;
    _L12 : real;
    _L13 : real;
  let
    _L6= _L12 - _L13;
    Y= _L9;
    _L8= _L11 * _L6;
    _L9= _L8 + _L13;
    _L11= F;
    _L12= Y2;
    _L13= Y1;
  tel
  
  function Lut3DNoSat<<Xs, Ys, Zs>>(
      InX : real;
      InY : real;
      InZ : real;
      X : real^Xs;
      Y : real^Ys;
      Z : real^Zs;
      W : real^Zs^Ys^Xs)
    returns (OutW : real)
  var
    Idx1 : int;
    F1 : real;
    _L22 : real;
    _L52 : real;
    _L73 : real^Zs^Ys^Xs;
    _L75 : real;
    _L78 : real;
    _L80 : real;
    _L81 : real^Zs^Ys;
    _L82 : real^Zs^Ys;
    _L83 : real;
    _L84 : real;
    _L85 : real;
  let
    F1, Idx1= (#1 PreLutNoSat <<Xs>>)(_L52, X);
    _L22= #1 InterpolateLinear(F1, _L85, _L84);
    OutW= _L22;
    _L52= InX;
    _L73= W;
    _L81, _L82= (#1 Proj <<Xs>>)(Idx1, _L73, 0.0^Zs^Ys);
    _L85= (#1 Lut2DNoSat <<Ys, Zs>>)(_L75, _L80, Y, Z, _L81);
    _L75= InY;
    _L84= (#2 Lut2DNoSat <<Ys, Zs>>)(_L78, _L83, Y, Z, _L82);
    _L78= InY;
    _L80= InZ;
    _L83= InZ;
  tel
  
  function #pragma kcg expand #end Lut3D<<Xs, Ys, Zs>>(
      InX : real;
      InY : real;
      InZ : real;
      X : real^Xs;
      Y : real^Ys;
      Z : real^Zs;
      W : real^Zs^Ys^Xs;
      Extrapol : bool)
    returns (OutW : real)
  var
    In1Sat : real;
    In3Sat : real;
    In2Sat : real;
    _L89 : real;
    _L90 : real;
    _L91 : real;
    _L92 : real;
  let
    activate IfBlock1 if Extrapol
      then var
        _L1 : real;
        _L2 : real;
        _L3 : real;
      let
        _L1= InX;
        _L2= InY;
        _L3= InZ;
        In1Sat= _L1;
        In2Sat= _L2;
        In3Sat= _L3;
      tel
      else var
        _L1 : real;
        _L2 : real;
        _L3 : real;
        _L4 : real;
        _L5 : real;
        _L6 : real;
      let
        _L1= InX;
        _L2= InY;
        _L3= InZ;
        In1Sat= _L4;
        In2Sat= _L5;
        In3Sat= _L6;
        _L4= (#3 Limiter <<Xs>>)(_L1, X);
        _L5= (#4 Limiter <<Ys>>)(_L2, Y);
        _L6= (#5 Limiter <<Zs>>)(_L3, Z);
      tel
    
    returns ..;
    _L89= (#1 Lut3DNoSat <<Xs, Ys, Zs>>)(_L90, _L91, _L92, X, Y, Z, W);
    _L90= In1Sat;
    _L91= In2Sat;
    _L92= In3Sat;
    OutW= _L89;
  tel
  
  function #pragma kcg expand #end PreLut<<Xs>>(
      InX : real;
      X : real^Xs;
      Extrapol : bool)
    returns (Out : LutIndex)
  var
    Xsat : real;
    _L44 : int;
    _L43 : real;
    _L45 : real;
    _L50 : LutIndex;
  let
    activate IfBlock1 if Extrapol
      then var
        _L7 : real;
      let
        Xsat= _L7;
        _L7= InX;
      tel
      else var
        _L5 : real;
        _L6 : real;
      let
        _L5= InX;
        Xsat= _L6;
        _L6= (#3 Limiter <<Xs>>)(_L5, X);
      tel
    
    returns ..;
    _L43, _L44= (#1 PreLutNoSat <<Xs>>)(_L45, X);
    _L45= Xsat;
    _L50= (make LutIndex)(_L44, _L43);
    Out= _L50;
  tel
  
  function Lut1DFloor<<Xs>>(InX : real; X : real^Xs; Y : real^Xs)
    returns (OutY : real)
  var
    i : int;
    _L188 : real^Xs;
    _L187 : real^Xs;
    _L186 : real^Xs;
    _L185 : real;
    _L184 : real;
    _L182 : int;
  let
    _L182= 0;
    i= (foldi #1 SearchIdxFloor <<Xs>>)(_L182, _L186, _L188);
    _L184= InX;
    _L185= (_L187.[i] default 0.0);
    _L186= _L184^Xs;
    _L187= Y;
    _L188= X;
    OutY= _L185;
  tel
  
end;

/* $*************** KCG Version 6.1.2 (build i5) ****************
** -
** Generation date: 2011-03-07T21:45:05
*************************************************************$ */
/* $*************** KCG Version 6.1.2 (build i5) ****************
** Command: x2s612 C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/libverif/libverif.xscade
** Generation date: 2011-03-07T21:45:05
*************************************************************$ */

/* xscade source: C:/Program Files (x86)/Esterel Technologies/SCADE 6.1.2/SCADE Suite/libraries/libverif/libverif.xscade */
package verif
  node AlwaysAfterFirstCond(Input1 : bool; Cond : bool) returns (Output1 : bool)
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : bool;
  let
    _L1= Cond;
    _L2= Input1;
    Output1= _L4;
    _L3= #1 HasNeverBeenTrue(_L1);
    _L4= _L3 or _L2;
  tel
  
  node #pragma kcg expand #end HasNeverBeenTrue(Input1 : bool)
    returns (Output1 : bool)
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : bool;
    _L5 : bool;
  let
    _L1= Input1;
    Output1= _L2;
    _L2= _L4 -> _L5;
    _L3= pre _L2;
    _L4= not _L1;
    _L5= _L4 and _L3;
  tel
  
  function #pragma kcg expand #end Implies(A : bool; B : bool)
    returns (C : bool)
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : bool;
  let
    _L1= A;
    _L2= B;
    C= _L3;
    _L3= _L4 or _L2;
    _L4= not _L1;
  tel
  
  node AtLeastNTicks(Input1 : bool; N : int) returns (Output1 : bool)
  var
    cnt : int;
    _L1 : bool;
    _L2 : int;
    _L3 : int;
    _L5 : int;
    _L6 : int;
    _L7 : int;
    _L8 : int;
    _L10 : int;
    _L11 : int;
    _L22 : int;
    _L23 : int;
    _L24 : bool;
    _L25 : bool;
    _L32 : bool;
    _L33 : int;
  let
    _L1= Input1;
    _L2= N;
    Output1= _L25;
    _L3= _L10 + _L6;
    _L5= cnt;
    _L6= _L8 -> _L7;
    _L7= pre _L5;
    _L8= 0;
    _L10= 1;
    _L11= if _L1 then _L3 else _L8;
    cnt= _L33;
    _L22= N;
    _L23= cnt;
    _L24= _L23 >= _L22;
    _L25= _L24 and _L1;
    _L32= _L11 < _L2;
    _L33= if _L32 then _L11 else _L2;
  tel
  
  node ImpliesWithinNTick(Input1 : bool; Input2 : bool; N : int)
    returns (Output1 : bool)
  var
    _L5 : bool;
    _L4 : bool;
    _L2 : bool;
    _L1 : bool;
  let
    _L5= #1 Implies(_L4, _L1);
    _L4= #2 AtLeastNTicks(_L2, N);
    Output1= _L5;
    _L2= Input1;
    _L1= Input2;
  tel
  
  node AfterNthTick<<N>>(Input1 : bool) returns (Output1 : bool)
  var
    _L6 : bool;
    _L5 : bool;
    _L4 : bool;
    _L3 : bool;
    _L2 : bool;
    _L1 : bool;
  let
    _L6= false;
    _L5= true;
    _L4= true;
    _L3= if _L2 then _L1 else _L4;
    _L2= fby(_L5; N; _L6);
    Output1= _L3;
    _L1= Input1;
  tel
  
end;

/* $*************** KCG Version 6.1.2 (build i5) ****************
** -
** Generation date: 2011-03-07T21:45:05
*************************************************************$ */
